"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/* babel-plugin-inline-import '../../../abstract/AbstractFactory.sol' */
var abstractFactory = "pragma solidity ^0.5.6;\n\ncontract AbstractFactory {\n    address internal worklist = address(0);\n\n    function setWorklist(address _worklist) public {\n        worklist = _worklist;\n    }\n\n    function newInstance(address parent, address globalFactory) public returns(address);\n    function startInstanceExecution(address processAddress) public;\n}\n";

/* babel-plugin-inline-import '../../../abstract/AbstractRegistry.sol' */
var abstractRegistry = "pragma solidity ^0.5.6;\n\ncontract AbstractRegistry {\n\n    function registerFactory(bytes32 bundleId, address factory) public;\n\n    function registerWorklist(bytes32 bundleId, address worklist) public;\n\n    function allInstances() public returns(address[] memory);\n\n    function newInstanceFor(uint nodeIndex, address parent) public returns(address);\n\n    function newBundleInstanceFor(bytes32 bundleId, address parent) public returns(address);\n\n    function bundleFor(address processInstance) public returns(bytes32);\n\n    function worklistBundleFor(address worklist) public returns(bytes32);\n\n    // Functions for Dynamic Bindings\n    function bindingPolicyFor(address processInstance) public view returns(bytes32);\n\n    function taskRoleMapFor(address processInstance) public view returns(bytes32);\n\n    function relateProcessToPolicy(bytes32 bundleId, bytes32 _taskRole, bytes32 _policy) external;\n\n    function canPerform(address actor, address processCase, uint taskIndex) external view returns(bool);\n}\n";

/* babel-plugin-inline-import '../../../abstract/AbstractWorklist.sol' */
var abstractWorklist = "pragma solidity ^0.5.6;\n\ncontract IRFunct {\n    function findRuntimePolicy(address pCase) public view returns(address);\n    function canPerform(address actor, address pCase, uint taskIndex) public view returns(bool);\n}\n\ncontract AbstractWorklist {\n\n    struct Workitem {\n        uint elementIndex;\n        address processInstanceAddr;\n    }\n\n    Workitem[] internal workitems;\n    address internal runtimeRegistry;\n\n    function updateRuntimeRegistry(address _runtimeRegistry) public {\n        runtimeRegistry = _runtimeRegistry;\n    }\n\n    function workItemsFor(uint elementIndex, address processInstance) external view returns(uint) {\n        uint reqIndex = 0;\n        for (uint i = 0; i < workitems.length; i++) {\n            if (workitems[i].elementIndex == elementIndex && workitems[i].processInstanceAddr == processInstance)\n                reqIndex |= uint(1) << i;\n        }\n        return reqIndex;\n    }\n\n    function processInstanceFor(uint workitemId) public view returns(address) {\n        require(workitemId < workitems.length);\n        return workitems[workitemId].processInstanceAddr;\n    }\n\n    function elementIndexFor(uint workitemId) public view returns(uint) {\n        require(workitemId < workitems.length);\n        return workitems[workitemId].elementIndex;\n    }\n\n    function canPerform(address actor, address pCase, uint elementIndex) internal view returns(bool) {\n        return IRFunct(IRFunct(runtimeRegistry).findRuntimePolicy(pCase)).canPerform(actor, pCase, elementIndex);\n    }\n}";

/* babel-plugin-inline-import '../../../abstract/ProcessRegistry.sol' */
var processRegistry = "pragma solidity ^0.5.6;\n\ncontract IFunct {\n    // WorkList functions\n    function updateRuntimeRegistry(address _runtimeRegistry) public;\n    // Factory Functions\n    function setWorklist(address _worklist) public;\n    function startInstanceExecution(address processAddress) public;\n    function newInstance(address parent, address globalFactory) public returns(address);\n    function findParent() public view returns(address);\n}\n\ncontract ProcessRegistry {\n\n    mapping (bytes32 => mapping (uint => bytes32)) private parent2ChildrenBundleId;\n    mapping (bytes32 => address) private factories;\n    mapping (bytes32 => bytes32) private policy;\n    mapping (bytes32 => bytes32) private taskRole;\n\n    mapping (address => bytes32) private instance2Bundle;\n    mapping (address => address) private instance2PolicyOp;\n    address[] private instances;\n\n    mapping (address => bytes32) private worklist2Bundle;\n\n    event NewInstanceCreatedFor(address parent, address processAddress);\n\n    function registerFactory(bytes32 bundleId, address factory) external {\n        factories[bundleId] = factory;\n    }\n\n    function registerWorklist(bytes32 bundleId, address worklist) external {\n        address factory = factories[bundleId];\n        require(factory != address(0));\n        worklist2Bundle[worklist] = bundleId;\n        IFunct(factory).setWorklist(worklist);\n        IFunct(worklist).updateRuntimeRegistry(address(this));\n    }\n\n    function findRuntimePolicy(address pCase) public view returns(address) {\n        return instance2PolicyOp[pCase];\n    }\n\n    function relateProcessToPolicy(bytes32 bundleId, bytes32 _policy, bytes32 _taskRole) external {\n        taskRole[bundleId] = _taskRole;\n        policy[bundleId] = _policy;\n    }\n\n\n    function addChildBundleId(bytes32 parentBundleId, bytes32 processBundleId, uint nodeIndex) external {\n        parent2ChildrenBundleId[parentBundleId][nodeIndex] = processBundleId;\n    }\n\n    function newInstanceFor(uint nodeIndex, address parent) public returns(address) {\n        return newBundleInstanceFor(parent2ChildrenBundleId[instance2Bundle[parent]][nodeIndex], parent, instance2PolicyOp[parent]);\n    }\n\n    function newBundleInstanceFor(bytes32 bundleId, address parent, address policyOpAddr) public returns(address) {\n        address factory = factories[bundleId];\n        require(factory != address(0));\n        address processAddress = IFunct(factory).newInstance(parent, address(this));\n        instance2Bundle[processAddress] = bundleId;\n        instance2PolicyOp[processAddress] = policyOpAddr;\n        instances.push(processAddress);\n        IFunct(factory).startInstanceExecution(processAddress);\n        emit NewInstanceCreatedFor(parent, processAddress);\n        return processAddress;\n    }\n\n    function allInstances() external view returns(address[] memory) {\n        return instances;\n    }\n    \n    function bindingPolicyFor(address procInstance) external view returns(bytes32) {\n        bytes32 pId = instance2Bundle[procInstance];\n        address pAddr = procInstance;\n        while(policy[pId].length != 0) {\n            pAddr = IFunct(pAddr).findParent();\n            if(pAddr == address(0))\n                break;\n            pId = instance2Bundle[pAddr];\n        }\n        return policy[pId];\n    }\n\n    function taskRoleMapFor(address procInstance) external view returns(bytes32) {\n        bytes32 pId = instance2Bundle[procInstance];\n        address pAddr = procInstance;\n        while(taskRole[pId].length != 0) {\n            pAddr = IFunct(pAddr).findParent();\n            if(pAddr == address(0))\n                break;\n            pId = instance2Bundle[pAddr];\n        }\n        return taskRole[pId];\n    }\n\n    function bindingPolicyFromId(bytes32 procId) external view returns(bytes32) {\n        return policy[procId];\n    }\n\n    function taskRoleMapFromId(bytes32 procId) external view returns(bytes32) {\n        return taskRole[procId];\n    }\n\n    function bundleFor(address processInstance) external view returns(bytes32) {\n        return instance2Bundle[processInstance];\n    }\n\n    function childrenFor(bytes32 parent, uint nodeInd) external view returns(bytes32) {\n        return parent2ChildrenBundleId[parent][nodeInd];\n    }\n\n    function worklistBundleFor(address worklist) external view returns(bytes32) {\n        return worklist2Bundle[worklist];\n    }\n}";

/* babel-plugin-inline-import '../../../abstract/AbstractProcess.sol' */
var abstractProcess = "pragma solidity ^0.5.6;\n\nimport \"AbstractRegistry\";\n\n\ncontract AbstractProcess {\n    address internal owner;\n    address internal parent;\n    address internal worklist;\n    uint internal instanceIndex;\n    address internal processRegistry;\n\n    constructor(address _parent, address _worklist, address _processRegistry) public {\n        owner = msg.sender;\n        parent = _parent;\n        worklist = _worklist;\n        processRegistry = _processRegistry;\n    }\n\n    function setInstanceIndex(uint _instanceIndex) public {\n        require(msg.sender == parent);\n        instanceIndex = _instanceIndex;\n    }\n\n    function findParent() public view returns(address) {\n        return parent;\n    }\n\n    function handleEvent(bytes32 code, bytes32 eventType, uint _instanceIndex, bool isInstanceCompleted) public;\n    function killProcess() public;\n    function startExecution() public;\n    function broadcastSignal() public;\n\n    function killProcess(uint processElementIndex, uint marking, uint startedActivities) internal returns(uint, uint);\n    function broadcastSignal(uint tmpMarking, uint tmpStartedActivities, uint sourceChild) internal returns(uint, uint);\n\n    function propagateEvent(bytes32 code, bytes32 eventType, uint tmpMarking, uint tmpStartedActivities, uint sourceChild) internal returns(uint, uint) {\n        if (eventType == \"Error\" || eventType == \"Terminate\")\n            (tmpMarking, tmpStartedActivities) = killProcess(0, tmpMarking, tmpStartedActivities);\n        else if (eventType == \"Signal\")\n            (tmpMarking, tmpStartedActivities) = broadcastSignal(tmpMarking, tmpStartedActivities, sourceChild);\n        if (parent != 0x0000000000000000000000000000000000000000)\n            AbstractProcess(parent).handleEvent(code, eventType, instanceIndex, tmpMarking | tmpStartedActivities == 0);\n        return (tmpMarking, tmpStartedActivities);\n    }\n}\n";
var _default = {
  AbstractFactory: {
    content: abstractFactory
  },
  AbstractRegistry: {
    content: abstractRegistry
  },
  AbstractWorklist: {
    content: abstractWorklist
  },
  ProcessRegistry: {
    content: processRegistry
  },
  AbstractProcess: {
    content: abstractProcess
  }
};
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2FwcC9yZXNvbHZlcnMvbXV0YXRpb24vYWRkLW1vZGVsL3NvdXJjZXMudHMiXSwibmFtZXMiOlsiQWJzdHJhY3RGYWN0b3J5IiwiY29udGVudCIsImFic3RyYWN0RmFjdG9yeSIsIkFic3RyYWN0UmVnaXN0cnkiLCJhYnN0cmFjdFJlZ2lzdHJ5IiwiQWJzdHJhY3RXb3JrbGlzdCIsImFic3RyYWN0V29ya2xpc3QiLCJQcm9jZXNzUmVnaXN0cnkiLCJwcm9jZXNzUmVnaXN0cnkiLCJBYnN0cmFjdFByb2Nlc3MiLCJhYnN0cmFjdFByb2Nlc3MiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQU9lO0FBQ2JBLEVBQUFBLGVBQWUsRUFBRTtBQUNmQyxJQUFBQSxPQUFPLEVBQUVDO0FBRE0sR0FESjtBQUliQyxFQUFBQSxnQkFBZ0IsRUFBRTtBQUNoQkYsSUFBQUEsT0FBTyxFQUFFRztBQURPLEdBSkw7QUFPYkMsRUFBQUEsZ0JBQWdCLEVBQUU7QUFDaEJKLElBQUFBLE9BQU8sRUFBRUs7QUFETyxHQVBMO0FBVWJDLEVBQUFBLGVBQWUsRUFBRTtBQUNmTixJQUFBQSxPQUFPLEVBQUVPO0FBRE0sR0FWSjtBQWFiQyxFQUFBQSxlQUFlLEVBQUU7QUFDZlIsSUFBQUEsT0FBTyxFQUFFUztBQURNO0FBYkosQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhYnN0cmFjdEZhY3RvcnkgZnJvbSAnLi4vLi4vLi4vYWJzdHJhY3QvQWJzdHJhY3RGYWN0b3J5LnNvbCdcbmltcG9ydCBhYnN0cmFjdFJlZ2lzdHJ5IGZyb20gJy4uLy4uLy4uL2Fic3RyYWN0L0Fic3RyYWN0UmVnaXN0cnkuc29sJ1xuaW1wb3J0IGFic3RyYWN0V29ya2xpc3QgZnJvbSAnLi4vLi4vLi4vYWJzdHJhY3QvQWJzdHJhY3RXb3JrbGlzdC5zb2wnXG5pbXBvcnQgcHJvY2Vzc1JlZ2lzdHJ5IGZyb20gJy4uLy4uLy4uL2Fic3RyYWN0L1Byb2Nlc3NSZWdpc3RyeS5zb2wnXG5pbXBvcnQgYWJzdHJhY3RQcm9jZXNzIGZyb20gJy4uLy4uLy4uL2Fic3RyYWN0L0Fic3RyYWN0UHJvY2Vzcy5zb2wnXG5pbXBvcnQgYmluZGluZ0FjY2Vzc0NvbnRyb2wgZnJvbSAnLi4vLi4vLi4vYWJzdHJhY3QvQmluZGluZ0FjY2Vzc0NvbnRyb2wuc29sJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEFic3RyYWN0RmFjdG9yeToge1xuICAgIGNvbnRlbnQ6IGFic3RyYWN0RmFjdG9yeSxcbiAgfSxcbiAgQWJzdHJhY3RSZWdpc3RyeToge1xuICAgIGNvbnRlbnQ6IGFic3RyYWN0UmVnaXN0cnksXG4gIH0sXG4gIEFic3RyYWN0V29ya2xpc3Q6IHtcbiAgICBjb250ZW50OiBhYnN0cmFjdFdvcmtsaXN0LFxuICB9LFxuICBQcm9jZXNzUmVnaXN0cnk6IHtcbiAgICBjb250ZW50OiBwcm9jZXNzUmVnaXN0cnksXG4gIH0sXG4gIEFic3RyYWN0UHJvY2Vzczoge1xuICAgIGNvbnRlbnQ6IGFic3RyYWN0UHJvY2VzcyxcbiAgfSxcbn1cbiJdfQ==