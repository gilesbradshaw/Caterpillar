"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _debug2 = _interopRequireDefault(require("debug"));

var _bpmnModdle = _interopRequireDefault(require("bpmn-moddle"));

var ejs = _interopRequireWildcard(require("ejs"));

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _definitions = require("./definitions");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* babel-plugin-inline-import '../../../templates/bpmn2sol.ejs' */
const bpmn2solEJS = "\nimport \"AbstractFactory\";\nimport \"AbstractProcess\";\nimport \"AbstractRegistry\";\n<% if(oracleTaskMap.size > 0) { -%>\ncontract Oracle_Wrapper {\n<% oracleTaskMap.forEach((oracleKey, nodeId, map) => { -%>\n    function <%= getOracleFunction(nodeId) %> (<%= typeParameters(nodeId, true, false) %>, function (uint<%= typeParameters(nodeId, false, true) %>) external returns(bool)) external returns(uint);\n<% }) -%>\n}\n<% } -%>\n\ncontract <%= nodeName(processId()) %>_Factory is AbstractFactory {\n    function newInstance(address parent, address processRegistry) public returns(address) {\n        <%= nodeName(processId()) %>_Contract newContract = new <%= nodeName(processId()) %>_Contract(parent, worklist, processRegistry);\n        return address(newContract);\n    }\n\n    function startInstanceExecution(address processAddress) public {\n        <%= nodeName(processId()) %>_Contract(processAddress).startExecution();\n    }\n}\n\n<% var contracts2Call = getContracts2Call();\n   var subprocessToKill = getPossibleKillSubprocess();\n   var eventsToCatch = getCatchingEvents(processId());\n   var eventTypes = allEventTypes(); -%>\n\ncontract <%= nodeName(processId()) %>_Contract is AbstractProcess {\n\n    uint public marking = uint(<%= subprocessStartMarking(processId()) %>);\n    uint public startedActivities = 0;\n<% if(contracts2Call.length > 0) { -%>\n    address[] private subInstanceAddresses;\n    mapping(uint => uint) private subInstanceStartedIndexes;\n<% } -%>\n\n<% /* --------- Solidity events to throw when an end message event is thrown  ---------------------------- */ -%>\n<% var messages = getThrowingMessages();\n   if(messages.length > 0) {\n    messages.forEach(nodeId => { -%>\n    // <%= nodeName(nodeId) %>\n    event <%= nodeId %>_Mesage(bytes32 messageText);\n<% })} -%>\n\n<% /* --------- Fields for interacting with external resources by means of callbacks (Oracle)  --------------- */ -%>\n<% if(oracleInfo.size > 0) { -%>\n    mapping(uint => address) oracleAddresses;\n<% } -%>\n    // Process Variables\n    <%= globalDeclarations() -%>\n\n    constructor(address _parent, address _worklist, address _processRegistry) public AbstractProcess(_parent, _worklist, _processRegistry) {\n<% oracleTaskMap.forEach((oracleKey, nodeId, map) => { -%>\n        oracleAddresses[<%= flowNodeIndex(nodeId) %>] = <%= oracleInfo.get(oracleKey).address %>;\n<% }) -%>\n<% if(getCountExternalTasks() > 0) { -%>\n        for (uint i = 0; i < <%= getCountExternalTasks() %>; i++)\n            requestedID.push(0);\n<% } -%>\n    }\n\n    function startExecution() public {\n        require(marking == uint(<%= subprocessStartMarking(processId()) %>) && startedActivities == 0);\n        step(uint(<%= subprocessStartMarking(processId()) %>), 0);\n    }\n\n<% /* --------------------------------- Event Handling ---------------------------------- */ -%>\n    function handleEvent(bytes32 code, bytes32 eventType, uint _instanceIndex, bool isInstanceCompleted) public {\n<% if(contracts2Call.length > 0 ) { -%>\n        (uint256 tmpMarking, uint256 tmpStartedActivities)  = (marking, startedActivities);\n        uint maskIndex = uint(1) << _instanceIndex;\n        uint sourceChild = 0;\n<%   var first = true;\n       contracts2Call.forEach(nodeId => {\n          var inFirst = true;\n          var node = nodeMap.get(nodeId); -%>\n<% if(first) { first = false; -%>        if <% } else { -%>        else if <% }-%>(subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] & uint(maskIndex) != 0) {\n            if(isInstanceCompleted)\n                subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] &= uint(~maskIndex);\n<% if(is(node, 'bpmn:BoundaryEvent')) { -%>\n<% var terminateCandidates = getTerminateCandidates(processId());\n     if(terminateCandidates.length > 0 ) {\n       terminateCandidates.forEach(bEvtId => {\n         var evtParentId = nodeMap.get(bEvtId).$parent.id;\n         if (inFirst && evtParentId === node.$parent.id) {\n            inFirst = false; -%>\n            if(eventType == \"Terminate\") {\n  <%     if(evtParentId === processId()) { -%>\n                killProcess();\n                propagateEvent('Default', 'Default', 0, 0, <%= flowNodeIndex(nodeId) %>);\n  <%     } else { -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(evtParentId) %>), tmpMarking, tmpStartedActivities);\n                step(tmpMarking | uint(<%= postMarking(evtParentId) %>), tmpStartedActivities);\n  <%     } -%>\n            }\n  <% } }) } -%>\n<% } -%>\n<% if(inFirst) { inFirst = false; -%>            if <% } else { -%>            else if <% }-%>(eventType == \"Default\") {\n<% if (node.loopCharacteristics && node.loopCharacteristics.$type === 'bpmn:MultiInstanceLoopCharacteristics') { -%>\n<%   if (node.loopCharacteristics.isSequential) { -%>\n                if(++_instanceIndex < subInstanceAddresses.length && subInstanceAddresses[_instanceIndex] == 0) {\n                    AbstractProcess child_<%= flowNodeIndex(nodeId) %> = AbstractProcess(AbstractRegistry(processRegistry).newInstanceFor(uint(<%= nodeRealIndex(nodeId) %>), address(this)));\n                    subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] |= (uint(1) << _instanceIndex);\n                    subInstanceAddresses[_instanceIndex] = child_<%= flowNodeIndex(nodeId) %>;\n                    child_<%= flowNodeIndex(nodeId) %>.setInstanceIndex(_instanceIndex);\n                }\n                else {\n                    step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>));\n                }\n<%  } else { -%>\n                if (subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] == 0)\n                    step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>));\n<% }} else if(!is(node, 'bpmn:BoundaryEvent') && !node.triggeredByEvent) { -%>\n                step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>));\n<% } else { -%>\n                tmpStartedActivities &= uint(~<%= flowNodeIndex(nodeId) %>);\n                (marking, startedActivities) = (tmpMarking, tmpStartedActivities);\n                if(tmpMarking | tmpStartedActivities == 0)\n                    propagateEvent(\"<%= nodeName(nodeId) %>\", \"Default\", tmpMarking, tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<% } -%>\n            }\n<% if(eventsToCatch.length > 0) { -%>\n            else\n                sourceChild |= uint(<%= flowNodeIndex(nodeId) %>);\n<% } -%>\n        }\n<% }) -%>\n<% first = true;\n   eventsToCatch.forEach(evtId => {\n   var nodeEvt = nodeMap.get(evtId);\n   var evtType = eventType(evtId); -%>\n<% if (evtType === 'Error' || evtType === 'Escalation') {\n          var candidateSubprocMask = getProcessCandidatesMaskFrom(evtId, evtType, nodeName(evtId), contracts2Call, eventsToCatch); -%>\n<% if(first) { first = false; -%>        if <% } else { -%>        else if <% }-%>(eventType == \"<%= evtType %>\" && code == \"<%= nodeName(evtId) %>\" && sourceChild & uint(<%= candidateSubprocMask %>) != 0) {\n<%    if(isInterrupting(evtId)) {\n        if(nodeEvt.$parent.triggeredByEvent) {\n          var startingKill = nodeEvt.$parent.$parent.id === processId() ? 0 : flowNodeIndex(nodeEvt.$parent.$parent.id); -%>\n            (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= startingKill %>), tmpMarking, tmpStartedActivities);\n            step(tmpMarking | uint(<%= subprocessStartMarking(nodeEvt.$parent.id) %>), tmpStartedActivities | uint(<%= flowNodeIndex(nodeEvt.$parent.id) %>));\n<%            } else { -%>\n            (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(nodeEvt.attachedToRef.id) %>), tmpMarking, tmpStartedActivities);\n            step(tmpMarking | uint(<%= postMarking(evtId) %>), tmpStartedActivities);\n<%            } -%>\n<%          } else {  -%>\n            createNewSubprocessInstance(<%= nodeRealIndex(evtId) %>);\n<% if (nodeEvt.attachedToRef) {\n      let nodeId = nodeEvt.attachedToRef.id;\n      let node = nodeMap.get(nodeId);\n      if (node.loopCharacteristics && node.loopCharacteristics.$type === 'bpmn:MultiInstanceLoopCharacteristics') {\n        if (node.loopCharacteristics.isSequential) { -%>\n            if(++_instanceIndex < subInstanceAddresses.length && subInstanceAddresses[_instanceIndex] == 0) {\n                AbstractProcess child_<%= flowNodeIndex(nodeId) %> = AbstractProcess(AbstractRegistry(processRegistry).newInstanceFor(uint(<%= nodeRealIndex(nodeId) %>), address(this)));\n                subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] |= (uint(1) << _instanceIndex);\n                subInstanceAddresses[_instanceIndex] = child_<%= flowNodeIndex(nodeId) %>;\n                child_<%= flowNodeIndex(nodeId) %>.setInstanceIndex(_instanceIndex);\n                step(tmpMarking, tmpStartedActivities | uint(<%= flowNodeIndex(evtId) %>));\n            }\n            else {\n                step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>) | uint(<%= flowNodeIndex(evtId) %>));\n            }\n<%      } else { -%>\n            if (subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] == 0)\n                step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>) | uint(<%= flowNodeIndex(evtId) %>));\n<% }} else if(!is(node, 'bpmn:BoundaryEvent') && !node.triggeredByEvent) { -%>\n            step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>) | uint(<%= flowNodeIndex(evtId) %>));\n<% } -%>\n<% } else { -%>\n            step(tmpMarking, tmpStartedActivities | uint(<%= flowNodeIndex(evtId) %>));\n<%   }      } -%>\n            }\n<%  } -%>\n<% }); -%>\n        else {\n            (tmpMarking, tmpStartedActivities) = propagateEvent(code, eventType, tmpMarking, tmpStartedActivities, sourceChild);\n            step(tmpMarking, tmpStartedActivities);\n        }\n<% } else { -%>\n        // Process without calls to external contracts.\n        // No events to catch !!!\n<% } -%>\n    }\n\n<% /* --------------------------------- Kill Childrens & Broadcast ------------------------------ */ -%>\n    function killProcess() public {\n        (marking, startedActivities) = killProcess(0, marking, startedActivities);\n    }\n\n    function killProcess(uint processElementIndex, uint tmpMarking, uint tmpStartedActivities) internal returns(uint, uint) {\n<% if(contracts2Call.length == 0) {         /* Case No External contract call in the contract */ -%>\n        if(processElementIndex == 0)\n            tmpMarking = tmpStartedActivities = 0;\n<% if(subprocessToKill.length > 0) { -%>\n<%     subprocessToKill.forEach(subprocId => { -%>\n        else if(processElementIndex & uint(<%= flowNodeIndex(subprocId) %>) != 0) {\n            tmpMarking &= uint(~<%=subprocessFullMarking(subprocId)%>);\n            tmpStartedActivities &= uint(~<%= subprocessNodeFullMarking(subprocId) %>);\n        }\n<%      }) }\n} else {                                    /* Case External Contract Calls in Main contract */ -%>\n        uint externalContracts2Stop = 0;\n        uint allAddresses2Stop = 0;\n        if(processElementIndex == 0) {\n            tmpMarking = tmpStartedActivities = 0;\n<% var getContracts2CallMask = getContracts2CallMaskFrom(processId(), contracts2Call);\n   if(getContracts2CallMask > 0) { -%>\n            externalContracts2Stop = uint(<%= getContracts2CallMask %>);\n<% } -%>\n        }\n<% subprocessToKill.forEach(subprocId => { -%>\n        else if(processElementIndex & uint(<%= flowNodeIndex(subprocId) %>) != 0) {\n<% if(callActivities.indexOf(subprocId) >= 0) { -%>\n            externalContracts2Stop = uint(<%= flowNodeIndex(subprocId) %>);\n<% } else { -%>\n            tmpMarking &= uint(~<%= subprocessFullMarking(subprocId) %>);\n            tmpStartedActivities &= uint(~<%= subprocessNodeFullMarking(subprocId) %>);\n<%  var contracts2CallMask = getContracts2CallMaskFrom(subprocId, contracts2Call);\n    if (contracts2CallMask !== 0) { -%>\n            externalContracts2Stop = uint(<%= contracts2CallMask %>);\n<% } -%>\n<% } -%>\n        }\n<%  }) -%>\n<% contracts2Call.forEach(subprocId => { -%>\n        if(externalContracts2Stop & uint(<%= flowNodeIndex(subprocId) %>) != 0) {\n            allAddresses2Stop |= subInstanceStartedIndexes[<%= nodeRealIndex(subprocId) %>];\n            subInstanceStartedIndexes[<%= nodeRealIndex(subprocId) %>] = 0;\n        }\n<% }) -%>\n        for(uint j = 0; j < subInstanceAddresses.length; j++)\n            if(allAddresses2Stop & (uint(1) << j) != 0)\n                AbstractProcess(subInstanceAddresses[j]).killProcess();\n<% } -%>\n        return (tmpMarking, tmpStartedActivities);\n    }\n\n    function broadcastSignal() public {\n        (uint256 tmpMarking, uint256 tmpStartedActivities) = broadcastSignal(marking, startedActivities, 0);\n        step(tmpMarking, tmpStartedActivities);\n    }\n\n    function broadcastSignal(uint tmpMarking, uint tmpStartedActivities, uint sourceChild) internal returns(uint, uint) {\n<% eventsToCatch.forEach(nodeId => {\n     if(eventType(nodeId) === 'Signal') {\n       var node = nodeMap.get(nodeId);\n        if(is(node, 'bpmn:IntermediateCatchEvent')) {\n          if (isPartOfDeferredChoice(nodeId)) { -%>\n        if(tmpMarking & uint(<%= deferredChoiceMarking(nodeId) %>) == uint(<%= deferredChoiceMarking(nodeId) %>))\n            tmpMarking = tmpMarking & uint(~<%= deferredChoiceMarking(nodeId) %>) | uint(<%= postMarking(nodeId) %>);\n<%            var deferredNodeMarking = deferredChoiceNodeMarking(nodeId);\n              if(deferredNodeMarking != 0) { -%>\n            tmpStartedActivities &= uint(~<%= deferredNodeMarking %>);\n<%    } -%>\n<%        } else {      -%>\n        if(tmpMarking & uint(<%= preMarking(nodeId) %>) == uint(<%= preMarking(nodeId) %>))\n            tmpMarking = tmpMarking & uint(~<%= preMarking(nodeId) %>) | uint(<%= postMarking(nodeId) %>);\n<%  }} else if(is(node, 'bpmn:StartEvent')) {\n           var parent = nodeMap.get(node.$parent.id);\n           if (parent.triggeredByEvent) {\n              if (isInterrupting(nodeId)) { -%>\n        if(tmpMarking & uint(~<%= subprocessFullMarking(parent.id) %>) != 0 || tmpStartedActivities & uint(~<%= subprocessNodeFullMarking(parent.id) %>) != 0) {\n            (tmpMarking, tmpStartedActivities) = killProcess(0, tmpMarking, tmpStartedActivities);\n            tmpStartedActivities |= uint(<%= flowNodeIndex(parent.id) %>);\n            tmpMarking |= uint(<%= subprocessStartMarking(parent.id) %>);\n        }\n<%            } else { -%>\n        if(tmpMarking & uint(<%= subprocessFullMarking(processId()) %>) != 0 || tmpStartedActivities & uint(~<%= flowNodeIndex(parent.id) %>) != 0) {\n            createNewSubprocessInstance(<%= nodeRealIndex(nodeId) %>);\n            tmpStartedActivities |= <%= flowNodeIndex(nodeId) %>;\n        }\n<%            } -%>\n<%         } else { -%>\n               /* Starting subprocess (not event subprocess) */\n<%         } -%>\n<%      } else if (is(node, 'bpmn:BoundaryEvent')) { -%>\n        if(tmpStartedActivities & uint(<%= flowNodeIndex(node.attachedToRef.id) %>) != 0) {\n<%          if(isInterrupting(nodeId)) { -%>\n            (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(node.attachedToRef.id) %>), tmpMarking, tmpStartedActivities);\n            tmpMarking |= uint(<%= postMarking(nodeId) %>);\n<%          } else { -%>\n            createNewSubprocessInstance(<%= nodeRealIndex(nodeId) %>);\n            tmpStartedActivities |= uint(<%= flowNodeIndex(nodeId) %>);\n<%          } -%>\n        }\n<% } -%>\n<% }}) -%>\n<% if (contracts2Call.length > 0) { -%>\n        uint contracts2Broadcast = 0;\n<%  contracts2Call.forEach(nodeId => { -%>\n        if (tmpStartedActivities & uint(<%= flowNodeIndex(nodeId) %>) != 0)\n            contracts2Broadcast |= subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>];\n<%  }) -%>\n        contracts2Broadcast &= uint(~sourceChild);\n        if(contracts2Broadcast != 0)\n            for(uint j = 0; j < subInstanceAddresses.length; j++)\n                if(contracts2Broadcast & (uint(1) << j) != 0)\n                    AbstractProcess(subInstanceAddresses[j]).broadcastSignal();\n<%  }   -%>\n        return (tmpMarking, tmpStartedActivities);\n    }\n\n<% /* --------------------------------- Functions from BPMN elements -------------------------- */ -%>\n<%  nodeList.forEach( nodeId => {\n        let node = nodeMap.get(nodeId),\n            nodePreMarking = preMarking(nodeId),\n            nodePostMarking = postMarking(nodeId);\n    if (is(node, 'bpmn:ServiceTask')) { -%>\n    // <%= nodeName(node.id) %>\n    function <%= nodeName(node.id) %>_callbak (uint reqId<%= concatParameters(name2Ids.get(nodeName[0]), false, true, true) %>) external returns(bool) {\n        require(msg.sender == oracleAddresses[<%= flowNodeIndex(node.id) %>]);\n        uint index = uint(1) << reqId;\n        if(requestedID[<%= nodeRealIndex(node.id) %>] & index == index) {\n            <%= nodeFunctionBody(nodeId) %>\n            requestedID[<%= nodeRealIndex(node.id) %>] &= ~uint(index);\n            step(marking | uint(<%= nodePostMarking %>), startedActivities);\n            return true;\n        }\n        return false ;\n    }\n<% }}); -%>\n\n<%  boundaryMessages = getMessages();\n    groupedIds = getWorkItemsGroupByParameters(false);\n    groupedIds.forEach(idGroup => { -%>\n    function <%= nodeName(idGroup[0]) %>_complete(uint elementIndex<%= concatParameters(idGroup[0], false, true, true) %>) external {\n        (uint256 tmpMarking, uint256 tmpStartedActivities) = (marking, startedActivities);\n<%    idGroup.forEach(nodeId => {\n        var node = nodeMap.get(nodeId); -%>\n        if(elementIndex == uint(<%= nodeRealIndex(nodeId) %>)) {\n            require(msg.sender == worklist && tmpStartedActivities & uint(<%= flowNodeIndex(nodeId) %>) != 0);\n<% if(boundaryMessages.indexOf(nodeId) < 0) {\n     var functionBody = nodeFunctionBody(nodeId);\n     if(functionBody.length > 0) { -%>\n           <%- functionBody %>\n<%   } -%>\n<% if (isPartOfDeferredChoice(nodeId)) {\n          var deferredNodeMarking = deferredChoiceNodeMarking(nodeId);\n          if(deferredNodeMarking != 0) { -%>\n            step(tmpMarking & uint(~<%= deferredChoiceMarking(nodeId) %>) | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= deferredNodeMarking %>));\n<%        } else { -%>\n            step(tmpMarking & uint(~<%= deferredChoiceMarking(nodeId) %>) | uint(<%= postMarking(nodeId) %>), tmpStartedActivities);\n<%        } -%>\n<% } else { -%>\n            step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>));\n<% }} else {\n  var parent = nodeMap.get(node.$parent.id);\n  if(parent.triggeredByEvent) { -%>\n<% if (isInterrupting(nodeId)) { -%>\n            killProcess();\n            step(uint(<%= subprocessStartMarking(parent.id) %>), uint(<%= flowNodeIndex(parent.id) %>));\n<% } else { -%>\n            createNewSubprocessInstance(<%= nodeRealIndex(nodeId) %>);\n            step(tmpMarking, tmpStartedActivities | <%= flowNodeIndex(parent.id) %>);\n<%   } -%>\n<% } else {\n    var attachedTo = node.attachedToRef.id;\n    if (isInterrupting(nodeId)) { -%>\n            (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(attachedTo) %>), tmpMarking, tmpStartedActivities);\n            step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities);\n<%  } else { -%>\n            createNewSubprocessInstance(<%= nodeRealIndex(nodeId) %>);\n            step(tmpMarking, tmpStartedActivities | <%= flowNodeIndex(nodeId) %>);\n<%     }}} -%>\n            return;\n        }\n<% }) -%>\n    }\n<%   }) -%>\n\n<% if(contracts2Call.length > 0) { -%>\n    function createNewSubprocessInstance(uint nodeIndex) private {\n        AbstractProcess child = AbstractProcess(AbstractRegistry(processRegistry).newInstanceFor(nodeIndex, address(this)));\n        uint index = subInstanceAddresses.length;\n        subInstanceAddresses.push(address(child));\n        subInstanceStartedIndexes[nodeIndex] |= (uint(1) << index);\n        child.setInstanceIndex(index);\n    }\n<% } -%>\n\n<% /* ----------------- Step: Method to execute internal activities automatically ------------------ */ -%>\n    function step(uint tmpMarking, uint tmpStartedActivities) internal {\n        while (true) {\n<% nodeList.forEach(nodeId => {\n    var node = nodeMap.get(nodeId);\n    var nodePostMarking = postMarking(nodeId);\n    if(catchingMessages.indexOf(nodeId) < 0) {\n        var nodePreMarking = preMarking(nodeId);\n     if (node.loopCharacteristics && node.loopCharacteristics.$type === 'bpmn:MultiInstanceLoopCharacteristics') { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n<%        if(!is (node, \"bpmn:Task\")) { -%>\n                for(uint i = 0; i < <%= node.loopCharacteristics.loopCardinality ? node.loopCharacteristics.loopCardinality.body : 1 %>; i++) {\n<% if (node.loopCharacteristics.isSequential) { -%>\n                    subInstanceAddresses.push(0);\n<% } else { -%>\n                    createNewSubprocessInstance(<%= nodeRealIndex(nodeId) %>);\n<% } -%>\n                }\n<% if (node.loopCharacteristics.isSequential) { -%>\n                AbstractProcess child_<%= flowNodeIndex(nodeId) %> = AbstractProcess(AbstractRegistry(processRegistry).newInstanceFor(uint(<%= nodeRealIndex(nodeId) %>), address(this)));\n                uint index = subInstanceAddresses.length - <%= node.loopCharacteristics.loopCardinality ? node.loopCharacteristics.loopCardinality.body : 1 %>;\n                subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] |= (uint(1) << index);\n                subInstanceAddresses[index] = child_<%= flowNodeIndex(nodeId) %>;\n                child_<%= flowNodeIndex(nodeId) %>.setInstanceIndex(index);\n<% } -%>\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                tmpStartedActivities |= <%= flowNodeIndex(nodeId) %>;\n<%      } -%>\n                continue;\n            }\n<% } else if (is(node, 'bpmn:ExclusiveGateway')) { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n<%          if (node.outgoing && node.outgoing.length > 1) {\n            var i = 0; node.outgoing.forEach( outgoing => { -%>\n<%= i > 0 ? 'else ' : '' %><%if (i < node.outgoing.length - 1){ %>if (<%- getCondition(outgoing) %>)<% } -%>\n                tmpMarking |= uint(<%= flowEdgeIndex(outgoing.id) %>);\n<% i++;}) -%>\n<%          } else { -%>\n                tmpMarking |= uint(<%= postMarking(nodeId) %>);\n<%          } -%>\n                continue;\n            }\n<% } else if(is(node, 'bpmn:ParallelGateway') || is(node,'bpmn:EventBasedGateway')) { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) == uint(<%= nodePreMarking %>)) {\n                tmpMarking = tmpMarking & uint(~<%= nodePreMarking %>) | uint(<%= nodePostMarking %>);\n                continue;\n            }\n<% } else if(is(node, 'bpmn:SubProcess') && !node.triggeredByEvent && multiinstanceActivities.indexOf(nodeId) < 0) { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeId) %>);\n                tmpMarking = tmpMarking & uint(~<%= nodePreMarking %>) | uint(<%= subprocessStartMarking(nodeId) %>);\n                continue;\n            }\n<% } else if(is(node, 'bpmn:ReceiveTask')) {\n    if (isPartOfDeferredChoice(nodeId)) { -%>\n            if (tmpStartedActivities & uint(<%= flowNodeIndex(nodeId) %>) == 0 && tmpMarking & uint(<%= deferredChoiceMarking(nodeId) %>) == uint(<%= deferredChoiceMarking(nodeId) %>)) {\n                <%= nodeName(processId()) %>_AbstractWorklist(worklist).<%= nodeName(nodeId) %>_start(<%= nodeRealIndex(nodeId) %><%= concatParameters(nodeId, true, false, true) %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeId) %>);\n                continue;\n            }\n<%  } else { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n                <%= nodeName(processId()) %>_AbstractWorklist(worklist).<%= nodeName(nodeId) %>_start(<%= nodeRealIndex(nodeId) %><%= concatParameters(nodeId, true, false, true) %>);\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(node.id) %>);\n                continue;\n            }\n<% }} else if((is(node, 'bpmn:Task'))) { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n<%    if (is(node, 'bpmn:UserTask'))  { -%>\n                <%= nodeName(processId()) %>_AbstractWorklist(worklist).<%= nodeName(nodeId) %>_start(<%= nodeRealIndex(nodeId) %><%= concatParameters(nodeId, true, false, true) %>);\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(node.id) %>);\n<%  } else if(is(node, 'bpmn:ServiceTask')) {\n          var functName = oracleTaskMap.get(nodeId);\n          var localInfo = oracleInfo.get(functName); -%>\n                uint reqId = Oracle_Wrapper(oracleAddresses[<%= flowNodeIndex(nodeId) %>]).<%= localInfo.functionName %>(<%= concatParameters(node.id, true, false, false) %>, this.<%= nodeName(nodeId) %>_callbak);\n                requestedID[<%= nodeRealIndex(node.id) %>] |= uint(1) << reqId;\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(node.id) %>);\n<%  } else if (is(node, 'bpmn:ScriptTask')) {\n         if (node.script) { -%>\n                <%- nodeFunctionBody(nodeId) -%>\n<%       } -%>\n                tmpMarking = tmpMarking & uint(~<%= nodePreMarking %>) | uint(<%= nodePostMarking %>);\n<%  } else { -%>\n                tmpMarking = tmpMarking & uint(~<%= nodePreMarking %>) | uint(<%= nodePostMarking %>);\n<%  } -%>\n                continue;\n            }\n<% } else if(is(node, 'bpmn:EndEvent')) {\n          var evtType = eventType(nodeId); -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n<% if(evtType === 'Default' || evtType === 'Message') { -%>\n<% if(evtType === 'Message') { -%>\n                <%= nodeId %>_Mesage('<%= nodeName(nodeId) %>');\n<% } -%>\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                if (tmpMarking & uint(<%= subprocessFullMarking(node.$parent.id) %>) == 0 && tmpStartedActivities & uint(<%= subprocessNodeMarking(node.$parent.id) %>) == 0) {\n<% if(node.$parent.id === processId() || nodeMap.get(node.$parent.id).triggeredByEvent || (is(nodeMap.get(processId()), 'bpmn:BoundaryEvent') && node.$parent.id === nodeMap.get(processId()).$parent.id)) { -%>\n<% if(nodeMap.get(node.$parent.id).triggeredByEvent) { -%>\n                    tmpStartedActivities &= uint(~<%= flowNodeIndex(node.$parent.id) %>);\n<% } -%>\n                    (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"Default\", tmpMarking, tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<% } else { -%>\n                    tmpStartedActivities &= uint(~<%= flowNodeIndex(node.$parent.id) %>);\n                    tmpMarking |= uint(<%= postMarking(node.$parent.id) %>);\n<% } -%>\n                }\n<% } else if (evtType === 'Terminate') { -%>\n<% if(is(nodeMap.get(processId()), 'bpmn:BoundaryEvent') && node.$parent.id === nodeMap.get(processId()).$parent.id) { -%>\n                (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"Terminate\", tmpMarking, tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<% } else if(node.$parent.id === processId()) { -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(0, tmpMarking, tmpStartedActivities);\n                (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"Default\", tmpMarking, tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<% } else { -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(node.$parent.id) %>), tmpMarking, tmpStartedActivities);\n                tmpMarking |= uint(<%= postMarking(node.$parent.id) %>);\n                tmpStartedActivities &= uint(~<%= flowNodeIndex(node.$parent.id) %>);\n<% } -%>\n<% } else if (evtType === 'Signal') { -%>\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"Signal\", tmpMarking, tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<% } else if (evtType === 'Error' || evtType === 'Escalation') {\n        var localEvents2Catch = getCatchingEventsFrom(node.$parent.id, evtType, nodeName(nodeId));\n        if(localEvents2Catch.length == 0) { -%>\n                (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"<%= evtType %>\", tmpMarking & uint(~<%= nodePreMarking %>), tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<%      } else {\n        localEvents2Catch.forEach(evtId => {\n            var nodeEvt = nodeMap.get(evtId);\n            if(isInterrupting(evtId)) {\n              if(nodeEvt.$parent.triggeredByEvent) {\n                 var startingKill = nodeEvt.$parent.$parent.id === processId() ? 0 : flowNodeIndex(nodeEvt.$parent.$parent.id); -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= startingKill %>), tmpMarking & uint(~<%= nodePreMarking %>), tmpStartedActivities);\n                tmpMarking |= uint(<%= subprocessStartMarking(nodeEvt.$parent.id) %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeEvt.$parent.id) %>);\n<%            } else { -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(nodeEvt.attachedToRef.id) %>), tmpMarking & uint(~<%= nodePreMarking %>), tmpStartedActivities);\n                tmpMarking |= uint(<%= postMarking(evtId) %>);\n<%            } -%>\n<%          } else {  -%>\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                createNewSubprocessInstance(<%= nodeRealIndex(evtId) %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(evtId) %>);\n<%          } }) -%>\n<%   } } -%>\n                continue;\n            }\n<% } else if(is(node, 'bpmn:IntermediateThrowEvent')) {\n       var evtType = eventType(nodeId); -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n<% if(evtType === 'Default') { -%>\n                tmpMarking = tmpMarking & uint(~<%= nodePreMarking %>) | uint(<%= nodePostMarking %>);\n<% } else {\n    if (isPartOfDeferredChoice(nodeId)) { -%>\n                tmpMarking = tmpMarking & uint(~<%= deferredChoiceMarking(nodeId) %>) | uint(<%= nodePostMarking %>);\n<%    var deferredNodeMarking = deferredChoiceNodeMarking(nodeId);\n      if(deferredNodeMarking != 0) { -%>\n              tmpStartedActivities &= uint(~<%= deferredNodeMarking %>);\n<%    } -%>\n<%  } else { -%>\n                tmpMarking = tmpMarking & uint(~<%= nodePreMarking %>) | uint(<%= nodePostMarking %>);\n<%  }  if (evtType === 'Signal') { -%>\n                (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"Signal\", tmpMarking, tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<%  } else if(evtType === 'Message') { -%>\n                <%= nodeId %>_Mesage('<%= nodeName(nodeId) %>');\n<%  } else if(evtType === 'Escalation') {\n          var localEvents2Catch = getCatchingEventsFrom(node.$parent.id, evtType, nodeName(nodeId));\n          if(localEvents2Catch.length == 0) { -%>\n                (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"<%= evtType %>\", tmpMarking & uint(~<%= nodePreMarking %>), tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n  <%      } else {\n          localEvents2Catch.forEach(evtId => {\n              var nodeEvt = nodeMap.get(evtId);\n              if(isInterrupting(evtId)) {\n                if(nodeEvt.$parent.triggeredByEvent) {\n                   var startingKill = nodeEvt.$parent.$parent.id === processId() ? 0 : flowNodeIndex(nodeEvt.$parent.$parent.id); -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= startingKill %>), tmpMarking & uint(~<%= nodePreMarking %>), tmpStartedActivities);\n                tmpMarking |= uint(<%= subprocessStartMarking(nodeEvt.$parent.id) %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeEvt.$parent.id) %>);\n  <%            } else { -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(nodeEvt.attachedToRef.id) %>), tmpMarking & uint(~<%= nodePreMarking %>), tmpStartedActivities);\n                tmpMarking |= uint(<%= postMarking(evtId) %>);\n  <%            } -%>\n  <%          } else {  -%>\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                createNewSubprocessInstance(<%= nodeRealIndex(evtId) %>);\n  <% if(nodeEvt.$parent.triggeredByEvent) { -%>\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeEvt.$parent.id) %>);\n  <% } else { -%>\n                tmpStartedActivities |= uint(<%= flowNodeIndex(evtId) %>);\n  <% }         } }) -%>\n  <%   } -%>\n<% }} -%>\n                continue;\n            }\n<% } else if (callActivities.indexOf(nodeId) >= 0) { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n                createNewSubprocessInstance(<%= nodeRealIndex(nodeId) %>);\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeId) %>);\n                continue;\n            }\n<% }} else {\n  if(isBoundaryEvent(nodeId)) {\n    var attachedTo = node.attachedToRef.id; -%>\n            if (tmpStartedActivities & uint(<%= flowNodeIndex(attachedTo) %>) != 0 && tmpStartedActivities & uint(<%= flowNodeIndex(nodeId) %>) == 0) {\n                <%= nodeName(processId()) %>_AbstractWorklist(worklist).<%= nodeName(nodeId) %>_start(<%= nodeRealIndex(nodeId) %><%= concatParameters(nodeId, true, false, true) %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeId) %>);\n                continue;\n            }\n            if (tmpStartedActivities & uint(<%= flowNodeIndex(attachedTo) %>) == 0 && tmpStartedActivities & uint(<%= flowNodeIndex(nodeId) %>) != 0) {\n                tmpStartedActivities &= uint(~<%= flowNodeIndex(nodeId) %>);\n                continue;\n            }\n  <% } -%>\n<% }}); -%>\n            break;\n        }\n        if(marking != 0 || startedActivities != 0) {\n            marking = tmpMarking;\n            startedActivities = tmpStartedActivities;\n        }\n    }\n\n    function getWorklistAddress() external view returns(address) {\n        return worklist;\n    }\n\n    function getInstanceIndex() external view returns(uint) {\n        return instanceIndex;\n    }\n\n<% /* ------------- Methods to obtain information about multiple contract instances running ------------------ */ -%>\n<% if (callActivities.length > 0 || multiinstanceActivities.length > 0 || nonInterruptingEvents.length > 0) { -%>\n    function allInstanceAddresses() external view returns(address [] memory) {\n        return subInstanceAddresses;\n    }\n\n    function startedInstanceIndexFor(uint instanceNode) external view returns(uint) {\n        return subInstanceStartedIndexes[instanceNode];\n    }\n\n<% } -%>\n}\n";

/* babel-plugin-inline-import '../../../templates/worklist2sol.ejs' */
const worklist2solEJS = "pragma solidity ^0.5.0;\n\nimport \"AbstractWorklist\";\n\ncontract <%= nodeName(processId()) %>_AbstractWorklist {\n\n  <%  groupedIds = getWorkItemsGroupByParameters(true);\n      groupedIds.forEach(idGroup => {\n          var nodeId = idGroup[0]; -%>\n    function <%= nodeName(nodeId) %>_start(uint<%= getParameterType(nodeId, true, true, true) %>) external;\n  <% }) -%>\n\n  <%  groupedIds = getWorkItemsGroupByParameters(false);\n      groupedIds.forEach(idGroup => {\n          var nodeId = idGroup[0]; -%>\n    function <%= nodeName(nodeId) %>_complete(uint<%= getParameterType(nodeId, false, true, true) %>) external;\n  <% }) -%>\n\n}\n\ncontract <%= nodeName(processId()) %>_worklist is AbstractWorklist {\n\n    // Events with the information to include in the Log when a workitem is registered\n<%  groupedIds = getWorkItemsGroupByParameters(true);\n    groupedIds.forEach(idGroup => { -%>\n    event <%= nodeName(idGroup[0]) %>_Requested(uint<%= getParameterType(idGroup[0], true, true, true) %>);\n<% }) -%>\n\n<%  groupedIds = getWorkItemsGroupByParameters(true);\n    groupedIds.forEach(idGroup => {\n        var nodeId = idGroup[0]; -%>\n    function <%= nodeName(nodeId) %>_start(uint elementIndex<%= getParameters(nodeId, true, true, true) %>) external {\n        workitems.push(Workitem(elementIndex, msg.sender));\n        emit <%= nodeName(nodeId) %>_Requested(workitems.length - 1<%= getParameters(nodeId, true, false, true) %>);\n    }\n<% }) -%>\n\n<%  groupedIds = getWorkItemsGroupByParameters(false);\n    groupedIds.forEach(idGroup => {\n        var nodeId = idGroup[0]; -%>\n    function <%= nodeName(nodeId) %>(uint workitemId<%= getParameters(nodeId, false, true, true) %>) external {\n\n        require(workitemId < workitems.length && workitems[workitemId].processInstanceAddr != address(0) && \n        canPerform(msg.sender, workitems[workitemId].processInstanceAddr, workitems[workitemId].elementIndex));\n        \n        <%= nodeName(processId()) %>_AbstractWorklist(workitems[workitemId].processInstanceAddr).<%= nodeName(nodeId) %>_complete(workitems[workitemId].elementIndex<%= getParameters(nodeId, false, false, true) %>);\n        workitems[workitemId].processInstanceAddr = address(0);\n    }\n<% }) -%>\n\n}\n";
const debug = (0, _debug2.default)('caterpillarql:parse-model');
const bpmn2solTemplate = ejs.compile(bpmn2solEJS);
const worklist2solTemplate = ejs.compile(worklist2solEJS);
let moddle = new _bpmnModdle.default();

let parseBpmn = bpmnDoc => {
  return new Promise((resolve, reject) => {
    moddle.fromXML(bpmnDoc, (err, definitions) => {
      if (!err) resolve(definitions);else reject(err);
    });
  });
};

let is = (element, type) => element.$instanceOf(type);

let collectControlFlowInfo;

collectControlFlowInfo = (proc, globalNodeMap, globalControlFlowInfo) => {
  let nodeList = [];
  let edgeList = [];
  let boundaryEvents = [];
  let nonBlockingBoundaryEvents = [];
  let controlFlowInfo;

  for (let node of proc.flowElements.filter(e => is(e, "bpmn:FlowNode"))) {
    if (is(node, "bpmn:BoundaryEvent")) {
      boundaryEvents.push(node.id);
      if (node.cancelActivity == false) nonBlockingBoundaryEvents.push(node.id);
    } else {
      nodeList.push(node.id);
    }

    globalNodeMap.set(node.id, node);
  }

  let sources = [...nodeList];

  for (let flowEdge of proc.flowElements.filter(e => is(e, "bpmn:SequenceFlow"))) {
    if (sources.indexOf(flowEdge.targetRef.id) > -1) {
      sources.splice(sources.indexOf(flowEdge.targetRef.id), 1);
    }

    edgeList.push(flowEdge.id);
  } // Let us remove all source elements from the node list


  nodeList = nodeList.filter(node => sources.indexOf(node) < 0);

  if (nonBlockingBoundaryEvents.length > 0) {
    let dfs = sources => {
      let open = [...sources];
      let nodeList = [];
      let edgeList = [];

      while (open.length > 0) {
        let currId = open.pop();
        let curr = globalNodeMap.get(currId);
        nodeList.push(currId);
        if (curr.outgoing && curr.outgoing.length > 0) for (let succEdge of curr.outgoing) {
          let succ = succEdge.targetRef;
          edgeList.push(succEdge.id);
          if (open.indexOf(succ.id) < 0 && nodeList.indexOf(succ.id) < 0) open.push(succ.id);
        }
      }

      return [nodeList, edgeList];
    };

    let [mainPathNodeList, mainPathEdgeList] = dfs(sources);
    let localBoundary = [];
    boundaryEvents.forEach(evtId => {
      if (nonBlockingBoundaryEvents.indexOf(evtId) < 0) localBoundary.push(evtId);
    });

    if (localBoundary.length > 0) {
      let [boundaryNodePath, boundaryEdgePath] = dfs(localBoundary);
      boundaryNodePath = boundaryNodePath.filter(node => localBoundary.indexOf(node) < 0);
      mainPathNodeList = mainPathNodeList.concat(boundaryNodePath);
      mainPathEdgeList = mainPathEdgeList.concat(boundaryEdgePath);
    } // Let us remove all source elements from the node list


    mainPathNodeList = mainPathNodeList.filter(node => sources.indexOf(node) < 0);
    controlFlowInfo = new _definitions.ControlFlowInfo(proc, mainPathNodeList, mainPathEdgeList, sources, boundaryEvents);
    globalControlFlowInfo.push(controlFlowInfo);

    for (let eventId of nonBlockingBoundaryEvents) {
      let event = globalNodeMap.get(eventId);

      if (!mainPathNodeList.find(e => event.attachedToRef.id === e)) {
        throw new Error("ERROR: Found non-interrupting event which is not attached to a subprocess in the main process path");
      }

      let [localNodeList, localEdgeList] = dfs([eventId]);
      if (mainPathNodeList.filter(nodeId => localNodeList.indexOf(nodeId) >= 0).length > 0) throw new Error("ERROR: Non-interrupting event outgoing path is not synchronized and merges with main process path"); // Let us remove all source elements from the node list

      localNodeList = localNodeList.filter(node => sources.indexOf(node) < 0);
      let childControlFlowInfo = new _definitions.ControlFlowInfo(event, localNodeList, localEdgeList, [eventId], []);
      childControlFlowInfo.parent = proc;
      globalControlFlowInfo.push(childControlFlowInfo);
    }
  } else {
    controlFlowInfo = new _definitions.ControlFlowInfo(proc, nodeList, edgeList, sources, boundaryEvents);
    globalControlFlowInfo.push(controlFlowInfo);
  }

  for (let subprocess of proc.flowElements.filter(e => is(e, "bpmn:SubProcess"))) {
    let subprocessControlFlowInfo = collectControlFlowInfo(subprocess, globalNodeMap, globalControlFlowInfo);
    subprocessControlFlowInfo.parent = proc;

    if (!(subprocess.loopCharacteristics && subprocess.loopCharacteristics.$type === "bpmn:MultiInstanceLoopCharacteristics")) {
      // Subprocess is embedded ... then copy all nodes and edges to the parent process
      subprocessControlFlowInfo.isEmbedded = true;
      controlFlowInfo.nodeList = controlFlowInfo.nodeList.concat(subprocessControlFlowInfo.nodeList);
      controlFlowInfo.edgeList = controlFlowInfo.edgeList.concat(subprocessControlFlowInfo.edgeList);
      controlFlowInfo.boundaryEvents = controlFlowInfo.boundaryEvents.concat(subprocessControlFlowInfo.boundaryEvents);
    }
  }

  if (proc.documentation) {
    controlFlowInfo.globalParameters = proc.documentation[0].text;
  }

  return controlFlowInfo;
};

let restrictRelation = new Map();

let extractParameters = (cad, nodeId, controlFlowInfo) => {
  // Extracting Roles from UserTasks functionBody
  let arr = cad.split('@');

  if (arr.length >= 3) {
    if (controlFlowInfo != null) controlFlowInfo.taskRoleMap.set(nodeId, arr[1].trim());
    if (arr[2].length > 1) cad = arr[2];else return undefined;
  } // Extracting Information of Oracle from Service Tasks (if aplicable)


  let oracle_Data = "";

  for (let j = 0, first = false; j < cad.length; j++) {
    if (cad.charAt(j) === "(") {
      if (!first) first = true;else {
        cad = cad.substr(j);
        break;
      }
    }

    if (cad.charAt(j) === ":") {
      oracle_Data = "";
      break;
    }

    oracle_Data += cad.charAt(j);
  } // Processing Information of function parameters (both service and user tasks)


  cad = cad.replace("(", " ").replace(")", " ").trim();
  cad = cad.replace("(", " ").replace(")", " ").trim();
  let firstSplit = cad.split(":");

  if (firstSplit.length > 2) {
    let aux = '';

    for (let i = 1; i < firstSplit.length; i++) aux += firstSplit[i];

    firstSplit = [firstSplit[0], aux];
  }

  let secondSplit = firstSplit[firstSplit.length - 1].trim().split("->");
  let resMap = new Map();
  let inputOutput = [firstSplit[0].trim(), secondSplit[0].trim()];
  let parameterType = ["input", "output"];
  resMap.set("body", [secondSplit[secondSplit.length - 1].trim()]);

  for (let i = 0; i < inputOutput.length; i++) {
    let temp = inputOutput[i].split(",");
    let res = [];
    temp.forEach(subCad => {
      let aux = subCad.trim().split(" ");

      if (aux[0].trim().length > 0) {
        res.push(aux[0].trim());
        res.push(aux[aux.length - 1].trim());
      }
    });
    resMap.set(parameterType[i], res);
  } // Updating Information of Oracle in controlFlowInfo


  if (controlFlowInfo != null) {
    let inParameters = [];
    let outParameters = [];
    let toIterate = resMap.get('input');

    for (let i = 0; i < toIterate.length; i += 2) inParameters.push(new _definitions.ParameterInfo(toIterate[i], toIterate[i + 1]));

    toIterate = resMap.get('output');
    let parameters = new Map();
    parameters.set('input', inParameters);
    parameters.set('output', outParameters);

    for (let i = 0; i < toIterate.length; i += 2) outParameters.push(new _definitions.ParameterInfo(toIterate[i], toIterate[i + 1]));

    if (oracle_Data.length > 0) {
      oracle_Data = oracle_Data.trim().replace(" ", "_");
      oracle_Data = oracle_Data.replace("(", " ").replace(").", " ").trim();
      let splitResult = oracle_Data.split(" ");

      if (!controlFlowInfo.oracleInfo.has(splitResult[0])) {
        controlFlowInfo.oracleInfo.set(splitResult[0], new _definitions.OracleInfo(splitResult[0]));
      }

      controlFlowInfo.oracleTaskMap.set(nodeId, splitResult[0]);
      let localOracle = controlFlowInfo.oracleInfo.get(splitResult[0]);
      localOracle.address = splitResult[1];
      localOracle.functionName = splitResult[2];
      localOracle.functionParameters = parameters.get('input');
    } else controlFlowInfo.localParameters.set(nodeId, parameters);
  }

  return resMap;
};

let getNodeName = node => node.name ? node.name.replace(/\s+/g, "_") : node.id;

let parseModel = modelInfo => {
  return new Promise((resolve, reject) => {
    parseBpmn(modelInfo.bpmn).then(definitions => {
      debug('parsed model', definitions);
      modelInfo.solidity = "pragma solidity ^0.5.0;\n";
      modelInfo.controlFlowInfoMap = new Map(); // Sanity checks

      if (!definitions.diagrams || definitions.diagrams.length == 0) throw new Error("ERROR: No diagram found in BPMN file");
      let proc = definitions.diagrams[0].plane.bpmnElement;
      modelInfo.name = proc.name ? proc.name.replace(/\s+/g, "_") : proc.id;
      modelInfo.id = proc.id;

      if (proc.$type !== "bpmn:Process") {
        if (proc.$type === "bpmn:Collaboration") {
          for (let i = 0; i < definitions.rootElements.length; i++) if (definitions.rootElements[i].$type === "bpmn:Process") {
            proc = definitions.rootElements[i];
            modelInfo.name = proc.name ? proc.name.replace(/\s+/g, "_") : proc.id;
            modelInfo.id = proc.id;
            break;
          }
        } else {
          throw new Error("ERROR: No root process model found");
        }
      } // BPMN to Solidity parsing


      let globalNodeMap = new Map(),
          globalNodeIndexMap = new Map(),
          globalEdgeIndexMap = new Map(),
          globalControlFlowInfo = []; ////////////////////////////////////////////////////////////

      globalNodeMap.set(proc.id, proc);
      let mainControlFlowInfo = collectControlFlowInfo(proc, globalNodeMap, globalControlFlowInfo);
      let globalControlFlowInfoMap = new Map();
      globalControlFlowInfo.forEach(controlFlowInfo => globalControlFlowInfoMap.set(controlFlowInfo.self.id, controlFlowInfo)); // Event sub-processes appear in the source list, and not in the nodeList
      // In addition, all the elements of a non interrupting subprocess event appears embedded on its parent process

      for (let controlFlowInfo of globalControlFlowInfo) {
        let indexesToRemove = [];
        controlFlowInfo.sources.forEach(nodeId => {
          if (globalNodeMap.get(nodeId).triggeredByEvent) {
            controlFlowInfo.nodeList.push(nodeId);
            indexesToRemove.push(controlFlowInfo.sources.indexOf(nodeId));
            let nodeInfo = globalControlFlowInfoMap.get(nodeId);
            if (!globalNodeMap.get(nodeInfo.sources[0]).isInterrupting) nodeInfo.nodeList.forEach(childId => {
              let index = controlFlowInfo.nodeList.indexOf(childId);
              if (index >= 0) controlFlowInfo.nodeList.splice(index, 1);
            });
          }
        });
        indexesToRemove.sort((ind1, ind2) => {
          return ind2 - ind1;
        });
        indexesToRemove.forEach(index => {
          controlFlowInfo.sources.splice(index, 1);
        });

        if (is(globalNodeMap.get(controlFlowInfo.self.id), "bpmn:SubProcess") && controlFlowInfo.self.triggeredByEvent && globalNodeMap.get(controlFlowInfo.sources[0]).isInterrupting == false) {
          controlFlowInfo.isEmbedded = false;
        }
      }

      let hasExternalCall = nodeId => {
        let node = globalNodeMap.get(nodeId);
        return is(node, "bpmn:ServiceTask");
      };

      modelInfo.globalNodeMap = globalNodeMap;

      for (let controlFlowInfo of globalControlFlowInfo) {
        if (!controlFlowInfo.isEmbedded) {
          let multiinstanceActivities = [],
              callActivities = [],
              nonInterruptingEvents = [],
              catchingMessages = [];
          controlFlowInfo.nodeList.map(nodeId => globalNodeMap.get(nodeId)).forEach(e => {
            if ((is(e, "bpmn:Task") || is(e, "bpmn:SubProcess")) && e.loopCharacteristics && e.loopCharacteristics.$type === "bpmn:MultiInstanceLoopCharacteristics") {
              controlFlowInfo.multiinstanceActivities.set(e.id, getNodeName(e));
              multiinstanceActivities.push(e.id);
            } else if (is(e, "bpmn:CallActivity")) {
              controlFlowInfo.callActivities.set(e.id, getNodeName(e));
              callActivities.push(e.id);
            } else if (is(e, "bpmn:IntermediateCatchEvent") && is(e.eventDefinitions[0], "bpmn:MessageEventDefinition")) catchingMessages.push(e.id);else if (is(e, "bpmn:StartEvent") && is(e.eventDefinitions[0], "bpmn:MessageEventDefinition")) catchingMessages.push(e.id);
          }); // It is also necessary to add boundary events of embedded sub-processes

          controlFlowInfo.sources.forEach(nodeId => {
            let start = globalNodeMap.get(nodeId);

            if (start.eventDefinitions && start.eventDefinitions[0] && is(start.eventDefinitions[0], "bpmn:MessageEventDefinition") && controlFlowInfo.nodeList.indexOf(nodeId) < 0) {
              controlFlowInfo.nodeList.push(nodeId);
              if (catchingMessages.indexOf(nodeId) < 0) catchingMessages.push(nodeId);
            }
          });
          controlFlowInfo.boundaryEvents.forEach(nodeId => {
            let node = globalNodeMap.get(nodeId);
            if (node.outgoing) for (let outgoing of node.outgoing) controlFlowInfo.edgeList.push(outgoing.id);

            if (!node.cancelActivity) {
              controlFlowInfo.nonInterruptingEvents.set(node.id, getNodeName(node));
              nonInterruptingEvents.push(node.id);
              controlFlowInfo.nodeList.push(nodeId); // Eager reinsertion

              if (node.eventDefinitions[0] && is(node.eventDefinitions[0], 'bpmn:MessageEventDefinition')) {
                if (catchingMessages.indexOf(nodeId) < 0) catchingMessages.push(nodeId);
              }
            } else if (node.eventDefinitions && is(node.eventDefinitions[0], "bpmn:MessageEventDefinition")) {
              if (controlFlowInfo.nodeList.indexOf(nodeId) < 0) controlFlowInfo.nodeList.push(nodeId);
              if (catchingMessages.indexOf(nodeId) < 0) catchingMessages.push(nodeId);
            }
          });
          globalNodeMap.forEach(node => {
            if (is(node, "bpmn:SubProcess") && node.triggeredByEvent && controlFlowInfo.nodeList.indexOf(node.id)) {
              for (let start of node.flowElements.filter(e => is(e, "bpmn:FlowNode") && is(e, "bpmn:StartEvent"))) {
                if (start.isInterrupting == false) {
                  let parent = globalNodeMap.get(start.$parent.id);
                  controlFlowInfo.nonInterruptingEvents.set(start.id, getNodeName(parent));
                  nonInterruptingEvents.push(start.id);
                  controlFlowInfo.nodeList.push(start.id);

                  if (start.eventDefinitions[0] && is(start.eventDefinitions[0], "bpmn:MessageEventDefinition")) {
                    if (catchingMessages.indexOf(start.id) < 0) catchingMessages.push(start.id);
                  }
                }

                if (controlFlowInfo.boundaryEvents.indexOf(start.id) < 0) {
                  controlFlowInfo.boundaryEvents.push(start.id);
                  if (controlFlowInfo.nodeList.indexOf(start.$parent.id) < 0) controlFlowInfo.nodeList.push(start.$parent.id);
                }

                if (start.eventDefinitions[0] && is(start.eventDefinitions[0], "bpmn:MessageEventDefinition")) {
                  if (controlFlowInfo.nodeList.indexOf(start.id) < 0) controlFlowInfo.nodeList.push(start.id);
                  if (catchingMessages.indexOf(start.id) < 0) catchingMessages.push(start.id);
                }

                if (start.outgoing) for (let outgoing of start.outgoing) controlFlowInfo.edgeList.push(outgoing.id);
              }
            }
          });
          let part1 = [];
          let part2 = [];
          controlFlowInfo.nodeList.forEach(nodeId => {
            if (hasExternalCall(nodeId)) part1.push(nodeId);else part2.push(nodeId);
          });
          controlFlowInfo.nodeList = part1.concat(part2);
          controlFlowInfo.nodeList.forEach((nodeId, index) => {
            let node = globalNodeMap.get(nodeId);
            controlFlowInfo.nodeIndexMap.set(nodeId, index + 1);
            globalNodeIndexMap.set(nodeId, index + 1);
            controlFlowInfo.nodeNameMap.set(nodeId, getNodeName(globalNodeMap.get(nodeId)));

            if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0) {
              if (is(node, 'bpmn:CallActivity')) controlFlowInfo.externalBundles.set(nodeId, node.documentation[0].text);else extractParameters(node.documentation[0].text, node.id, controlFlowInfo);
            }
          });
          controlFlowInfo.edgeList.forEach((edgeId, index) => {
            controlFlowInfo.edgeIndexMap.set(edgeId, index + 1);
            globalEdgeIndexMap.set(edgeId, index + 1);
          });
          controlFlowInfo.catchingMessages = catchingMessages; // ControlFlow Perspective: Generation of Smart Contracts

          let codeGenerationInfo = {
            nodeList: controlFlowInfo.nodeList,
            nodeMap: globalNodeMap,
            catchingMessages: controlFlowInfo.catchingMessages,
            multiinstanceActivities: multiinstanceActivities,
            callActivities: callActivities,
            nonInterruptingEvents: nonInterruptingEvents,
            oracleInfo: controlFlowInfo.oracleInfo,
            oracleTaskMap: controlFlowInfo.oracleTaskMap,
            processId: () => controlFlowInfo.self.id,
            nodeName: nodeId => getNodeName(globalNodeMap.get(nodeId)),
            eventType: nodeId => {
              let node = globalNodeMap.get(nodeId);

              if (node.eventDefinitions && node.eventDefinitions[0]) {
                let cad = node.eventDefinitions[0].$type;
                return cad.substring(5, cad.length - 15);
              }

              return "Default";
            },
            allEventTypes: () => {
              let taken = [];
              globalNodeMap.forEach(node => {
                if (node.eventDefinitions && node.eventDefinitions[0] && !is(node.eventDefinitions[0], "bpmn:TerminateEventDefinition") && !is(node.eventDefinitions[0], "bpmn:MessageEventDefinition")) {
                  let cad = node.eventDefinitions[0].$type;
                  if (taken.indexOf(cad.substring(5, cad.length - 15)) < 0) taken.push(cad.substring(5, cad.length - 15));
                }
              });
              return taken;
            },
            getMessages: () => {
              let taken = [];
              let candidates = controlFlowInfo.boundaryEvents;
              controlFlowInfo.nodeList.forEach(nodeId => {
                if (is(globalNodeMap.get(nodeId), "bpmn:SubProcess")) {
                  let subP = globalControlFlowInfoMap.get(nodeId);
                  candidates = candidates.concat(subP.boundaryEvents);
                  subP.sources.forEach(id => {
                    if (!is(globalNodeMap.get(id), "bpmn:Subprocess") && candidates.indexOf(id) < 0) candidates.push(id);
                  });
                }
              });
              candidates.forEach(evtId => {
                let evt = globalNodeMap.get(evtId);
                if (evt.eventDefinitions && evt.eventDefinitions[0] && is(evt.eventDefinitions[0], "bpmn:MessageEventDefinition")) taken.push(evtId);
              });
              return taken;
            },
            getThrowingMessages: () => {
              let res = [];
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);
                if ((is(node, "bpmn:EndEvent") || is(node, "bpmn:IntermediateThrowEvent")) && node.eventDefinitions && node.eventDefinitions[0] && is(node.eventDefinitions[0], "bpmn:MessageEventDefinition")) res.push(nodeId);
              });
              return res;
            },
            getThrowingEvents: (subprocId, evType) => {
              let res = [];
              globalNodeMap.forEach(node => {
                if (node.eventDefinitions && node.eventDefinitions[0]) {
                  let cad = node.eventDefinitions[0].$type;

                  if (cad.substring(5, cad.length - 15) === evType) {
                    if ((is(node, "bpmn:EndEvent") || is(node, "bpmn:IntermediateThrowEvent")) && (node.$parent.id === subprocId || controlFlowInfo.nodeList.indexOf(node.id) >= 0)) {
                      res.push(node.id);
                    }
                  }
                }
              });
              return res;
            },
            getCatchingEvents: subprocId => {
              let res = [];
              globalNodeMap.forEach(node => {
                if (node.eventDefinitions && node.eventDefinitions[0]) {
                  if (is(node, "bpmn:StartEvent")) {
                    let parent = globalNodeMap.get(node.$parent.id);
                    if (parent.triggeredByEvent && parent.$parent.id === subprocId) res.unshift(node.id);else if (!parent.triggeredByEvent && (parent.id === subprocId || controlFlowInfo.nodeList.indexOf(parent.id) > -1)) res.push(node.id);
                  } else if (is(node, "bpmn:BoundaryEvent") || is(node, "bpmn:IntermediateCatchEvent")) {
                    if (node.$parent.id === subprocId || controlFlowInfo.nodeList.indexOf(node.$parent.id) > -1) res.push(node.id);
                  }
                }
              });
              return res;
            },
            getTerminateCandidates: subprocId => {
              let res = [];
              globalNodeMap.forEach(node => {
                if (node.eventDefinitions && node.eventDefinitions[0]) {
                  if (is(node, "bpmn:BoundaryEvent") && node.cancelActivity == false) {
                    if (globalControlFlowInfoMap.has(node.id)) {
                      let localC = globalControlFlowInfoMap.get(node.id);
                      localC.nodeList.forEach(elemId => {
                        let elem = globalNodeMap.get(elemId);
                        if (elem.eventDefinitions && is(elem.eventDefinitions[0], "bpmn:TerminateEventDefinition") && elem.$parent.id === node.$parent.id) res.push(node.id);
                      });
                    } else {
                      debug('Missing Non Interrupting event');
                    }
                  }
                }
              });
              return res;
            },
            getProcessCandidatesMaskFrom: (evtId, evtType, evtCode, sourceProcesses, allEvents) => {
              let eventList = [];
              let bitarray = [];
              allEvents.forEach(nodeId => {
                let cad = globalNodeMap.get(nodeId).eventDefinitions[0].$type;
                if (evtType === cad.substring(5, cad.length - 15) && evtCode === getNodeName(globalNodeMap.get(nodeId))) eventList.push(nodeId);
              });
              sourceProcesses.forEach(procId => {
                let parent = globalNodeMap.get(procId);
                let previousParent = parent;
                let res = [];
                let eventFound = false;

                while (!eventFound && res.length == 0 && parent.$parent && controlFlowInfo.self.id !== parent.id) {
                  parent = globalNodeMap.get(parent.$parent.id);
                  eventList.forEach(nodeId => {
                    let node = globalNodeMap.get(nodeId);

                    if (!eventFound && is(node, "bpmn:BoundaryEvent") && node.attachedToRef.id === previousParent.id) {
                      eventFound = node.cancelActivity != false;
                      if (eventFound) res = [nodeId];else res.push(nodeId);
                    }
                  });

                  if (res.length == 0) {
                    eventList.forEach(nodeId => {
                      let node = globalNodeMap.get(nodeId);

                      if (!eventFound && is(node, "bpmn:StartEvent") && node.$parent.triggeredByEvent && node.$parent.$parent.id === parent.id) {
                        eventFound = node.isInterrupting != false;
                        if (eventFound) res = [nodeId];else res.push(nodeId);
                      }
                    });
                  }

                  previousParent = parent;
                }

                if (res.indexOf(evtId)) bitarray[globalNodeIndexMap.get(procId)] = 1;
              });
              let result = "0b";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return result === "0b" ? 0 : new _bignumber.default(result).toFixed();
            },
            getCatchingEventsFrom: (procId, evtType, evtCode) => {
              // Escalation and Error catching events.
              // No intermediate events in normal flow allowed
              let res = [];
              let parent = globalNodeMap.get(procId);
              let eventFound = false;
              let candidates = controlFlowInfo.boundaryEvents.concat(controlFlowInfo.nodeList);
              let eventList = [];
              candidates.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (node.eventDefinitions) {
                  let cad = node.eventDefinitions[0].$type;
                  let type = cad.substring(5, cad.length - 15);

                  if (type === evtType && evtCode === getNodeName(globalNodeMap.get(nodeId)) && eventList.indexOf(nodeId) < 0) {
                    eventList.push(nodeId);
                  }
                }
              });

              if (!parent.triggeredByEvent) {
                eventList.forEach(nodeId => {
                  let node = globalNodeMap.get(nodeId);

                  if (!eventFound && is(node, "bpmn:StartEvent") && node.$parent.triggeredByEvent && node.$parent.$parent.id === parent.id) {
                    eventFound = node.isInterrupting != false;
                    if (eventFound) res = [nodeId];else res.push(nodeId);
                  }
                });
              }

              if (controlFlowInfo.self.id === procId || res.length > 0) {
                return res;
              } else {
                if (parent.triggeredByEvent) parent = globalNodeMap.get(parent.$parent.id);
                let previousParent = parent;

                while (!eventFound && res.length == 0 && parent.$parent && controlFlowInfo.self.id !== parent.id) {
                  parent = globalNodeMap.get(parent.$parent.id);
                  eventList.forEach(nodeId => {
                    let node = globalNodeMap.get(nodeId);

                    if (!eventFound && is(node, "bpmn:BoundaryEvent") && node.attachedToRef.id === previousParent.id) {
                      eventFound = node.cancelActivity != false;
                      if (eventFound) res = [nodeId];else res.push(nodeId);
                    }
                  });

                  if (res.length == 0) {
                    eventList.forEach(nodeId => {
                      let node = globalNodeMap.get(nodeId);

                      if (!eventFound && is(node, "bpmn:StartEvent") && node.$parent.triggeredByEvent && node.$parent.$parent.id === parent.id) {
                        eventFound = node.isInterrupting != false;
                        if (eventFound) res = [nodeId];else res.push(nodeId);
                      }
                    });
                  }

                  previousParent = parent;
                }

                return res;
              }
            },
            getWorkItemsGroupByParameters: isInput => {
              let name2Ids = new Map();
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (is(node, 'bpmn:UserTask') || is(node, 'bpmn:ReceiveTask') || catchingMessages.indexOf(nodeId) >= 0) {
                  let params = "";

                  if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0 && extractParameters(node.documentation[0].text, nodeId, null) !== undefined) {
                    let localParams = isInput ? extractParameters(node.documentation[0].text, nodeId, null).get("input") : extractParameters(node.documentation[0].text, nodeId, null).get("output");

                    if (localParams.length > 0) {
                      params = localParams[0];

                      for (let i = 2; i < localParams.length; i += 2) params += localParams[i];
                    }
                  }

                  let name = getNodeName(globalNodeMap.get(nodeId)) + params;

                  if (!name2Ids.has(name)) {
                    name2Ids.set(name, []);
                  }

                  name2Ids.get(name).push(nodeId);
                }
              });
              return name2Ids;
            },
            getContracts2Call: () => {
              let res = callActivities.concat(multiinstanceActivities);
              nonInterruptingEvents.forEach(evtId => {
                let node = globalNodeMap.get(evtId);
                res.push(is(node, "bpmn:StartEvent") ? node.$parent.id : evtId);
              });
              return res;
            },
            getContracts2CallFrom: (subprocId, candidates) => {
              let res = [subprocId];

              if (!controlFlowInfo.callActivities.has(subprocId)) {
                candidates.forEach(nodeId => {
                  let node = globalNodeMap.get(nodeId);

                  while (node.$parent) {
                    if (node.$parent.id === subprocId) {
                      res.push(nodeId);
                      break;
                    }

                    node = node.$parent;
                  }
                });
              }

              return res;
            },
            getContracts2CallMaskFrom: (subprocId, candidates) => {
              let bitarray = [];
              candidates.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                while (node.$parent) {
                  if (node.$parent.id === subprocId) {
                    bitarray[globalNodeIndexMap.get(nodeId)] = 1;
                    break;
                  }

                  node = node.$parent;
                }
              });
              let result = "0b";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return result === "0b" ? 0 : new _bignumber.default(result).toFixed();
            },
            getContracts2CallArray: (subprocId, candidates) => {
              let res = '[uint(' + globalNodeIndexMap.get(candidates[0]) + ')';

              for (let i = 1; i < candidates.length; i++) res += ', uint(' + globalNodeIndexMap.get(candidates[i]) + ')';

              return res + ']';
            },
            getPossibleKillSubprocess: () => {
              let res = [];
              controlFlowInfo.boundaryEvents.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (node.$parent.triggeredByEvent && node.$parent.$parent.id !== controlFlowInfo.self.id) {
                  if (node.isInterrupting != false && res.indexOf(node.$parent.$parent.id) < 0) res.push(node.$parent.$parent.id);
                } else if (node.attachedToRef) {
                  let attachedTo = node.attachedToRef.id;

                  if (node.cancelActivity != false && res.indexOf(attachedTo) < 0) {
                    res.push(attachedTo);
                  }
                }
              });
              globalNodeMap.forEach(node => {
                if (node.eventDefinitions && node.eventDefinitions[0]) {
                  if (is(node, "bpmn:BoundaryEvent") && node.cancelActivity == false) {
                    if (globalControlFlowInfoMap.has(node.id)) {
                      let localC = globalControlFlowInfoMap.get(node.id);
                      localC.nodeList.forEach(elemId => {
                        let elem = globalNodeMap.get(elemId);

                        if (elem.eventDefinitions && is(elem.eventDefinitions[0], "bpmn:TerminateEventDefinition") && elem.$parent.id === node.$parent.id && controlFlowInfo.nodeList.indexOf(node.$parent.id) >= 0 && res.indexOf(node.$parent.id) < 0 && node.$parent.id != controlFlowInfo.self.id) {
                          res.push(node.$parent.id);
                        }
                      });
                    }
                  }
                }
              });
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (node.eventDefinitions && is(node.eventDefinitions[0], "bpmn:TerminateEventDefinition")) {
                  if (res.indexOf(node.$parent.id) < 0 && node.$parent.id != controlFlowInfo.self.id && !is(globalNodeMap.get(controlFlowInfo.self.id), "bpmn:BoundaryEvent")) {
                    debug('I am here 2');
                    res.push(node.$parent.id);
                  }
                }
              });
              return res;
            },
            getCountExternalTasks: () => {
              let res = 0;
              controlFlowInfo.nodeList.forEach(nodeId => {
                if (hasExternalCall(nodeId)) res++;
              });
              return res;
            },
            getStartedMessages: processId => {
              let res = [];
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);
                if (is(node, "bpmn:StartEvent") && node.$parent.id === processId && node.eventDefinitions && is(node.eventDefinitions[0], "bpmn:MessageEventDefinition") && globalNodeMap.get(node.$parent.id).triggeredByEvent) res.push(nodeId);
              });
              return res;
            },
            getParent: nodeId => {
              // Retrieves the id of the parent
              let node = globalNodeMap.get(nodeId);
              if (is(node, "bpmn:StartEvent") && node.$parent && globalNodeMap.get(node.$parent.id).triggeredByEvent) return globalNodeMap.get(node.$parent.id).$parent.id;
              if (is(node, "bpmn:BoundaryEvent") && node.cancelActivity) return node.attachedToRef.id;
              return node.$parent ? node.$parent.id : nodeId;
            },
            getContractName: nodeId => {
              // Retrieves the contract name related to the node.
              let node = globalNodeMap.get(nodeId);
              if (is(node, "bpmn:StartEvent") && node.$parent && globalNodeMap.get(node.$parent.id).triggeredByEvent) return node.$parent.id;
              if (is(node, "bpmn:BoundaryEvent")) return node.id;
              return controlFlowInfo.self.id;
            },
            getAllChildren: (subprocId, direct) => {
              let taken = direct ? [] : [subprocId];
              controlFlowInfo.nodeList.map(nodeId => globalNodeMap.get(nodeId)).forEach(e => {
                if (is(e, "bpmn:SubProcess") || callActivities.indexOf(e.id) >= 0 || nonInterruptingEvents.indexOf(e.id) >= 0 && !is(e, "bpmn:StartEvent")) if ((direct && subprocId !== e.id && e.$parent.id === subprocId || !direct) && taken.indexOf(e.id) < 0) taken.push(e.id);
              });
              return taken;
            },
            isStartingContractEvent: (eventId, processId) => {
              let evt = globalNodeMap.get(eventId);

              if (is(evt, "bpmn:StartEvent")) {
                if (globalNodeMap.get(evt.$parent.id).triggeredByEvent) return evt.$parent.id !== processId;
                if (is(evt.eventDefinitions[0], "bpmn:MessageEventDefinition")) return true;
              } else if (is(evt, "bpmn:BoundaryEvent")) {
                return eventId !== processId;
              } else if (is(evt, "bpmn:IntermediateCatchEvent") && is(evt.eventDefinitions[0], "bpmn:MessageEventDefinition")) return true;

              return false;
            },
            isInterrupting: eventId => {
              // True if an event is interrupting
              let node = globalNodeMap.get(eventId);
              if (node.eventDefinitions && is(node.eventDefinitions[0], "bpmn:ErrorEventDefinition")) return true;
              if (is(node, "bpmn:StartEvent") && node.$parent && globalNodeMap.get(node.$parent.id).triggeredByEvent) return node.isInterrupting != false;
              if (is(node, "bpmn:BoundaryEvent")) return node.cancelActivity != false;
              return false;
            },
            isEmbeddedSubprocess: subprocessId => {
              return globalControlFlowInfoMap.get(subprocessId).isEmbedded;
            },
            isBoundaryEvent: evtId => {
              return controlFlowInfo.boundaryEvents.indexOf(evtId) >= 0;
            },
            preMarking: nodeId => {
              let node = globalNodeMap.get(nodeId);
              let bitarray = [];
              if (node.incoming) for (let incoming of node.incoming) bitarray[controlFlowInfo.edgeIndexMap.get(incoming.id)] = 1;else bitarray[0] = 1;
              let result = "0b";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            postMarking: nodeId => {
              let node = globalNodeMap.get(nodeId);
              let bitarray = [];
              let result = "0b";
              if (node.outgoing) for (let outgoing of node.outgoing) {
                bitarray[controlFlowInfo.edgeIndexMap.get(outgoing.id)] = 1;
              } else result = "0";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            subprocessNodeMarking: subprocessId => {
              let bitarray = [];
              globalNodeMap.forEach(node => {
                if (node.$parent && node.$parent.id === subprocessId) {
                  if (is(node, "bpmn:Task") || is(node, 'bpmn:SubProcess')) bitarray[globalNodeIndexMap.get(node.id)] = 1;else if (!globalNodeMap.get(subprocessId).triggeredByEvent && node.eventDefinitions && node.eventDefinitions[0] && is(node.eventDefinitions[0], "bpmn:MessageEventDefinition")) bitarray[globalNodeIndexMap.get(node.id)] = 1;
                }
              });
              let result = bitarray.length > 0 ? "0b" : 0;

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            subprocessNodeFullMarking: subprocId => {
              let children = [subprocId];
              let bitarray = [];
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (is(node, "bpmn:SubProcess") || callActivities.indexOf(node.id) >= 0 || nonInterruptingEvents.indexOf(node.id) >= 0 && !is(node, "bpmn:StartEvent")) {
                  while (node.$parent) {
                    if (node.$parent.id === subprocId) {
                      if (multiinstanceActivities.indexOf(nodeId) >= 0 || callActivities.indexOf(node.id) >= 0 || nonInterruptingEvents.indexOf(node.id) >= 0) {
                        bitarray[globalNodeIndexMap.get(nodeId)] = 1;
                      } else if (children.indexOf(nodeId) < 0) {
                        children.push(nodeId);
                      }

                      break;
                    }

                    node = node.$parent;
                  }
                }
              });
              let result = "0b";
              if (globalNodeIndexMap.get(subprocId)) bitarray[globalNodeIndexMap.get(subprocId)] = 1;
              controlFlowInfo.nodeList.map(nodeId => globalNodeMap.get(nodeId)).forEach(node => {
                if (node.$parent && children.indexOf(node.$parent.id) >= 0) {
                  bitarray[globalNodeIndexMap.get(node.id)] = 1;
                }
              });
              catchingMessages.map(evtId => globalNodeMap.get(evtId)).forEach(evt => {
                if (evt.attachedToRef && children.indexOf(evt.attachedToRef) >= 0) {
                  bitarray[globalNodeIndexMap.get(evt.id)] = 1;
                }
              });

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return result === '0b' ? new _bignumber.default(0) : new _bignumber.default(result).toFixed();
            },
            subprocessStartMarking: subprocessId => {
              let toSearch = globalNodeMap.get(subprocessId);
              let bitarray = [];
              let result = "0b";

              if (is(toSearch, "bpmn:BoundaryEvent")) {
                for (let outgoing of toSearch.outgoing) bitarray[controlFlowInfo.edgeIndexMap.get(outgoing.id)] = 1;
              } else {
                for (let node of toSearch.flowElements.filter(e => is(e, "bpmn:FlowNode") && is(e, "bpmn:StartEvent"))) {
                  if (node.$parent.id === subprocessId) if (!globalNodeMap.get(node.$parent.id).triggeredByEvent && node.eventDefinitions && node.eventDefinitions[0] && is(node.eventDefinitions[0], "bpmn:MessageEventDefinition")) bitarray[0] = 1;else if (node.outgoing) for (let outgoing of node.outgoing) bitarray[controlFlowInfo.edgeIndexMap.get(outgoing.id)] = 1;
                }
              }

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            getAllAncestorsMask: subprocId => {
              let bitarray = [];
              let result = "0b";
              let node = globalNodeMap.get(subprocId);

              while (node.$parent) {
                bitarray[controlFlowInfo.nodeIndexMap.get(node.id)] = 1;
                node = node.$parent;
              }

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            subprocessMarking: subprocessId => {
              let bitarray = [];
              let result = "0b";
              let localInfo = globalControlFlowInfoMap.get(subprocessId);
              let edgeList = [];
              localInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (node.$parent && node.$parent.id === subprocessId && node.incoming) {
                  for (let incoming of node.incoming) {
                    edgeList.push(incoming.id);
                  }
                }
              });
              edgeList.forEach(edgeId => {
                bitarray[controlFlowInfo.edgeIndexMap.get(edgeId)] = 1;
              });

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            subprocessFullMarking: subprocId => {
              let bitarray = [];
              let result = "0b";
              let children = [subprocId];
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (is(node, "bpmn:SubProcess") && multiinstanceActivities.indexOf(nodeId) < 0) {
                  while (node.$parent) {
                    if (node.$parent.id === subprocId) {
                      if (children.indexOf(nodeId) < 0) children.push(nodeId);
                      break;
                    }

                    node = node.$parent;
                  }
                }
              });
              children.forEach(subprocessId => {
                let localInfo = globalControlFlowInfoMap.get(subprocessId);
                localInfo.edgeList.forEach(edgeId => {
                  bitarray[controlFlowInfo.edgeIndexMap.get(edgeId)] = 1;
                });
              });

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            flowEdgeIndex: flowEdgeId => {
              let bitarray = [];
              bitarray[controlFlowInfo.edgeIndexMap.get(flowEdgeId)] = 1;
              let result = "0b";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            flowNodeIndex: flowNodeId => {
              let bitarray = [];
              bitarray[globalNodeIndexMap.get(flowNodeId)] = 1;
              let result = "0b";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            nodeRealIndex: nodeId => {
              return globalNodeIndexMap.get(nodeId);
            },
            isPartOfDeferredChoice: eventId => {
              let event = globalNodeMap.get(eventId);

              if (event.incoming) {
                let node = event.incoming[0].sourceRef;
                return is(node, "bpmn:EventBasedGateway");
              }

              return false;
            },
            getDeferredChoiceElements: nodeId => {
              let event = globalNodeMap.get(nodeId);
              let res = [];

              if (event.incoming) {
                let node = event.incoming[0].sourceRef;

                if (is(node, "bpmn:EventBasedGateway")) {
                  for (let outgoing of node.outgoing) {
                    if (outgoing.targetRef.id !== nodeId) res.push(outgoing.targetRef.id);
                  }
                }
              }

              return res;
            },
            deferredChoiceNodeMarking: nodeId => {
              let event = globalNodeMap.get(nodeId);
              let bitarray = [];

              if (event.incoming) {
                let node = event.incoming[0].sourceRef;

                if (is(node, "bpmn:EventBasedGateway")) {
                  for (let outgoing of node.outgoing) {
                    bitarray[controlFlowInfo.nodeIndexMap.get(outgoing.targetRef.id)] = 1;
                  }
                }
              }

              let result = "0";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            deferredChoiceMarking: eventId => {
              let event = globalNodeMap.get(eventId);
              let node = event.incoming[0].sourceRef;
              let bitarray = [];
              let result = "0b";
              if (node.outgoing) for (let outgoing of node.outgoing) {
                bitarray[controlFlowInfo.edgeIndexMap.get(outgoing.id)] = 1;
              } else result = "0";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            globalDeclarations: () => {
              if (controlFlowInfo.globalParameters.length > 0) return controlFlowInfo.globalParameters;else return "";
            },
            getOracleFunction: nodeId => {
              if (controlFlowInfo.oracleTaskMap.has(nodeId)) return controlFlowInfo.oracleInfo.get(controlFlowInfo.oracleTaskMap.get(nodeId)).functionName;
              return "";
            },
            nodeParameters: nodeId => {
              let node = globalNodeMap.get(nodeId);

              if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0) {
                let resDict = extractParameters(node.documentation[0].text, nodeId, null);
                return resDict !== undefined ? resDict.get("input").length > 0 || resDict.get("output").length > 0 : false;
              }

              return false;
            },
            typeParameters: (nodeId, isInput, hasPreviousParameter) => {
              let node = globalNodeMap.get(nodeId);
              let res = "";

              if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0 && extractParameters(node.documentation[0].text, nodeId, null) !== undefined) {
                let localParams = isInput ? extractParameters(node.documentation[0].text, nodeId, null).get("input") : extractParameters(node.documentation[0].text, nodeId, null).get("output");

                if (localParams.length > 0) {
                  res = localParams[0];

                  for (let i = 2; i < localParams.length; i += 2) res += ", " + localParams[i];
                }
              }

              return hasPreviousParameter && res.length > 0 ? ", " + res : res;
            },
            concatParameters: (nodeId, isInput, hasType, hasPreviousParameter) => {
              let node = globalNodeMap.get(nodeId);
              let res = "";

              if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0 && extractParameters(node.documentation[0].text, nodeId, null) !== undefined) {
                let localParams = isInput ? extractParameters(node.documentation[0].text, nodeId, null).get("input") : extractParameters(node.documentation[0].text, nodeId, null).get("output");

                if (localParams.length > 0) {
                  res = hasType ? localParams[0] + " " + localParams[1] : localParams[1];

                  for (let i = 2; i < localParams.length; i += 2) res += "," + (hasType ? localParams[i] + " " + localParams[i + 1] : localParams[i + 1]);
                }
              }

              return hasPreviousParameter && res.length > 0 ? ", " + res : res;
            },
            nodeFunctionBody: nodeId => {
              let node = globalNodeMap.get(nodeId);

              if (node.script) {
                return node.script.split("->");
              } else if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0 && extractParameters(node.documentation[0].text, nodeId, null) !== undefined) {
                return extractParameters(node.documentation[0].text, nodeId, null).get("body");
              } else return "";
            },
            getCondition: flowEdge => flowEdge.conditionExpression ? flowEdge.conditionExpression.body : flowEdge.name ? flowEdge.name : flowEdge.id,
            is: is
          };
          let localSolidity = bpmn2solTemplate(codeGenerationInfo); // Code for using the worklist template

          let userTaskList = [];
          let parameterInfo = new Map();
          controlFlowInfo.nodeList.forEach(nodeId => {
            let node = globalNodeMap.get(nodeId);

            if (is(node, 'bpmn:UserTask') || is(node, 'bpmn:ReceiveTask')) {
              userTaskList.push(nodeId);

              if (controlFlowInfo.localParameters.has(nodeId) && (controlFlowInfo.localParameters.get(nodeId).get('input').length > 0 || controlFlowInfo.localParameters.get(nodeId).get('output').length > 0)) {
                parameterInfo.set(nodeId, controlFlowInfo.localParameters.get(nodeId));
              }
            }
          });
          if (controlFlowInfo.catchingMessages.length > 0) userTaskList = userTaskList.concat(controlFlowInfo.catchingMessages); // worklist: Smart Contract Generation

          let worklistGenerationInfo = {
            nodeList: userTaskList,
            restrictRelation: restrictRelation,
            parameterInfo: parameterInfo,
            nodeIndex: globalNodeIndexMap,
            nodeMap: globalNodeMap,
            processId: () => controlFlowInfo.self.id,
            nodeName: nodeId => {
              return getNodeName(globalNodeMap.get(nodeId));
            },
            getParameterType: (nodeId, isInput, isType, hasPrevious) => {
              let res = "";

              if (parameterInfo.get(nodeId)) {
                let localParams = isInput ? parameterInfo.get(nodeId).get("input") : parameterInfo.get(nodeId).get("output");

                if (localParams && localParams.length > 0) {
                  res = isType ? localParams[0].type : localParams[0].name;

                  for (let i = 1; i < localParams.length; i++) res += isType ? ", " + localParams[i].type : ", " + localParams[i].name;
                }
              }

              return res.length > 0 && hasPrevious ? ", " + res : res;
            },
            getParameters: (nodeId, isInput, hasType, hasPrevious) => {
              let res = "";

              if (parameterInfo.get(nodeId)) {
                let localParams = isInput ? parameterInfo.get(nodeId).get("input") : parameterInfo.get(nodeId).get("output");

                if (localParams && localParams.length > 0) {
                  res = hasType ? localParams[0].type + " " + localParams[0].name : localParams[0].name;

                  for (let i = 1; i < localParams.length; i++) res += hasType ? ", " + localParams[i].type + " " + localParams[i].name : ", " + localParams[i].name;
                }
              }

              return res.length > 0 && hasPrevious ? ", " + res : res;
            },
            getWorkItemsGroupByParameters: isInput => {
              let name2Ids = new Map();
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (is(node, 'bpmn:UserTask') || is(node, 'bpmn:ReceiveTask') || catchingMessages.indexOf(nodeId) >= 0) {
                  let params = "";

                  if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0 && extractParameters(node.documentation[0].text, nodeId, null) !== undefined) {
                    let localParams = isInput ? extractParameters(node.documentation[0].text, nodeId, null).get("input") : extractParameters(node.documentation[0].text, nodeId, null).get("output");

                    if (localParams.length > 0) {
                      params = localParams[0];

                      for (let i = 2; i < localParams.length; i += 2) params += localParams[i];
                    }
                  }

                  let name = getNodeName(globalNodeMap.get(nodeId)) + params;

                  if (!name2Ids.has(name)) {
                    name2Ids.set(name, []);
                  }

                  name2Ids.get(name).push(nodeId);
                }
              });
              return name2Ids;
            },
            is: is
          };
          modelInfo.solidity += localSolidity;

          if (userTaskList.length > 0) {
            modelInfo.solidity += worklist2solTemplate(worklistGenerationInfo);
            debug(JSON.stringify(modelInfo.solidity));
          }

          modelInfo.controlFlowInfoMap.set(controlFlowInfo.self.id, controlFlowInfo);
        } else {
          controlFlowInfo.nodeList.forEach(nodeId => controlFlowInfo.nodeIndexMap.set(nodeId, globalNodeIndexMap.get(nodeId)));
          controlFlowInfo.edgeList.forEach(edgeId => controlFlowInfo.edgeIndexMap.set(edgeId, globalEdgeIndexMap.get(edgeId)));
        }
      } //////////////////////////////////////////////////////////////////////////////////


      modelInfo.entryContractName = modelInfo.name + ":" + (proc.name ? proc.name.replace(/\s+/g, "_") : proc.id) + "_Contract";
      resolve();
    }).catch(err => {
      throw new Error(err);
      reject();
    });
  });
};

var _default = parseModel;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2FwcC9yZXNvbHZlcnMvbXV0YXRpb24vbW9kZWwvcGFyc2UtbW9kZWwudHMiXSwibmFtZXMiOlsiZGVidWciLCJicG1uMnNvbFRlbXBsYXRlIiwiZWpzIiwiY29tcGlsZSIsImJwbW4yc29sRUpTIiwid29ya2xpc3Qyc29sVGVtcGxhdGUiLCJ3b3JrbGlzdDJzb2xFSlMiLCJtb2RkbGUiLCJCcG1uTW9kZGxlIiwicGFyc2VCcG1uIiwiYnBtbkRvYyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnJvbVhNTCIsImVyciIsImRlZmluaXRpb25zIiwiaXMiLCJlbGVtZW50IiwidHlwZSIsIiRpbnN0YW5jZU9mIiwiY29sbGVjdENvbnRyb2xGbG93SW5mbyIsInByb2MiLCJnbG9iYWxOb2RlTWFwIiwiZ2xvYmFsQ29udHJvbEZsb3dJbmZvIiwibm9kZUxpc3QiLCJlZGdlTGlzdCIsImJvdW5kYXJ5RXZlbnRzIiwibm9uQmxvY2tpbmdCb3VuZGFyeUV2ZW50cyIsImNvbnRyb2xGbG93SW5mbyIsIm5vZGUiLCJmbG93RWxlbWVudHMiLCJmaWx0ZXIiLCJlIiwicHVzaCIsImlkIiwiY2FuY2VsQWN0aXZpdHkiLCJzZXQiLCJzb3VyY2VzIiwiZmxvd0VkZ2UiLCJpbmRleE9mIiwidGFyZ2V0UmVmIiwic3BsaWNlIiwibGVuZ3RoIiwiZGZzIiwib3BlbiIsImN1cnJJZCIsInBvcCIsImN1cnIiLCJnZXQiLCJvdXRnb2luZyIsInN1Y2NFZGdlIiwic3VjYyIsIm1haW5QYXRoTm9kZUxpc3QiLCJtYWluUGF0aEVkZ2VMaXN0IiwibG9jYWxCb3VuZGFyeSIsImZvckVhY2giLCJldnRJZCIsImJvdW5kYXJ5Tm9kZVBhdGgiLCJib3VuZGFyeUVkZ2VQYXRoIiwiY29uY2F0IiwiQ29udHJvbEZsb3dJbmZvIiwiZXZlbnRJZCIsImV2ZW50IiwiZmluZCIsImF0dGFjaGVkVG9SZWYiLCJFcnJvciIsImxvY2FsTm9kZUxpc3QiLCJsb2NhbEVkZ2VMaXN0Iiwibm9kZUlkIiwiY2hpbGRDb250cm9sRmxvd0luZm8iLCJwYXJlbnQiLCJzdWJwcm9jZXNzIiwic3VicHJvY2Vzc0NvbnRyb2xGbG93SW5mbyIsImxvb3BDaGFyYWN0ZXJpc3RpY3MiLCIkdHlwZSIsImlzRW1iZWRkZWQiLCJkb2N1bWVudGF0aW9uIiwiZ2xvYmFsUGFyYW1ldGVycyIsInRleHQiLCJyZXN0cmljdFJlbGF0aW9uIiwiTWFwIiwiZXh0cmFjdFBhcmFtZXRlcnMiLCJjYWQiLCJhcnIiLCJzcGxpdCIsInRhc2tSb2xlTWFwIiwidHJpbSIsInVuZGVmaW5lZCIsIm9yYWNsZV9EYXRhIiwiaiIsImZpcnN0IiwiY2hhckF0Iiwic3Vic3RyIiwicmVwbGFjZSIsImZpcnN0U3BsaXQiLCJhdXgiLCJpIiwic2Vjb25kU3BsaXQiLCJyZXNNYXAiLCJpbnB1dE91dHB1dCIsInBhcmFtZXRlclR5cGUiLCJ0ZW1wIiwicmVzIiwic3ViQ2FkIiwiaW5QYXJhbWV0ZXJzIiwib3V0UGFyYW1ldGVycyIsInRvSXRlcmF0ZSIsIlBhcmFtZXRlckluZm8iLCJwYXJhbWV0ZXJzIiwic3BsaXRSZXN1bHQiLCJvcmFjbGVJbmZvIiwiaGFzIiwiT3JhY2xlSW5mbyIsIm9yYWNsZVRhc2tNYXAiLCJsb2NhbE9yYWNsZSIsImFkZHJlc3MiLCJmdW5jdGlvbk5hbWUiLCJmdW5jdGlvblBhcmFtZXRlcnMiLCJsb2NhbFBhcmFtZXRlcnMiLCJnZXROb2RlTmFtZSIsIm5hbWUiLCJwYXJzZU1vZGVsIiwibW9kZWxJbmZvIiwiYnBtbiIsInRoZW4iLCJzb2xpZGl0eSIsImNvbnRyb2xGbG93SW5mb01hcCIsImRpYWdyYW1zIiwicGxhbmUiLCJicG1uRWxlbWVudCIsInJvb3RFbGVtZW50cyIsImdsb2JhbE5vZGVJbmRleE1hcCIsImdsb2JhbEVkZ2VJbmRleE1hcCIsIm1haW5Db250cm9sRmxvd0luZm8iLCJnbG9iYWxDb250cm9sRmxvd0luZm9NYXAiLCJzZWxmIiwiaW5kZXhlc1RvUmVtb3ZlIiwidHJpZ2dlcmVkQnlFdmVudCIsIm5vZGVJbmZvIiwiaXNJbnRlcnJ1cHRpbmciLCJjaGlsZElkIiwiaW5kZXgiLCJzb3J0IiwiaW5kMSIsImluZDIiLCJoYXNFeHRlcm5hbENhbGwiLCJtdWx0aWluc3RhbmNlQWN0aXZpdGllcyIsImNhbGxBY3Rpdml0aWVzIiwibm9uSW50ZXJydXB0aW5nRXZlbnRzIiwiY2F0Y2hpbmdNZXNzYWdlcyIsIm1hcCIsImV2ZW50RGVmaW5pdGlvbnMiLCJzdGFydCIsIiRwYXJlbnQiLCJwYXJ0MSIsInBhcnQyIiwibm9kZUluZGV4TWFwIiwibm9kZU5hbWVNYXAiLCJleHRlcm5hbEJ1bmRsZXMiLCJlZGdlSWQiLCJlZGdlSW5kZXhNYXAiLCJjb2RlR2VuZXJhdGlvbkluZm8iLCJub2RlTWFwIiwicHJvY2Vzc0lkIiwibm9kZU5hbWUiLCJldmVudFR5cGUiLCJzdWJzdHJpbmciLCJhbGxFdmVudFR5cGVzIiwidGFrZW4iLCJnZXRNZXNzYWdlcyIsImNhbmRpZGF0ZXMiLCJzdWJQIiwiZXZ0IiwiZ2V0VGhyb3dpbmdNZXNzYWdlcyIsImdldFRocm93aW5nRXZlbnRzIiwic3VicHJvY0lkIiwiZXZUeXBlIiwiZ2V0Q2F0Y2hpbmdFdmVudHMiLCJ1bnNoaWZ0IiwiZ2V0VGVybWluYXRlQ2FuZGlkYXRlcyIsImxvY2FsQyIsImVsZW1JZCIsImVsZW0iLCJnZXRQcm9jZXNzQ2FuZGlkYXRlc01hc2tGcm9tIiwiZXZ0VHlwZSIsImV2dENvZGUiLCJzb3VyY2VQcm9jZXNzZXMiLCJhbGxFdmVudHMiLCJldmVudExpc3QiLCJiaXRhcnJheSIsInByb2NJZCIsInByZXZpb3VzUGFyZW50IiwiZXZlbnRGb3VuZCIsInJlc3VsdCIsIkJpZ051bWJlciIsInRvRml4ZWQiLCJnZXRDYXRjaGluZ0V2ZW50c0Zyb20iLCJnZXRXb3JrSXRlbXNHcm91cEJ5UGFyYW1ldGVycyIsImlzSW5wdXQiLCJuYW1lMklkcyIsInBhcmFtcyIsImxvY2FsUGFyYW1zIiwiZ2V0Q29udHJhY3RzMkNhbGwiLCJnZXRDb250cmFjdHMyQ2FsbEZyb20iLCJnZXRDb250cmFjdHMyQ2FsbE1hc2tGcm9tIiwiZ2V0Q29udHJhY3RzMkNhbGxBcnJheSIsImdldFBvc3NpYmxlS2lsbFN1YnByb2Nlc3MiLCJhdHRhY2hlZFRvIiwiZ2V0Q291bnRFeHRlcm5hbFRhc2tzIiwiZ2V0U3RhcnRlZE1lc3NhZ2VzIiwiZ2V0UGFyZW50IiwiZ2V0Q29udHJhY3ROYW1lIiwiZ2V0QWxsQ2hpbGRyZW4iLCJkaXJlY3QiLCJpc1N0YXJ0aW5nQ29udHJhY3RFdmVudCIsImlzRW1iZWRkZWRTdWJwcm9jZXNzIiwic3VicHJvY2Vzc0lkIiwiaXNCb3VuZGFyeUV2ZW50IiwicHJlTWFya2luZyIsImluY29taW5nIiwicG9zdE1hcmtpbmciLCJzdWJwcm9jZXNzTm9kZU1hcmtpbmciLCJzdWJwcm9jZXNzTm9kZUZ1bGxNYXJraW5nIiwiY2hpbGRyZW4iLCJzdWJwcm9jZXNzU3RhcnRNYXJraW5nIiwidG9TZWFyY2giLCJnZXRBbGxBbmNlc3RvcnNNYXNrIiwic3VicHJvY2Vzc01hcmtpbmciLCJsb2NhbEluZm8iLCJzdWJwcm9jZXNzRnVsbE1hcmtpbmciLCJmbG93RWRnZUluZGV4IiwiZmxvd0VkZ2VJZCIsImZsb3dOb2RlSW5kZXgiLCJmbG93Tm9kZUlkIiwibm9kZVJlYWxJbmRleCIsImlzUGFydE9mRGVmZXJyZWRDaG9pY2UiLCJzb3VyY2VSZWYiLCJnZXREZWZlcnJlZENob2ljZUVsZW1lbnRzIiwiZGVmZXJyZWRDaG9pY2VOb2RlTWFya2luZyIsImRlZmVycmVkQ2hvaWNlTWFya2luZyIsImdsb2JhbERlY2xhcmF0aW9ucyIsImdldE9yYWNsZUZ1bmN0aW9uIiwibm9kZVBhcmFtZXRlcnMiLCJyZXNEaWN0IiwidHlwZVBhcmFtZXRlcnMiLCJoYXNQcmV2aW91c1BhcmFtZXRlciIsImNvbmNhdFBhcmFtZXRlcnMiLCJoYXNUeXBlIiwibm9kZUZ1bmN0aW9uQm9keSIsInNjcmlwdCIsImdldENvbmRpdGlvbiIsImNvbmRpdGlvbkV4cHJlc3Npb24iLCJib2R5IiwibG9jYWxTb2xpZGl0eSIsInVzZXJUYXNrTGlzdCIsInBhcmFtZXRlckluZm8iLCJ3b3JrbGlzdEdlbmVyYXRpb25JbmZvIiwibm9kZUluZGV4IiwiZ2V0UGFyYW1ldGVyVHlwZSIsImlzVHlwZSIsImhhc1ByZXZpb3VzIiwiZ2V0UGFyYW1ldGVycyIsIkpTT04iLCJzdHJpbmdpZnkiLCJlbnRyeUNvbnRyYWN0TmFtZSIsImNhdGNoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBR0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7O0FBU0EsTUFBTUEsS0FBSyxHQUFHLHFCQUFPLDJCQUFQLENBQWQ7QUFFQSxNQUFNQyxnQkFBZ0IsR0FBR0MsR0FBRyxDQUFDQyxPQUFKLENBQVlDLFdBQVosQ0FBekI7QUFFQSxNQUFNQyxvQkFBb0IsR0FBR0gsR0FBRyxDQUFDQyxPQUFKLENBQVlHLGVBQVosQ0FBN0I7QUFFQSxJQUFJQyxNQUFNLEdBQUcsSUFBSUMsbUJBQUosRUFBYjs7QUFDQSxJQUFJQyxTQUFTLEdBQUdDLE9BQU8sSUFBSTtBQUN2QixTQUFPLElBQUlDLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDcENOLElBQUFBLE1BQU0sQ0FBQ08sT0FBUCxDQUFlSixPQUFmLEVBQXdCLENBQUNLLEdBQUQsRUFBTUMsV0FBTixLQUFzQjtBQUMxQyxVQUFJLENBQUNELEdBQUwsRUFBVUgsT0FBTyxDQUFDSSxXQUFELENBQVAsQ0FBVixLQUNLSCxNQUFNLENBQUNFLEdBQUQsQ0FBTjtBQUNSLEtBSEQ7QUFJSCxHQUxNLENBQVA7QUFNSCxDQVBEOztBQVNBLElBQUlFLEVBQUUsR0FBRyxDQUFDQyxPQUFELEVBQVVDLElBQVYsS0FBbUJELE9BQU8sQ0FBQ0UsV0FBUixDQUFvQkQsSUFBcEIsQ0FBNUI7O0FBQ0EsSUFBSUUsc0JBQUo7O0FBQ0FBLHNCQUFzQixHQUFHLENBQUNDLElBQUQsRUFDQ0MsYUFERCxFQUVDQyxxQkFGRCxLQUVvRTtBQUN6RixNQUFJQyxRQUF1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MUUsSUFBZ0YsV0FBOUc7QUFFQXZCLE1BQUFBLE9BQU87QUFDVixLQXQvQkwsRUF1L0JLOFAsS0F2L0JMLENBdS9CVzNQLEdBQUcsSUFBSTtBQUNWLFlBQU0sSUFBSW1ELEtBQUosQ0FBVW5ELEdBQVYsQ0FBTjtBQUNBRixNQUFBQSxNQUFNO0FBQ1QsS0ExL0JMO0FBMi9CSCxHQTUvQk0sQ0FBUDtBQTYvQkgsQ0E5L0JEOztlQWdnQ2U2RyxVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWJ1ZyBmcm9tICdkZWJ1ZydcbmltcG9ydCBCcG1uTW9kZGxlIGZyb20gXCJicG1uLW1vZGRsZVwiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyBlanMgZnJvbSBcImVqc1wiO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XG5pbXBvcnQge1xuICAgIENvbnRyb2xGbG93SW5mbyxcbiAgICBNb2RlbEluZm8sXG4gICAgUGFyYW1ldGVySW5mbyxcbiAgICBPcmFjbGVJbmZvXG59IGZyb20gXCIuL2RlZmluaXRpb25zXCI7XG5pbXBvcnQgYnBtbjJzb2xFSlMgZnJvbSAnLi4vLi4vLi4vdGVtcGxhdGVzL2JwbW4yc29sLmVqcycgXG5pbXBvcnQgd29ya2xpc3Qyc29sRUpTIGZyb20gJy4uLy4uLy4uL3RlbXBsYXRlcy93b3JrbGlzdDJzb2wuZWpzJyBcblxuY29uc3QgZGVidWcgPSBfZGVidWcoJ2NhdGVycGlsbGFycWw6cGFyc2UtbW9kZWwnKVxuXG5jb25zdCBicG1uMnNvbFRlbXBsYXRlID0gZWpzLmNvbXBpbGUoYnBtbjJzb2xFSlMpO1xuXG5jb25zdCB3b3JrbGlzdDJzb2xUZW1wbGF0ZSA9IGVqcy5jb21waWxlKHdvcmtsaXN0MnNvbEVKUyk7XG5cbmxldCBtb2RkbGUgPSBuZXcgQnBtbk1vZGRsZSgpO1xubGV0IHBhcnNlQnBtbiA9IGJwbW5Eb2MgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIG1vZGRsZS5mcm9tWE1MKGJwbW5Eb2MsIChlcnIsIGRlZmluaXRpb25zKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycikgcmVzb2x2ZShkZWZpbml0aW9ucyk7XG4gICAgICAgICAgICBlbHNlIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbmxldCBpcyA9IChlbGVtZW50LCB0eXBlKSA9PiBlbGVtZW50LiRpbnN0YW5jZU9mKHR5cGUpO1xubGV0IGNvbGxlY3RDb250cm9sRmxvd0luZm86IChwcm9jOiBhbnksIGdsb2JhbE5vZGVNYXA6IE1hcDxzdHJpbmcsIGFueT4sIGdsb2JhbENvbnRyb2xGbG93SW5mbzogQXJyYXk8Q29udHJvbEZsb3dJbmZvPikgPT4gQ29udHJvbEZsb3dJbmZvO1xuY29sbGVjdENvbnRyb2xGbG93SW5mbyA9IChwcm9jOiBhbnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbE5vZGVNYXA6IE1hcDxzdHJpbmcsIGFueT4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbENvbnRyb2xGbG93SW5mbzogQXJyYXk8Q29udHJvbEZsb3dJbmZvPik6IENvbnRyb2xGbG93SW5mbyA9PiB7XG4gICAgbGV0IG5vZGVMaXN0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgbGV0IGVkZ2VMaXN0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgbGV0IGJvdW5kYXJ5RXZlbnRzOiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgbGV0IG5vbkJsb2NraW5nQm91bmRhcnlFdmVudHM6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICBsZXQgY29udHJvbEZsb3dJbmZvOiBDb250cm9sRmxvd0luZm87XG5cbiAgICBmb3IgKGxldCBub2RlIG9mIHByb2MuZmxvd0VsZW1lbnRzLmZpbHRlcihlID0+IGlzKGUsIFwiYnBtbjpGbG93Tm9kZVwiKSkpIHtcbiAgICAgICAgaWYgKGlzKG5vZGUsIFwiYnBtbjpCb3VuZGFyeUV2ZW50XCIpKSB7XG4gICAgICAgICAgICBib3VuZGFyeUV2ZW50cy5wdXNoKG5vZGUuaWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2FuY2VsQWN0aXZpdHkgPT0gZmFsc2UpIG5vbkJsb2NraW5nQm91bmRhcnlFdmVudHMucHVzaChub2RlLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVMaXN0LnB1c2gobm9kZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsTm9kZU1hcC5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgfVxuXG4gICAgbGV0IHNvdXJjZXMgPSBbLi4ubm9kZUxpc3RdO1xuXG4gICAgZm9yIChsZXQgZmxvd0VkZ2Ugb2YgcHJvYy5mbG93RWxlbWVudHMuZmlsdGVyKGUgPT5cbiAgICAgICAgaXMoZSwgXCJicG1uOlNlcXVlbmNlRmxvd1wiKVxuICAgICkpIHtcbiAgICAgICAgaWYgKHNvdXJjZXMuaW5kZXhPZihmbG93RWRnZS50YXJnZXRSZWYuaWQpID4gLTEpIHtcbiAgICAgICAgICAgIHNvdXJjZXMuc3BsaWNlKHNvdXJjZXMuaW5kZXhPZihmbG93RWRnZS50YXJnZXRSZWYuaWQpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlZGdlTGlzdC5wdXNoKGZsb3dFZGdlLmlkKTtcbiAgICB9XG5cbiAgICAvLyBMZXQgdXMgcmVtb3ZlIGFsbCBzb3VyY2UgZWxlbWVudHMgZnJvbSB0aGUgbm9kZSBsaXN0XG4gICAgbm9kZUxpc3QgPSBub2RlTGlzdC5maWx0ZXIoKG5vZGU6IHN0cmluZykgPT4gc291cmNlcy5pbmRleE9mKG5vZGUpIDwgMCk7XG5cbiAgICBpZiAobm9uQmxvY2tpbmdCb3VuZGFyeUV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBkZnMgPSAoc291cmNlczogc3RyaW5nW10pID0+IHtcbiAgICAgICAgICAgIGxldCBvcGVuID0gWy4uLnNvdXJjZXNdO1xuICAgICAgICAgICAgbGV0IG5vZGVMaXN0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgICAgICBsZXQgZWRnZUxpc3Q6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChvcGVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycklkID0gb3Blbi5wb3AoKTtcbiAgICAgICAgICAgICAgICBsZXQgY3VyciA9IGdsb2JhbE5vZGVNYXAuZ2V0KGN1cnJJZCk7XG4gICAgICAgICAgICAgICAgbm9kZUxpc3QucHVzaChjdXJySWQpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyLm91dGdvaW5nICYmIGN1cnIub3V0Z29pbmcubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3VjY0VkZ2Ugb2YgY3Vyci5vdXRnb2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1Y2MgPSBzdWNjRWRnZS50YXJnZXRSZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlTGlzdC5wdXNoKHN1Y2NFZGdlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVuLmluZGV4T2Yoc3VjYy5pZCkgPCAwICYmIG5vZGVMaXN0LmluZGV4T2Yoc3VjYy5pZCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4ucHVzaChzdWNjLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtub2RlTGlzdCwgZWRnZUxpc3RdO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgW21haW5QYXRoTm9kZUxpc3QsIG1haW5QYXRoRWRnZUxpc3RdID0gZGZzKHNvdXJjZXMpO1xuICAgICAgICBsZXQgbG9jYWxCb3VuZGFyeSA9IFtdO1xuICAgICAgICBib3VuZGFyeUV2ZW50cy5mb3JFYWNoKGV2dElkID0+IHtcbiAgICAgICAgICAgIGlmIChub25CbG9ja2luZ0JvdW5kYXJ5RXZlbnRzLmluZGV4T2YoZXZ0SWQpIDwgMClcbiAgICAgICAgICAgICAgICBsb2NhbEJvdW5kYXJ5LnB1c2goZXZ0SWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxvY2FsQm91bmRhcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IFtib3VuZGFyeU5vZGVQYXRoLCBib3VuZGFyeUVkZ2VQYXRoXSA9IGRmcyhsb2NhbEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIGJvdW5kYXJ5Tm9kZVBhdGggPSBib3VuZGFyeU5vZGVQYXRoLmZpbHRlcihcbiAgICAgICAgICAgICAgICAobm9kZTogc3RyaW5nKSA9PiBsb2NhbEJvdW5kYXJ5LmluZGV4T2Yobm9kZSkgPCAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFpblBhdGhOb2RlTGlzdCA9IG1haW5QYXRoTm9kZUxpc3QuY29uY2F0KGJvdW5kYXJ5Tm9kZVBhdGgpO1xuICAgICAgICAgICAgbWFpblBhdGhFZGdlTGlzdCA9IG1haW5QYXRoRWRnZUxpc3QuY29uY2F0KGJvdW5kYXJ5RWRnZVBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGV0IHVzIHJlbW92ZSBhbGwgc291cmNlIGVsZW1lbnRzIGZyb20gdGhlIG5vZGUgbGlzdFxuICAgICAgICBtYWluUGF0aE5vZGVMaXN0ID0gbWFpblBhdGhOb2RlTGlzdC5maWx0ZXIoKG5vZGU6IHN0cmluZykgPT4gc291cmNlcy5pbmRleE9mKG5vZGUpIDwgMCk7XG5cbiAgICAgICAgY29udHJvbEZsb3dJbmZvID0gbmV3IENvbnRyb2xGbG93SW5mbyhcbiAgICAgICAgICAgIHByb2MsXG4gICAgICAgICAgICBtYWluUGF0aE5vZGVMaXN0LFxuICAgICAgICAgICAgbWFpblBhdGhFZGdlTGlzdCxcbiAgICAgICAgICAgIHNvdXJjZXMsXG4gICAgICAgICAgICBib3VuZGFyeUV2ZW50c1xuICAgICAgICApO1xuICAgICAgICBnbG9iYWxDb250cm9sRmxvd0luZm8ucHVzaChjb250cm9sRmxvd0luZm8pO1xuICAgICAgICBmb3IgKGxldCBldmVudElkIG9mIG5vbkJsb2NraW5nQm91bmRhcnlFdmVudHMpIHtcbiAgICAgICAgICAgIGxldCBldmVudCA9IGdsb2JhbE5vZGVNYXAuZ2V0KGV2ZW50SWQpO1xuICAgICAgICAgICAgaWYgKCFtYWluUGF0aE5vZGVMaXN0LmZpbmQoKGU6IHN0cmluZykgPT4gZXZlbnQuYXR0YWNoZWRUb1JlZi5pZCA9PT0gZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRVJST1I6IEZvdW5kIG5vbi1pbnRlcnJ1cHRpbmcgZXZlbnQgd2hpY2ggaXMgbm90IGF0dGFjaGVkIHRvIGEgc3VicHJvY2VzcyBpbiB0aGUgbWFpbiBwcm9jZXNzIHBhdGhcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBbbG9jYWxOb2RlTGlzdCwgbG9jYWxFZGdlTGlzdF0gPSBkZnMoW2V2ZW50SWRdKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBtYWluUGF0aE5vZGVMaXN0LmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgKG5vZGVJZDogc3RyaW5nKSA9PiBsb2NhbE5vZGVMaXN0LmluZGV4T2Yobm9kZUlkKSA+PSAwXG4gICAgICAgICAgICAgICAgKS5sZW5ndGggPiAwXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkVSUk9SOiBOb24taW50ZXJydXB0aW5nIGV2ZW50IG91dGdvaW5nIHBhdGggaXMgbm90IHN5bmNocm9uaXplZCBhbmQgbWVyZ2VzIHdpdGggbWFpbiBwcm9jZXNzIHBhdGhcIlxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIExldCB1cyByZW1vdmUgYWxsIHNvdXJjZSBlbGVtZW50cyBmcm9tIHRoZSBub2RlIGxpc3RcbiAgICAgICAgICAgIGxvY2FsTm9kZUxpc3QgPSBsb2NhbE5vZGVMaXN0LmZpbHRlcigobm9kZTogc3RyaW5nKSA9PiBzb3VyY2VzLmluZGV4T2Yobm9kZSkgPCAwKTtcblxuICAgICAgICAgICAgbGV0IGNoaWxkQ29udHJvbEZsb3dJbmZvID0gbmV3IENvbnRyb2xGbG93SW5mbyhcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBsb2NhbE5vZGVMaXN0LFxuICAgICAgICAgICAgICAgIGxvY2FsRWRnZUxpc3QsXG4gICAgICAgICAgICAgICAgW2V2ZW50SWRdLFxuICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY2hpbGRDb250cm9sRmxvd0luZm8ucGFyZW50ID0gcHJvYztcbiAgICAgICAgICAgIGdsb2JhbENvbnRyb2xGbG93SW5mby5wdXNoKGNoaWxkQ29udHJvbEZsb3dJbmZvKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xGbG93SW5mbyA9IG5ldyBDb250cm9sRmxvd0luZm8oXG4gICAgICAgICAgICBwcm9jLFxuICAgICAgICAgICAgbm9kZUxpc3QsXG4gICAgICAgICAgICBlZGdlTGlzdCxcbiAgICAgICAgICAgIHNvdXJjZXMsXG4gICAgICAgICAgICBib3VuZGFyeUV2ZW50c1xuICAgICAgICApO1xuICAgICAgICBnbG9iYWxDb250cm9sRmxvd0luZm8ucHVzaChjb250cm9sRmxvd0luZm8pO1xuICAgIH1cblxuICAgIGZvciAobGV0IHN1YnByb2Nlc3Mgb2YgcHJvYy5mbG93RWxlbWVudHMuZmlsdGVyKGUgPT4gaXMoZSwgXCJicG1uOlN1YlByb2Nlc3NcIikpKSB7XG4gICAgICAgIGxldCBzdWJwcm9jZXNzQ29udHJvbEZsb3dJbmZvID0gY29sbGVjdENvbnRyb2xGbG93SW5mbyhzdWJwcm9jZXNzLCBnbG9iYWxOb2RlTWFwLCBnbG9iYWxDb250cm9sRmxvd0luZm8pO1xuICAgICAgICBzdWJwcm9jZXNzQ29udHJvbEZsb3dJbmZvLnBhcmVudCA9IHByb2M7XG5cbiAgICAgICAgaWYgKCEoc3VicHJvY2Vzcy5sb29wQ2hhcmFjdGVyaXN0aWNzICYmIHN1YnByb2Nlc3MubG9vcENoYXJhY3RlcmlzdGljcy4kdHlwZSA9PT0gXCJicG1uOk11bHRpSW5zdGFuY2VMb29wQ2hhcmFjdGVyaXN0aWNzXCIpKSB7XG4gICAgICAgICAgICAvLyBTdWJwcm9jZXNzIGlzIGVtYmVkZGVkIC4uLiB0aGVuIGNvcHkgYWxsIG5vZGVzIGFuZCBlZGdlcyB0byB0aGUgcGFyZW50IHByb2Nlc3NcbiAgICAgICAgICAgIHN1YnByb2Nlc3NDb250cm9sRmxvd0luZm8uaXNFbWJlZGRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdCA9IGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5jb25jYXQoc3VicHJvY2Vzc0NvbnRyb2xGbG93SW5mby5ub2RlTGlzdCk7XG4gICAgICAgICAgICBjb250cm9sRmxvd0luZm8uZWRnZUxpc3QgPSBjb250cm9sRmxvd0luZm8uZWRnZUxpc3QuY29uY2F0KHN1YnByb2Nlc3NDb250cm9sRmxvd0luZm8uZWRnZUxpc3QpO1xuICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzID0gY29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzLmNvbmNhdChzdWJwcm9jZXNzQ29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvYy5kb2N1bWVudGF0aW9uKSB7XG4gICAgICAgIGNvbnRyb2xGbG93SW5mby5nbG9iYWxQYXJhbWV0ZXJzID0gcHJvYy5kb2N1bWVudGF0aW9uWzBdLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sRmxvd0luZm87XG59O1xuXG5sZXQgcmVzdHJpY3RSZWxhdGlvbjogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXAoKTtcblxuXG5cbmxldCBleHRyYWN0UGFyYW1ldGVycyA9IChjYWQsIG5vZGVJZCwgY29udHJvbEZsb3dJbmZvKSA9PiB7XG4gICAgICAgIC8vIEV4dHJhY3RpbmcgUm9sZXMgZnJvbSBVc2VyVGFza3MgZnVuY3Rpb25Cb2R5XG5cbiAgICBsZXQgYXJyID0gY2FkLnNwbGl0KCdAJyk7XG4gICAgaWYoYXJyLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIGlmKGNvbnRyb2xGbG93SW5mbyAhPSBudWxsKVxuICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLnRhc2tSb2xlTWFwLnNldChub2RlSWQsIGFyclsxXS50cmltKCkpO1xuICAgICAgICBpZihhcnJbMl0ubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIGNhZCA9IGFyclsyXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0aW5nIEluZm9ybWF0aW9uIG9mIE9yYWNsZSBmcm9tIFNlcnZpY2UgVGFza3MgKGlmIGFwbGljYWJsZSlcbiAgICBsZXQgb3JhY2xlX0RhdGEgPSBcIlwiO1xuICAgIGZvciAobGV0IGogPSAwLCBmaXJzdCA9IGZhbHNlOyBqIDwgY2FkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChjYWQuY2hhckF0KGopID09PSBcIihcIikge1xuICAgICAgICAgICAgaWYgKCFmaXJzdCkgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FkID0gY2FkLnN1YnN0cihqKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FkLmNoYXJBdChqKSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgIG9yYWNsZV9EYXRhID0gXCJcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9yYWNsZV9EYXRhICs9IGNhZC5jaGFyQXQoaik7XG4gICAgfVxuXG4gICAgLy8gUHJvY2Vzc2luZyBJbmZvcm1hdGlvbiBvZiBmdW5jdGlvbiBwYXJhbWV0ZXJzIChib3RoIHNlcnZpY2UgYW5kIHVzZXIgdGFza3MpXG4gICAgY2FkID0gY2FkXG4gICAgICAgIC5yZXBsYWNlKFwiKFwiLCBcIiBcIilcbiAgICAgICAgLnJlcGxhY2UoXCIpXCIsIFwiIFwiKVxuICAgICAgICAudHJpbSgpO1xuICAgIGNhZCA9IGNhZFxuICAgICAgICAucmVwbGFjZShcIihcIiwgXCIgXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiKVwiLCBcIiBcIilcbiAgICAgICAgLnRyaW0oKTtcblxuICAgIGxldCBmaXJzdFNwbGl0ID0gY2FkLnNwbGl0KFwiOlwiKTtcbiAgICBpZiAoZmlyc3RTcGxpdC5sZW5ndGggPiAyKSB7XG4gICAgICAgIGxldCBhdXggPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBmaXJzdFNwbGl0Lmxlbmd0aDsgaSsrKSBhdXggKz0gZmlyc3RTcGxpdFtpXTtcbiAgICAgICAgZmlyc3RTcGxpdCA9IFtmaXJzdFNwbGl0WzBdLCBhdXhdO1xuICAgIH1cbiAgICBsZXQgc2Vjb25kU3BsaXQgPSBmaXJzdFNwbGl0W2ZpcnN0U3BsaXQubGVuZ3RoIC0gMV0udHJpbSgpLnNwbGl0KFwiLT5cIik7XG4gICAgbGV0IHJlc01hcDogTWFwPHN0cmluZywgQXJyYXk8c3RyaW5nPj4gPSBuZXcgTWFwKCk7XG5cbiAgICBsZXQgaW5wdXRPdXRwdXQgPSBbZmlyc3RTcGxpdFswXS50cmltKCksIHNlY29uZFNwbGl0WzBdLnRyaW0oKV07XG4gICAgbGV0IHBhcmFtZXRlclR5cGUgPSBbXCJpbnB1dFwiLCBcIm91dHB1dFwiXTtcbiAgICByZXNNYXAuc2V0KFwiYm9keVwiLCBbc2Vjb25kU3BsaXRbc2Vjb25kU3BsaXQubGVuZ3RoIC0gMV0udHJpbSgpXSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0T3V0cHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0ZW1wID0gaW5wdXRPdXRwdXRbaV0uc3BsaXQoXCIsXCIpO1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIHRlbXAuZm9yRWFjaChzdWJDYWQgPT4ge1xuICAgICAgICAgICAgbGV0IGF1eCA9IHN1YkNhZC50cmltKCkuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgaWYgKGF1eFswXS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGF1eFswXS50cmltKCkpO1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGF1eFthdXgubGVuZ3RoIC0gMV0udHJpbSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlc01hcC5zZXQocGFyYW1ldGVyVHlwZVtpXSwgcmVzKTtcbiAgICB9XG4gICAgLy8gVXBkYXRpbmcgSW5mb3JtYXRpb24gb2YgT3JhY2xlIGluIGNvbnRyb2xGbG93SW5mb1xuICAgIGlmIChjb250cm9sRmxvd0luZm8gIT0gbnVsbCkge1xuICAgICAgICBsZXQgaW5QYXJhbWV0ZXJzOiBBcnJheTxQYXJhbWV0ZXJJbmZvPiA9IFtdO1xuICAgICAgICBsZXQgb3V0UGFyYW1ldGVyczogQXJyYXk8UGFyYW1ldGVySW5mbz4gPSBbXTtcbiAgICAgICAgbGV0IHRvSXRlcmF0ZSA9IHJlc01hcC5nZXQoJ2lucHV0Jyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9JdGVyYXRlLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgaW5QYXJhbWV0ZXJzLnB1c2gobmV3IFBhcmFtZXRlckluZm8odG9JdGVyYXRlW2ldLCB0b0l0ZXJhdGVbaSArIDFdKSk7XG4gICAgICAgIHRvSXRlcmF0ZSA9IHJlc01hcC5nZXQoJ291dHB1dCcpO1xuICAgICAgICBsZXQgcGFyYW1ldGVyczogTWFwPHN0cmluZywgQXJyYXk8UGFyYW1ldGVySW5mbz4+ID0gbmV3IE1hcCgpO1xuICAgICAgICBwYXJhbWV0ZXJzLnNldCgnaW5wdXQnLCBpblBhcmFtZXRlcnMpO1xuICAgICAgICBwYXJhbWV0ZXJzLnNldCgnb3V0cHV0Jywgb3V0UGFyYW1ldGVycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9JdGVyYXRlLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgb3V0UGFyYW1ldGVycy5wdXNoKG5ldyBQYXJhbWV0ZXJJbmZvKHRvSXRlcmF0ZVtpXSwgdG9JdGVyYXRlW2kgKyAxXSkpO1xuICAgICAgICBpZiAob3JhY2xlX0RhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3JhY2xlX0RhdGEgPSBvcmFjbGVfRGF0YS50cmltKCkucmVwbGFjZShcIiBcIiwgXCJfXCIpO1xuICAgICAgICAgICAgb3JhY2xlX0RhdGEgPSBvcmFjbGVfRGF0YVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiKFwiLCBcIiBcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcIikuXCIsIFwiIFwiKVxuICAgICAgICAgICAgICAgIC50cmltKCk7XG4gICAgICAgICAgICBsZXQgc3BsaXRSZXN1bHQgPSBvcmFjbGVfRGF0YS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICBpZiAoIWNvbnRyb2xGbG93SW5mby5vcmFjbGVJbmZvLmhhcyhzcGxpdFJlc3VsdFswXSkpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ub3JhY2xlSW5mby5zZXQoXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0UmVzdWx0WzBdLFxuICAgICAgICAgICAgICAgICAgICBuZXcgT3JhY2xlSW5mbyhzcGxpdFJlc3VsdFswXSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm9yYWNsZVRhc2tNYXAuc2V0KG5vZGVJZCwgc3BsaXRSZXN1bHRbMF0pO1xuICAgICAgICAgICAgbGV0IGxvY2FsT3JhY2xlID0gY29udHJvbEZsb3dJbmZvLm9yYWNsZUluZm8uZ2V0KHNwbGl0UmVzdWx0WzBdKTtcbiAgICAgICAgICAgIGxvY2FsT3JhY2xlLmFkZHJlc3MgPSBzcGxpdFJlc3VsdFsxXTtcbiAgICAgICAgICAgIGxvY2FsT3JhY2xlLmZ1bmN0aW9uTmFtZSA9IHNwbGl0UmVzdWx0WzJdO1xuICAgICAgICAgICAgbG9jYWxPcmFjbGUuZnVuY3Rpb25QYXJhbWV0ZXJzID0gcGFyYW1ldGVycy5nZXQoJ2lucHV0Jyk7XG4gICAgICAgIH0gZWxzZSBjb250cm9sRmxvd0luZm8ubG9jYWxQYXJhbWV0ZXJzLnNldChub2RlSWQsIHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzTWFwO1xufTtcblxubGV0IGdldE5vZGVOYW1lID0gKG5vZGU6IGFueSkgPT5cbiAgICBub2RlLm5hbWUgPyBub2RlLm5hbWUucmVwbGFjZSgvXFxzKy9nLCBcIl9cIikgOiBub2RlLmlkO1xuXG5sZXQgcGFyc2VNb2RlbCA9IChtb2RlbEluZm86IE1vZGVsSW5mbykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHBhcnNlQnBtbihtb2RlbEluZm8uYnBtbilcbiAgICAgICAgICAgIC50aGVuKChkZWZpbml0aW9uczogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ3BhcnNlZCBtb2RlbCcsIGRlZmluaXRpb25zKVxuICAgICAgICAgICAgICAgIG1vZGVsSW5mby5zb2xpZGl0eSA9IFwicHJhZ21hIHNvbGlkaXR5IF4wLjUuMDtcXG5cIjtcbiAgICAgICAgICAgICAgICBtb2RlbEluZm8uY29udHJvbEZsb3dJbmZvTWFwID0gbmV3IE1hcCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrc1xuICAgICAgICAgICAgICAgIGlmICghZGVmaW5pdGlvbnMuZGlhZ3JhbXMgfHwgZGVmaW5pdGlvbnMuZGlhZ3JhbXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBObyBkaWFncmFtIGZvdW5kIGluIEJQTU4gZmlsZVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgcHJvYyA9IGRlZmluaXRpb25zLmRpYWdyYW1zWzBdLnBsYW5lLmJwbW5FbGVtZW50O1xuICAgICAgICAgICAgICAgIG1vZGVsSW5mby5uYW1lID0gcHJvYy5uYW1lID8gcHJvYy5uYW1lLnJlcGxhY2UoL1xccysvZywgXCJfXCIpIDogcHJvYy5pZDtcbiAgICAgICAgICAgICAgICBtb2RlbEluZm8uaWQgPSBwcm9jLmlkO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jLiR0eXBlICE9PSBcImJwbW46UHJvY2Vzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jLiR0eXBlID09PSBcImJwbW46Q29sbGFib3JhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmluaXRpb25zLnJvb3RFbGVtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbnMucm9vdEVsZW1lbnRzW2ldLiR0eXBlID09PSBcImJwbW46UHJvY2Vzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2MgPSBkZWZpbml0aW9ucy5yb290RWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsSW5mby5uYW1lID0gcHJvYy5uYW1lID8gcHJvYy5uYW1lLnJlcGxhY2UoL1xccysvZywgXCJfXCIpIDogcHJvYy5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxJbmZvLmlkID0gcHJvYy5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IE5vIHJvb3QgcHJvY2VzcyBtb2RlbCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEJQTU4gdG8gU29saWRpdHkgcGFyc2luZ1xuXG4gICAgICAgICAgICAgICAgbGV0IGdsb2JhbE5vZGVNYXA6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbE5vZGVJbmRleE1hcDogTWFwPHN0cmluZywgbnVtYmVyPiA9IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRWRnZUluZGV4TWFwOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxDb250cm9sRmxvd0luZm86IEFycmF5PENvbnRyb2xGbG93SW5mbz4gPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAgICAgZ2xvYmFsTm9kZU1hcC5zZXQocHJvYy5pZCwgcHJvYyk7XG4gICAgICAgICAgICAgICAgbGV0IG1haW5Db250cm9sRmxvd0luZm8gPSBjb2xsZWN0Q29udHJvbEZsb3dJbmZvKHByb2MsIGdsb2JhbE5vZGVNYXAsIGdsb2JhbENvbnRyb2xGbG93SW5mbyk7XG4gICAgICAgICAgICAgICAgbGV0IGdsb2JhbENvbnRyb2xGbG93SW5mb01hcDogTWFwPHN0cmluZywgQ29udHJvbEZsb3dJbmZvPiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBnbG9iYWxDb250cm9sRmxvd0luZm8uZm9yRWFjaChjb250cm9sRmxvd0luZm8gPT5cbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsQ29udHJvbEZsb3dJbmZvTWFwLnNldChjb250cm9sRmxvd0luZm8uc2VsZi5pZCwgY29udHJvbEZsb3dJbmZvKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBFdmVudCBzdWItcHJvY2Vzc2VzIGFwcGVhciBpbiB0aGUgc291cmNlIGxpc3QsIGFuZCBub3QgaW4gdGhlIG5vZGVMaXN0XG4gICAgICAgICAgICAgICAgLy8gSW4gYWRkaXRpb24sIGFsbCB0aGUgZWxlbWVudHMgb2YgYSBub24gaW50ZXJydXB0aW5nIHN1YnByb2Nlc3MgZXZlbnQgYXBwZWFycyBlbWJlZGRlZCBvbiBpdHMgcGFyZW50IHByb2Nlc3NcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb250cm9sRmxvd0luZm8gb2YgZ2xvYmFsQ29udHJvbEZsb3dJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleGVzVG9SZW1vdmUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLnNvdXJjZXMuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCkudHJpZ2dlcmVkQnlFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVtb3ZlLnB1c2goY29udHJvbEZsb3dJbmZvLnNvdXJjZXMuaW5kZXhPZihub2RlSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZUluZm8gPSBnbG9iYWxDb250cm9sRmxvd0luZm9NYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFnbG9iYWxOb2RlTWFwLmdldChub2RlSW5mby5zb3VyY2VzWzBdKS5pc0ludGVycnVwdGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZm8ubm9kZUxpc3QuZm9yRWFjaChjaGlsZElkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5pbmRleE9mKGNoaWxkSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlbW92ZS5zb3J0KChpbmQxLCBpbmQyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kMiAtIGluZDE7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVzVG9SZW1vdmUuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8uc291cmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzKGdsb2JhbE5vZGVNYXAuZ2V0KGNvbnRyb2xGbG93SW5mby5zZWxmLmlkKSwgXCJicG1uOlN1YlByb2Nlc3NcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5zZWxmLnRyaWdnZXJlZEJ5RXZlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbE5vZGVNYXAuZ2V0KGNvbnRyb2xGbG93SW5mby5zb3VyY2VzWzBdKS5pc0ludGVycnVwdGluZyA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmlzRW1iZWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBoYXNFeHRlcm5hbENhbGwgPSBub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpcyhub2RlLCBcImJwbW46U2VydmljZVRhc2tcIik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG1vZGVsSW5mby5nbG9iYWxOb2RlTWFwID0gZ2xvYmFsTm9kZU1hcDtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbnRyb2xGbG93SW5mbyBvZiBnbG9iYWxDb250cm9sRmxvd0luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250cm9sRmxvd0luZm8uaXNFbWJlZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG11bHRpaW5zdGFuY2VBY3Rpdml0aWVzID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEFjdGl2aXRpZXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25JbnRlcnJ1cHRpbmdFdmVudHMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaGluZ01lc3NhZ2VzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobm9kZUlkID0+IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaXMoZSwgXCJicG1uOlRhc2tcIikgfHwgaXMoZSwgXCJicG1uOlN1YlByb2Nlc3NcIikpICYmIGUubG9vcENoYXJhY3RlcmlzdGljcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5sb29wQ2hhcmFjdGVyaXN0aWNzLiR0eXBlID09PSBcImJwbW46TXVsdGlJbnN0YW5jZUxvb3BDaGFyYWN0ZXJpc3RpY3NcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm11bHRpaW5zdGFuY2VBY3Rpdml0aWVzLnNldChlLmlkLCBnZXROb2RlTmFtZShlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWluc3RhbmNlQWN0aXZpdGllcy5wdXNoKGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzKGUsIFwiYnBtbjpDYWxsQWN0aXZpdHlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5jYWxsQWN0aXZpdGllcy5zZXQoZS5pZCwgZ2V0Tm9kZU5hbWUoZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEFjdGl2aXRpZXMucHVzaChlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhlLCBcImJwbW46SW50ZXJtZWRpYXRlQ2F0Y2hFdmVudFwiKSAmJiBpcyhlLmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hpbmdNZXNzYWdlcy5wdXNoKGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpcyhlLCBcImJwbW46U3RhcnRFdmVudFwiKSAmJiBpcyhlLmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hpbmdNZXNzYWdlcy5wdXNoKGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBhbHNvIG5lY2Vzc2FyeSB0byBhZGQgYm91bmRhcnkgZXZlbnRzIG9mIGVtYmVkZGVkIHN1Yi1wcm9jZXNzZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLnNvdXJjZXMuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0LmV2ZW50RGVmaW5pdGlvbnMgJiYgc3RhcnQuZXZlbnREZWZpbml0aW9uc1swXSAmJiBpcyhzdGFydC5ldmVudERlZmluaXRpb25zWzBdLCBcImJwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvblwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuaW5kZXhPZihub2RlSWQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0Y2hpbmdNZXNzYWdlcy5pbmRleE9mKG5vZGVJZCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hpbmdNZXNzYWdlcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ib3VuZGFyeUV2ZW50cy5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm91dGdvaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBvdXRnb2luZyBvZiBub2RlLm91dGdvaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmVkZ2VMaXN0LnB1c2gob3V0Z29pbmcuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5jYW5jZWxBY3Rpdml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9uSW50ZXJydXB0aW5nRXZlbnRzLnNldChub2RlLmlkLCBnZXROb2RlTmFtZShub2RlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbkludGVycnVwdGluZ0V2ZW50cy5wdXNoKG5vZGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QucHVzaChub2RlSWQpOyAvLyBFYWdlciByZWluc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ldmVudERlZmluaXRpb25zWzBdICYmIGlzKG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSwgJ2JwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0Y2hpbmdNZXNzYWdlcy5pbmRleE9mKG5vZGVJZCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoaW5nTWVzc2FnZXMucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmV2ZW50RGVmaW5pdGlvbnMgJiYgaXMobm9kZS5ldmVudERlZmluaXRpb25zWzBdLCBcImJwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmluZGV4T2Yobm9kZUlkKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0Y2hpbmdNZXNzYWdlcy5pbmRleE9mKG5vZGVJZCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hpbmdNZXNzYWdlcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbE5vZGVNYXAuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOlN1YlByb2Nlc3NcIikgJiYgbm9kZS50cmlnZ2VyZWRCeUV2ZW50ICYmIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5pbmRleE9mKG5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHN0YXJ0IG9mIG5vZGUuZmxvd0VsZW1lbnRzLmZpbHRlcihlID0+IGlzKGUsIFwiYnBtbjpGbG93Tm9kZVwiKSAmJiBpcyhlLCBcImJwbW46U3RhcnRFdmVudFwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydC5pc0ludGVycnVwdGluZyA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBnbG9iYWxOb2RlTWFwLmdldChzdGFydC4kcGFyZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9uSW50ZXJydXB0aW5nRXZlbnRzLnNldChzdGFydC5pZCwgZ2V0Tm9kZU5hbWUocGFyZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uSW50ZXJydXB0aW5nRXZlbnRzLnB1c2goc3RhcnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5wdXNoKHN0YXJ0LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQuZXZlbnREZWZpbml0aW9uc1swXSAmJiBpcyhzdGFydC5ldmVudERlZmluaXRpb25zWzBdLCBcImJwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0Y2hpbmdNZXNzYWdlcy5pbmRleE9mKHN0YXJ0LmlkKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaGluZ01lc3NhZ2VzLnB1c2goc3RhcnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sRmxvd0luZm8uYm91bmRhcnlFdmVudHMuaW5kZXhPZihzdGFydC5pZCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzLnB1c2goc3RhcnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuaW5kZXhPZihzdGFydC4kcGFyZW50LmlkKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5wdXNoKHN0YXJ0LiRwYXJlbnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0LmV2ZW50RGVmaW5pdGlvbnNbMF0gJiYgaXMoc3RhcnQuZXZlbnREZWZpbml0aW9uc1swXSwgXCJicG1uOk1lc3NhZ2VFdmVudERlZmluaXRpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmluZGV4T2Yoc3RhcnQuaWQpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LnB1c2goc3RhcnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXRjaGluZ01lc3NhZ2VzLmluZGV4T2Yoc3RhcnQuaWQpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hpbmdNZXNzYWdlcy5wdXNoKHN0YXJ0LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydC5vdXRnb2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBvdXRnb2luZyBvZiBzdGFydC5vdXRnb2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmVkZ2VMaXN0LnB1c2gob3V0Z29pbmcuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0MTogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnQyOiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNFeHRlcm5hbENhbGwobm9kZUlkKSkgcGFydDEucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcGFydDIucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QgPSBwYXJ0MS5jb25jYXQocGFydDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGVJZDogc3RyaW5nLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVJbmRleE1hcC5zZXQobm9kZUlkLCBpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxOb2RlSW5kZXhNYXAuc2V0KG5vZGVJZCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVOYW1lTWFwLnNldChub2RlSWQsIGdldE5vZGVOYW1lKGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZG9jdW1lbnRhdGlvbiAmJiBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCAmJiBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgJ2JwbW46Q2FsbEFjdGl2aXR5JykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmV4dGVybmFsQnVuZGxlcy5zZXQobm9kZUlkLCBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGUuaWQsIGNvbnRyb2xGbG93SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmVkZ2VMaXN0LmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVkZ2VJZDogc3RyaW5nLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5lZGdlSW5kZXhNYXAuc2V0KGVkZ2VJZCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRWRnZUluZGV4TWFwLnNldChlZGdlSWQsIGluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5jYXRjaGluZ01lc3NhZ2VzID0gY2F0Y2hpbmdNZXNzYWdlcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udHJvbEZsb3cgUGVyc3BlY3RpdmU6IEdlbmVyYXRpb24gb2YgU21hcnQgQ29udHJhY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29kZUdlbmVyYXRpb25JbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMaXN0OiBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU1hcDogZ2xvYmFsTm9kZU1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaGluZ01lc3NhZ2VzOiBjb250cm9sRmxvd0luZm8uY2F0Y2hpbmdNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWluc3RhbmNlQWN0aXZpdGllczogbXVsdGlpbnN0YW5jZUFjdGl2aXRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEFjdGl2aXRpZXM6IGNhbGxBY3Rpdml0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbkludGVycnVwdGluZ0V2ZW50czogbm9uSW50ZXJydXB0aW5nRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yYWNsZUluZm86IGNvbnRyb2xGbG93SW5mby5vcmFjbGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yYWNsZVRhc2tNYXA6IGNvbnRyb2xGbG93SW5mby5vcmFjbGVUYXNrTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NJZDogKCkgPT4gY29udHJvbEZsb3dJbmZvLnNlbGYuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWU6IG5vZGVJZCA9PiBnZXROb2RlTmFtZShnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGU6IG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZXZlbnREZWZpbml0aW9ucyAmJiBub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYWQgPSBub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0uJHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FkLnN1YnN0cmluZyg1LCBjYWQubGVuZ3RoIC0gMTUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkRlZmF1bHRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEV2ZW50VHlwZXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRha2VuID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbE5vZGVNYXAuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmV2ZW50RGVmaW5pdGlvbnMgJiYgbm9kZS5ldmVudERlZmluaXRpb25zWzBdICYmICFpcyhub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpUZXJtaW5hdGVFdmVudERlZmluaXRpb25cIikgJiYgIWlzKG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSwgXCJicG1uOk1lc3NhZ2VFdmVudERlZmluaXRpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FkID0gbm9kZS5ldmVudERlZmluaXRpb25zWzBdLiR0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWtlbi5pbmRleE9mKGNhZC5zdWJzdHJpbmcoNSwgY2FkLmxlbmd0aCAtIDE1KSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWtlbi5wdXNoKGNhZC5zdWJzdHJpbmcoNSwgY2FkLmxlbmd0aCAtIDE1KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFrZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRNZXNzYWdlczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFrZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZXMgPSBjb250cm9sRmxvd0luZm8uYm91bmRhcnlFdmVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMoZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKSwgXCJicG1uOlN1YlByb2Nlc3NcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3ViUCA9IGdsb2JhbENvbnRyb2xGbG93SW5mb01hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5jb25jYXQoc3ViUC5ib3VuZGFyeUV2ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViUC5zb3VyY2VzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzKGdsb2JhbE5vZGVNYXAuZ2V0KGlkKSwgXCJicG1uOlN1YnByb2Nlc3NcIikgJiYgY2FuZGlkYXRlcy5pbmRleE9mKGlkKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5mb3JFYWNoKGV2dElkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldnQgPSBnbG9iYWxOb2RlTWFwLmdldChldnRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0LmV2ZW50RGVmaW5pdGlvbnMgJiYgZXZ0LmV2ZW50RGVmaW5pdGlvbnNbMF0gJiYgaXMoZXZ0LmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRha2VuLnB1c2goZXZ0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRha2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VGhyb3dpbmdNZXNzYWdlczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGlzKG5vZGUsIFwiYnBtbjpFbmRFdmVudFwiKSB8fCBpcyhub2RlLCBcImJwbW46SW50ZXJtZWRpYXRlVGhyb3dFdmVudFwiKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmV2ZW50RGVmaW5pdGlvbnMgJiYgbm9kZS5ldmVudERlZmluaXRpb25zWzBdICYmIGlzKG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSwgXCJicG1uOk1lc3NhZ2VFdmVudERlZmluaXRpb25cIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRUaHJvd2luZ0V2ZW50czogKHN1YnByb2NJZCwgZXZUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsTm9kZU1hcC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZXZlbnREZWZpbml0aW9ucyAmJiBub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FkID0gbm9kZS5ldmVudERlZmluaXRpb25zWzBdLiR0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWQuc3Vic3RyaW5nKDUsIGNhZC5sZW5ndGggLSAxNSkgPT09IGV2VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGlzKG5vZGUsIFwiYnBtbjpFbmRFdmVudFwiKSB8fCBpcyhub2RlLCBcImJwbW46SW50ZXJtZWRpYXRlVGhyb3dFdmVudFwiKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLiRwYXJlbnQuaWQgPT09IHN1YnByb2NJZCB8fCBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuaW5kZXhPZihub2RlLmlkKSA+PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q2F0Y2hpbmdFdmVudHM6IChzdWJwcm9jSWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxOb2RlTWFwLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ldmVudERlZmluaXRpb25zICYmIG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCBcImJwbW46U3RhcnRFdmVudFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZS4kcGFyZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC50cmlnZ2VyZWRCeUV2ZW50ICYmIHBhcmVudC4kcGFyZW50LmlkID09PSBzdWJwcm9jSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMudW5zaGlmdChub2RlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXBhcmVudC50cmlnZ2VyZWRCeUV2ZW50ICYmIChwYXJlbnQuaWQgPT09IHN1YnByb2NJZCB8fCBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuaW5kZXhPZihwYXJlbnQuaWQpID4gLTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhub2RlLCBcImJwbW46Qm91bmRhcnlFdmVudFwiKSB8fCBpcyhub2RlLCBcImJwbW46SW50ZXJtZWRpYXRlQ2F0Y2hFdmVudFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS4kcGFyZW50LmlkID09PSBzdWJwcm9jSWQgfHwgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmluZGV4T2Yobm9kZS4kcGFyZW50LmlkKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFRlcm1pbmF0ZUNhbmRpZGF0ZXM6IChzdWJwcm9jSWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbE5vZGVNYXAuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ldmVudERlZmluaXRpb25zICYmIG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOkJvdW5kYXJ5RXZlbnRcIikgJiYgbm9kZS5jYW5jZWxBY3Rpdml0eSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihnbG9iYWxDb250cm9sRmxvd0luZm9NYXAuaGFzKG5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsQyA9IGdsb2JhbENvbnRyb2xGbG93SW5mb01hcC5nZXQobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxDLm5vZGVMaXN0LmZvckVhY2goZWxlbUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbSA9IGdsb2JhbE5vZGVNYXAuZ2V0KGVsZW1JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWxlbS5ldmVudERlZmluaXRpb25zICYmIGlzKGVsZW0uZXZlbnREZWZpbml0aW9uc1swXSwgXCJicG1uOlRlcm1pbmF0ZUV2ZW50RGVmaW5pdGlvblwiKSAmJiBlbGVtLiRwYXJlbnQuaWQgPT09IG5vZGUuJHBhcmVudC5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKCdNaXNzaW5nIE5vbiBJbnRlcnJ1cHRpbmcgZXZlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UHJvY2Vzc0NhbmRpZGF0ZXNNYXNrRnJvbTogKGV2dElkLCBldnRUeXBlLCBldnRDb2RlLCBzb3VyY2VQcm9jZXNzZXMsIGFsbEV2ZW50cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxFdmVudHMuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhZCA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCkuZXZlbnREZWZpbml0aW9uc1swXS4kdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldnRUeXBlID09PSBjYWQuc3Vic3RyaW5nKDUsIGNhZC5sZW5ndGggLSAxNSkgJiYgZXZ0Q29kZSA9PT0gZ2V0Tm9kZU5hbWUoZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0LnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVByb2Nlc3Nlcy5mb3JFYWNoKHByb2NJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gZ2xvYmFsTm9kZU1hcC5nZXQocHJvY0lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcmV2aW91c1BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIWV2ZW50Rm91bmQgJiYgcmVzLmxlbmd0aCA9PSAwICYmIHBhcmVudC4kcGFyZW50ICYmIGNvbnRyb2xGbG93SW5mby5zZWxmLmlkICE9PSBwYXJlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBnbG9iYWxOb2RlTWFwLmdldChwYXJlbnQuJHBhcmVudC5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0LmZvckVhY2gobm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Rm91bmQgJiYgaXMobm9kZSwgXCJicG1uOkJvdW5kYXJ5RXZlbnRcIikgJiYgbm9kZS5hdHRhY2hlZFRvUmVmLmlkID09PSBwcmV2aW91c1BhcmVudC5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRGb3VuZCA9IG5vZGUuY2FuY2VsQWN0aXZpdHkgIT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRGb3VuZCkgcmVzID0gW25vZGVJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHJlcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Rm91bmQgJiYgaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikgJiYgbm9kZS4kcGFyZW50LnRyaWdnZXJlZEJ5RXZlbnQgJiYgbm9kZS4kcGFyZW50LiRwYXJlbnQuaWQgPT09IHBhcmVudC5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Rm91bmQgPSBub2RlLmlzSW50ZXJydXB0aW5nICE9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEZvdW5kKSByZXMgPSBbbm9kZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHJlcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5pbmRleE9mKGV2dElkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRhcnJheVtnbG9iYWxOb2RlSW5kZXhNYXAuZ2V0KHByb2NJZCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBcIjBiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IFwiMGJcIiA/IDAgOiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q2F0Y2hpbmdFdmVudHNGcm9tOiAocHJvY0lkLCBldnRUeXBlLCBldnRDb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzY2FsYXRpb24gYW5kIEVycm9yIGNhdGNoaW5nIGV2ZW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gaW50ZXJtZWRpYXRlIGV2ZW50cyBpbiBub3JtYWwgZmxvdyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IGdsb2JhbE5vZGVNYXAuZ2V0KHByb2NJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYW5kaWRhdGVzID0gY29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzLmNvbmNhdChjb250cm9sRmxvd0luZm8ubm9kZUxpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZXZlbnREZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYWQgPSBub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0uJHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBjYWQuc3Vic3RyaW5nKDUsIGNhZC5sZW5ndGggLSAxNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IGV2dFR5cGUgJiYgZXZ0Q29kZSA9PT0gZ2V0Tm9kZU5hbWUoZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKSkgJiYgZXZlbnRMaXN0LmluZGV4T2Yobm9kZUlkKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0LnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudC50cmlnZ2VyZWRCeUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudExpc3QuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Rm91bmQgJiYgaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikgJiYgbm9kZS4kcGFyZW50LnRyaWdnZXJlZEJ5RXZlbnQgJiYgbm9kZS4kcGFyZW50LiRwYXJlbnQuaWQgPT09IHBhcmVudC5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEZvdW5kID0gbm9kZS5pc0ludGVycnVwdGluZyAhPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Rm91bmQpIHJlcyA9IFtub2RlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHJlcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xGbG93SW5mby5zZWxmLmlkID09PSBwcm9jSWQgfHwgcmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnRyaWdnZXJlZEJ5RXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gZ2xvYmFsTm9kZU1hcC5nZXQocGFyZW50LiRwYXJlbnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzUGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFldmVudEZvdW5kICYmIHJlcy5sZW5ndGggPT0gMCAmJiBwYXJlbnQuJHBhcmVudCAmJiBjb250cm9sRmxvd0luZm8uc2VsZi5pZCAhPT0gcGFyZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gZ2xvYmFsTm9kZU1hcC5nZXQocGFyZW50LiRwYXJlbnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudEZvdW5kICYmIGlzKG5vZGUsIFwiYnBtbjpCb3VuZGFyeUV2ZW50XCIpICYmIG5vZGUuYXR0YWNoZWRUb1JlZi5pZCA9PT0gcHJldmlvdXNQYXJlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Rm91bmQgPSBub2RlLmNhbmNlbEFjdGl2aXR5ICE9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Rm91bmQpIHJlcyA9IFtub2RlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSByZXMucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudExpc3QuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudEZvdW5kICYmIGlzKG5vZGUsIFwiYnBtbjpTdGFydEV2ZW50XCIpICYmIG5vZGUuJHBhcmVudC50cmlnZ2VyZWRCeUV2ZW50ICYmIG5vZGUuJHBhcmVudC4kcGFyZW50LmlkID09PSBwYXJlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEZvdW5kID0gbm9kZS5pc0ludGVycnVwdGluZyAhPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRGb3VuZCkgcmVzID0gW25vZGVJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSByZXMucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFdvcmtJdGVtc0dyb3VwQnlQYXJhbWV0ZXJzOiAoaXNJbnB1dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZTJJZHM6IE1hcDxzdHJpbmcsIHN0cmluZ1tdPiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmZvckVhY2gobm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCAnYnBtbjpVc2VyVGFzaycpIHx8IGlzKG5vZGUsICdicG1uOlJlY2VpdmVUYXNrJykgfHwgY2F0Y2hpbmdNZXNzYWdlcy5pbmRleE9mKG5vZGVJZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJhbXMgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmRvY3VtZW50YXRpb24gJiYgbm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQgJiYgbm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQubGVuZ3RoID4gMCAmJiBleHRyYWN0UGFyYW1ldGVycyhub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCwgbm9kZUlkLCBudWxsKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbFBhcmFtcyA9IGlzSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGVJZCwgbnVsbCkuZ2V0KFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGVJZCwgbnVsbCkuZ2V0KFwib3V0cHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gbG9jYWxQYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGxvY2FsUGFyYW1zLmxlbmd0aDsgaSArPSAyKSBwYXJhbXMgKz0gbG9jYWxQYXJhbXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBnZXROb2RlTmFtZShnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpKSArIHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWUySWRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lMklkcy5zZXQobmFtZSwgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lMklkcy5nZXQobmFtZSkucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUySWRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29udHJhY3RzMkNhbGw6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IGNhbGxBY3Rpdml0aWVzLmNvbmNhdChtdWx0aWluc3RhbmNlQWN0aXZpdGllcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbkludGVycnVwdGluZ0V2ZW50cy5mb3JFYWNoKGV2dElkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQoZXZ0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikgPyBub2RlLiRwYXJlbnQuaWQgOiBldnRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29udHJhY3RzMkNhbGxGcm9tOiAoc3VicHJvY0lkLCBjYW5kaWRhdGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBbc3VicHJvY0lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250cm9sRmxvd0luZm8uY2FsbEFjdGl2aXRpZXMuaGFzKHN1YnByb2NJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZS4kcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLiRwYXJlbnQuaWQgPT09IHN1YnByb2NJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLiRwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbnRyYWN0czJDYWxsTWFza0Zyb206IChzdWJwcm9jSWQsIGNhbmRpZGF0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpdGFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUuJHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLiRwYXJlbnQuaWQgPT09IHN1YnByb2NJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRhcnJheVtnbG9iYWxOb2RlSW5kZXhNYXAuZ2V0KG5vZGVJZCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLiRwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gXCIwYlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gYml0YXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYml0YXJyYXlbaV0gPyBcIjFcIiA6IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBcIjBiXCIgPyAwIDogbmV3IEJpZ051bWJlcihyZXN1bHQpLnRvRml4ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbnRyYWN0czJDYWxsQXJyYXk6IChzdWJwcm9jSWQsIGNhbmRpZGF0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9ICdbdWludCgnICsgZ2xvYmFsTm9kZUluZGV4TWFwLmdldChjYW5kaWRhdGVzWzBdKSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9ICcsIHVpbnQoJyArIGdsb2JhbE5vZGVJbmRleE1hcC5nZXQoY2FuZGlkYXRlc1tpXSkgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMgKyAnXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRQb3NzaWJsZUtpbGxTdWJwcm9jZXNzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzLmZvckVhY2gobm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLiRwYXJlbnQudHJpZ2dlcmVkQnlFdmVudCAmJiBub2RlLiRwYXJlbnQuJHBhcmVudC5pZCAhPT0gY29udHJvbEZsb3dJbmZvLnNlbGYuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pc0ludGVycnVwdGluZyAhPSBmYWxzZSAmJiByZXMuaW5kZXhPZihub2RlLiRwYXJlbnQuJHBhcmVudC5pZCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChub2RlLiRwYXJlbnQuJHBhcmVudC5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuYXR0YWNoZWRUb1JlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhdHRhY2hlZFRvID0gbm9kZS5hdHRhY2hlZFRvUmVmLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNhbmNlbEFjdGl2aXR5ICE9IGZhbHNlICYmIHJlcy5pbmRleE9mKGF0dGFjaGVkVG8pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChhdHRhY2hlZFRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxOb2RlTWFwLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ldmVudERlZmluaXRpb25zICYmIG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCBcImJwbW46Qm91bmRhcnlFdmVudFwiKSAmJiBub2RlLmNhbmNlbEFjdGl2aXR5ID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZ2xvYmFsQ29udHJvbEZsb3dJbmZvTWFwLmhhcyhub2RlLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsQyA9IGdsb2JhbENvbnRyb2xGbG93SW5mb01hcC5nZXQobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEMubm9kZUxpc3QuZm9yRWFjaChlbGVtSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW0gPSBnbG9iYWxOb2RlTWFwLmdldChlbGVtSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWxlbS5ldmVudERlZmluaXRpb25zICYmIGlzKGVsZW0uZXZlbnREZWZpbml0aW9uc1swXSwgXCJicG1uOlRlcm1pbmF0ZUV2ZW50RGVmaW5pdGlvblwiKSAmJiBlbGVtLiRwYXJlbnQuaWQgPT09IG5vZGUuJHBhcmVudC5pZCAmJiBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuaW5kZXhPZihub2RlLiRwYXJlbnQuaWQpID49IDAgJiYgcmVzLmluZGV4T2Yobm9kZS4kcGFyZW50LmlkKSA8IDAgJiYgbm9kZS4kcGFyZW50LmlkICE9IGNvbnRyb2xGbG93SW5mby5zZWxmLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS4kcGFyZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ldmVudERlZmluaXRpb25zICYmIGlzKG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSwgXCJicG1uOlRlcm1pbmF0ZUV2ZW50RGVmaW5pdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXMuaW5kZXhPZihub2RlLiRwYXJlbnQuaWQpIDwgMCAmJiBub2RlLiRwYXJlbnQuaWQgIT0gY29udHJvbEZsb3dJbmZvLnNlbGYuaWQgJiYgIWlzKGdsb2JhbE5vZGVNYXAuZ2V0KGNvbnRyb2xGbG93SW5mby5zZWxmLmlkKSwgXCJicG1uOkJvdW5kYXJ5RXZlbnRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKCdJIGFtIGhlcmUgMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS4kcGFyZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvdW50RXh0ZXJuYWxUYXNrczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmZvckVhY2gobm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNFeHRlcm5hbENhbGwobm9kZUlkKSkgcmVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhcnRlZE1lc3NhZ2VzOiBwcm9jZXNzSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikgJiYgbm9kZS4kcGFyZW50LmlkID09PSBwcm9jZXNzSWQgJiYgbm9kZS5ldmVudERlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgaXMobm9kZS5ldmVudERlZmluaXRpb25zWzBdLCBcImJwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvblwiKSAmJiBnbG9iYWxOb2RlTWFwLmdldChub2RlLiRwYXJlbnQuaWQpLnRyaWdnZXJlZEJ5RXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRQYXJlbnQ6IG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHJpZXZlcyB0aGUgaWQgb2YgdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCBcImJwbW46U3RhcnRFdmVudFwiKSAmJiBub2RlLiRwYXJlbnQgJiYgZ2xvYmFsTm9kZU1hcC5nZXQobm9kZS4kcGFyZW50LmlkKS50cmlnZ2VyZWRCeUV2ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGUuJHBhcmVudC5pZCkuJHBhcmVudC5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKG5vZGUsIFwiYnBtbjpCb3VuZGFyeUV2ZW50XCIpICYmIG5vZGUuY2FuY2VsQWN0aXZpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5hdHRhY2hlZFRvUmVmLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS4kcGFyZW50ID8gbm9kZS4kcGFyZW50LmlkIDogbm9kZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29udHJhY3ROYW1lOiBub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZXMgdGhlIGNvbnRyYWN0IG5hbWUgcmVsYXRlZCB0byB0aGUgbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikgJiYgbm9kZS4kcGFyZW50ICYmIGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGUuJHBhcmVudC5pZCkudHJpZ2dlcmVkQnlFdmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLiRwYXJlbnQuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCBcImJwbW46Qm91bmRhcnlFdmVudFwiKSkgcmV0dXJuIG5vZGUuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sRmxvd0luZm8uc2VsZi5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFsbENoaWxkcmVuOiAoc3VicHJvY0lkLCBkaXJlY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRha2VuID0gZGlyZWN0ID8gW10gOiBbc3VicHJvY0lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKG5vZGVJZCA9PiBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKGUsIFwiYnBtbjpTdWJQcm9jZXNzXCIpIHx8IGNhbGxBY3Rpdml0aWVzLmluZGV4T2YoZS5pZCkgPj0gMCB8fCAobm9uSW50ZXJydXB0aW5nRXZlbnRzLmluZGV4T2YoZS5pZCkgPj0gMCAmJiAhaXMoZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChkaXJlY3QgJiYgc3VicHJvY0lkICE9PSBlLmlkICYmIGUuJHBhcmVudC5pZCA9PT0gc3VicHJvY0lkKSB8fCAhZGlyZWN0KSAmJiB0YWtlbi5pbmRleE9mKGUuaWQpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRha2VuLnB1c2goZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRha2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGFydGluZ0NvbnRyYWN0RXZlbnQ6IChldmVudElkLCBwcm9jZXNzSWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2dCA9IGdsb2JhbE5vZGVNYXAuZ2V0KGV2ZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMoZXZ0LCBcImJwbW46U3RhcnRFdmVudFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbE5vZGVNYXAuZ2V0KGV2dC4kcGFyZW50LmlkKS50cmlnZ2VyZWRCeUV2ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldnQuJHBhcmVudC5pZCAhPT0gcHJvY2Vzc0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKGV2dC5ldmVudERlZmluaXRpb25zWzBdLCBcImJwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvblwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhldnQsIFwiYnBtbjpCb3VuZGFyeUV2ZW50XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRJZCAhPT0gcHJvY2Vzc0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzKGV2dCwgXCJicG1uOkludGVybWVkaWF0ZUNhdGNoRXZlbnRcIikgJiYgaXMoZXZ0LmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSW50ZXJydXB0aW5nOiBldmVudElkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ1ZSBpZiBhbiBldmVudCBpcyBpbnRlcnJ1cHRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChldmVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZXZlbnREZWZpbml0aW9ucyAmJiBpcyhub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpFcnJvckV2ZW50RGVmaW5pdGlvblwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikgJiYgbm9kZS4kcGFyZW50ICYmIGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGUuJHBhcmVudC5pZCkudHJpZ2dlcmVkQnlFdmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmlzSW50ZXJydXB0aW5nICE9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOkJvdW5kYXJ5RXZlbnRcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5jYW5jZWxBY3Rpdml0eSAhPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNFbWJlZGRlZFN1YnByb2Nlc3M6IHN1YnByb2Nlc3NJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxDb250cm9sRmxvd0luZm9NYXAuZ2V0KHN1YnByb2Nlc3NJZCkuaXNFbWJlZGRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQm91bmRhcnlFdmVudDogZXZ0SWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzLmluZGV4T2YoZXZ0SWQpID49IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVNYXJraW5nOiBub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pbmNvbWluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluY29taW5nIG9mIG5vZGUuaW5jb21pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0YXJyYXlbY29udHJvbEZsb3dJbmZvLmVkZ2VJbmRleE1hcC5nZXQoaW5jb21pbmcuaWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgYml0YXJyYXlbMF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gXCIwYlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gYml0YXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYml0YXJyYXlbaV0gPyBcIjFcIiA6IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihyZXN1bHQpLnRvRml4ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNYXJraW5nOiBub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gXCIwYlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5vdXRnb2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG91dGdvaW5nIG9mIG5vZGUub3V0Z29pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRhcnJheVtjb250cm9sRmxvd0luZm8uZWRnZUluZGV4TWFwLmdldChvdXRnb2luZy5pZCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSByZXN1bHQgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJpdGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJpdGFycmF5W2ldID8gXCIxXCIgOiBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIocmVzdWx0KS50b0ZpeGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJwcm9jZXNzTm9kZU1hcmtpbmc6IHN1YnByb2Nlc3NJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxOb2RlTWFwLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS4kcGFyZW50ICYmIG5vZGUuJHBhcmVudC5pZCA9PT0gc3VicHJvY2Vzc0lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKG5vZGUsIFwiYnBtbjpUYXNrXCIpIHx8IGlzKG5vZGUsICdicG1uOlN1YlByb2Nlc3MnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0YXJyYXlbZ2xvYmFsTm9kZUluZGV4TWFwLmdldChub2RlLmlkKV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFnbG9iYWxOb2RlTWFwLmdldChzdWJwcm9jZXNzSWQpLnRyaWdnZXJlZEJ5RXZlbnQgJiYgbm9kZS5ldmVudERlZmluaXRpb25zICYmIG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyhub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRhcnJheVtnbG9iYWxOb2RlSW5kZXhNYXAuZ2V0KG5vZGUuaWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gYml0YXJyYXkubGVuZ3RoID4gMCA/IFwiMGJcIiA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicHJvY2Vzc05vZGVGdWxsTWFya2luZzogc3VicHJvY0lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gW3N1YnByb2NJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKG5vZGUsIFwiYnBtbjpTdWJQcm9jZXNzXCIpIHx8IGNhbGxBY3Rpdml0aWVzLmluZGV4T2Yobm9kZS5pZCkgPj0gMCB8fCAobm9uSW50ZXJydXB0aW5nRXZlbnRzLmluZGV4T2Yobm9kZS5pZCkgPj0gMCAmJiAhaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUuJHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS4kcGFyZW50LmlkID09PSBzdWJwcm9jSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aWluc3RhbmNlQWN0aXZpdGllcy5pbmRleE9mKG5vZGVJZCkgPj0gMCB8fCBjYWxsQWN0aXZpdGllcy5pbmRleE9mKG5vZGUuaWQpID49IDAgfHwgbm9uSW50ZXJydXB0aW5nRXZlbnRzLmluZGV4T2Yobm9kZS5pZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2dsb2JhbE5vZGVJbmRleE1hcC5nZXQobm9kZUlkKV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRyZW4uaW5kZXhPZihub2RlSWQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLiRwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiMGJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbE5vZGVJbmRleE1hcC5nZXQoc3VicHJvY0lkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2dsb2JhbE5vZGVJbmRleE1hcC5nZXQoc3VicHJvY0lkKV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobm9kZUlkID0+IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS4kcGFyZW50ICYmIGNoaWxkcmVuLmluZGV4T2Yobm9kZS4kcGFyZW50LmlkKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2dsb2JhbE5vZGVJbmRleE1hcC5nZXQobm9kZS5pZCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaGluZ01lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGV2dElkID0+IGdsb2JhbE5vZGVNYXAuZ2V0KGV2dElkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGV2dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2dC5hdHRhY2hlZFRvUmVmICYmIGNoaWxkcmVuLmluZGV4T2YoZXZ0LmF0dGFjaGVkVG9SZWYpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0YXJyYXlbZ2xvYmFsTm9kZUluZGV4TWFwLmdldChldnQuaWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJpdGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJpdGFycmF5W2ldID8gXCIxXCIgOiBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gJzBiJyA/IG5ldyBCaWdOdW1iZXIoMCkgOiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicHJvY2Vzc1N0YXJ0TWFya2luZzogc3VicHJvY2Vzc0lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvU2VhcmNoID0gZ2xvYmFsTm9kZU1hcC5nZXQoc3VicHJvY2Vzc0lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpdGFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBcIjBiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyh0b1NlYXJjaCwgXCJicG1uOkJvdW5kYXJ5RXZlbnRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG91dGdvaW5nIG9mIHRvU2VhcmNoLm91dGdvaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2NvbnRyb2xGbG93SW5mby5lZGdlSW5kZXhNYXAuZ2V0KG91dGdvaW5nLmlkKV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0b1NlYXJjaC5mbG93RWxlbWVudHMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPT4gaXMoZSwgXCJicG1uOkZsb3dOb2RlXCIpICYmIGlzKGUsIFwiYnBtbjpTdGFydEV2ZW50XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuJHBhcmVudC5pZCA9PT0gc3VicHJvY2Vzc0lkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdsb2JhbE5vZGVNYXAuZ2V0KG5vZGUuJHBhcmVudC5pZCkudHJpZ2dlcmVkQnlFdmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ldmVudERlZmluaXRpb25zICYmIG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMobm9kZS5ldmVudERlZmluaXRpb25zWzBdLCBcImJwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvblwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5WzBdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5vdXRnb2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG91dGdvaW5nIG9mIG5vZGUub3V0Z29pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0YXJyYXlbY29udHJvbEZsb3dJbmZvLmVkZ2VJbmRleE1hcC5nZXQob3V0Z29pbmcuaWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJpdGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJpdGFycmF5W2ldID8gXCIxXCIgOiBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIocmVzdWx0KS50b0ZpeGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRBbGxBbmNlc3RvcnNNYXNrOiBzdWJwcm9jSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0YXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiMGJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChzdWJwcm9jSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZS4kcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRhcnJheVtjb250cm9sRmxvd0luZm8ubm9kZUluZGV4TWFwLmdldChub2RlLmlkKV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuJHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gYml0YXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYml0YXJyYXlbaV0gPyBcIjFcIiA6IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihyZXN1bHQpLnRvRml4ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnByb2Nlc3NNYXJraW5nOiBzdWJwcm9jZXNzSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0YXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiMGJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsSW5mbyA9IGdsb2JhbENvbnRyb2xGbG93SW5mb01hcC5nZXQoc3VicHJvY2Vzc0lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVkZ2VMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsSW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS4kcGFyZW50ICYmIG5vZGUuJHBhcmVudC5pZCA9PT0gc3VicHJvY2Vzc0lkICYmIG5vZGUuaW5jb21pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmNvbWluZyBvZiBub2RlLmluY29taW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VMaXN0LnB1c2goaW5jb21pbmcuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VMaXN0LmZvckVhY2goZWRnZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2NvbnRyb2xGbG93SW5mby5lZGdlSW5kZXhNYXAuZ2V0KGVkZ2VJZCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicHJvY2Vzc0Z1bGxNYXJraW5nOiBzdWJwcm9jSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0YXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiMGJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gW3N1YnByb2NJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOlN1YlByb2Nlc3NcIikgJiYgbXVsdGlpbnN0YW5jZUFjdGl2aXRpZXMuaW5kZXhPZihub2RlSWQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlLiRwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuJHBhcmVudC5pZCA9PT0gc3VicHJvY0lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4uaW5kZXhPZihub2RlSWQpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS4kcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goc3VicHJvY2Vzc0lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbEluZm8gPSBnbG9iYWxDb250cm9sRmxvd0luZm9NYXAuZ2V0KHN1YnByb2Nlc3NJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEluZm8uZWRnZUxpc3QuZm9yRWFjaChlZGdlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2NvbnRyb2xGbG93SW5mby5lZGdlSW5kZXhNYXAuZ2V0KGVkZ2VJZCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJpdGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJpdGFycmF5W2ldID8gXCIxXCIgOiBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIocmVzdWx0KS50b0ZpeGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG93RWRnZUluZGV4OiBmbG93RWRnZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpdGFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2NvbnRyb2xGbG93SW5mby5lZGdlSW5kZXhNYXAuZ2V0KGZsb3dFZGdlSWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBcIjBiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvd05vZGVJbmRleDogZmxvd05vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRhcnJheVtnbG9iYWxOb2RlSW5kZXhNYXAuZ2V0KGZsb3dOb2RlSWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBcIjBiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlYWxJbmRleDogbm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbE5vZGVJbmRleE1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFydE9mRGVmZXJyZWRDaG9pY2U6IGV2ZW50SWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSBnbG9iYWxOb2RlTWFwLmdldChldmVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmluY29taW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGV2ZW50LmluY29taW5nWzBdLnNvdXJjZVJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpcyhub2RlLCBcImJwbW46RXZlbnRCYXNlZEdhdGV3YXlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RGVmZXJyZWRDaG9pY2VFbGVtZW50czogbm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuaW5jb21pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZXZlbnQuaW5jb21pbmdbMF0uc291cmNlUmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKG5vZGUsIFwiYnBtbjpFdmVudEJhc2VkR2F0ZXdheVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG91dGdvaW5nIG9mIG5vZGUub3V0Z29pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGdvaW5nLnRhcmdldFJlZi5pZCAhPT0gbm9kZUlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gob3V0Z29pbmcudGFyZ2V0UmVmLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2hvaWNlTm9kZU1hcmtpbmc6IG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudCA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuaW5jb21pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZXZlbnQuaW5jb21pbmdbMF0uc291cmNlUmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKG5vZGUsIFwiYnBtbjpFdmVudEJhc2VkR2F0ZXdheVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG91dGdvaW5nIG9mIG5vZGUub3V0Z29pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0YXJyYXlbY29udHJvbEZsb3dJbmZvLm5vZGVJbmRleE1hcC5nZXQob3V0Z29pbmcudGFyZ2V0UmVmLmlkKV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDaG9pY2VNYXJraW5nOiBldmVudElkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gZ2xvYmFsTm9kZU1hcC5nZXQoZXZlbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZXZlbnQuaW5jb21pbmdbMF0uc291cmNlUmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0YXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiMGJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub3V0Z29pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBvdXRnb2luZyBvZiBub2RlLm91dGdvaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0YXJyYXlbY29udHJvbEZsb3dJbmZvLmVkZ2VJbmRleE1hcC5nZXQob3V0Z29pbmcuaWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcmVzdWx0ID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRGVjbGFyYXRpb25zOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sRmxvd0luZm8uZ2xvYmFsUGFyYW1ldGVycy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xGbG93SW5mby5nbG9iYWxQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3JhY2xlRnVuY3Rpb246IG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sRmxvd0luZm8ub3JhY2xlVGFza01hcC5oYXMobm9kZUlkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sRmxvd0luZm8ub3JhY2xlSW5mby5nZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm9yYWNsZVRhc2tNYXAuZ2V0KG5vZGVJZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkuZnVuY3Rpb25OYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVQYXJhbWV0ZXJzOiBub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmRvY3VtZW50YXRpb24gJiYgbm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQgJiYgbm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc0RpY3QgPSBleHRyYWN0UGFyYW1ldGVycyhub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCwgbm9kZUlkLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNEaWN0ICE9PSB1bmRlZmluZWQgPyByZXNEaWN0LmdldChcImlucHV0XCIpLmxlbmd0aCA+IDAgfHwgcmVzRGljdC5nZXQoXCJvdXRwdXRcIikubGVuZ3RoID4gMCA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzOiAobm9kZUlkLCBpc0lucHV0LCBoYXNQcmV2aW91c1BhcmFtZXRlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5kb2N1bWVudGF0aW9uICYmIG5vZGUuZG9jdW1lbnRhdGlvblswXS50ZXh0ICYmIG5vZGUuZG9jdW1lbnRhdGlvblswXS50ZXh0Lmxlbmd0aCA+IDAgJiYgZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGVJZCwgbnVsbCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsUGFyYW1zID0gaXNJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGVJZCwgbnVsbCkuZ2V0KFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGV4dHJhY3RQYXJhbWV0ZXJzKG5vZGUuZG9jdW1lbnRhdGlvblswXS50ZXh0LCBub2RlSWQsIG51bGwpLmdldChcIm91dHB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gbG9jYWxQYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBsb2NhbFBhcmFtcy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiLCBcIiArIGxvY2FsUGFyYW1zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNQcmV2aW91c1BhcmFtZXRlciAmJiByZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIiwgXCIgKyByZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2F0UGFyYW1ldGVyczogKG5vZGVJZCwgaXNJbnB1dCwgaGFzVHlwZSwgaGFzUHJldmlvdXNQYXJhbWV0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZG9jdW1lbnRhdGlvbiAmJiBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCAmJiBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dC5sZW5ndGggPiAwICYmIGV4dHJhY3RQYXJhbWV0ZXJzKG5vZGUuZG9jdW1lbnRhdGlvblswXS50ZXh0LCBub2RlSWQsIG51bGwpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbFBhcmFtcyA9IGlzSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGV4dHJhY3RQYXJhbWV0ZXJzKG5vZGUuZG9jdW1lbnRhdGlvblswXS50ZXh0LCBub2RlSWQsIG51bGwpLmdldChcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBleHRyYWN0UGFyYW1ldGVycyhub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCwgbm9kZUlkLCBudWxsKS5nZXQoXCJvdXRwdXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGhhc1R5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsb2NhbFBhcmFtc1swXSArIFwiIFwiICsgbG9jYWxQYXJhbXNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBsb2NhbFBhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGxvY2FsUGFyYW1zLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gXCIsXCIgKyAoaGFzVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsb2NhbFBhcmFtc1tpXSArIFwiIFwiICsgbG9jYWxQYXJhbXNbaSArIDFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxvY2FsUGFyYW1zW2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc1ByZXZpb3VzUGFyYW1ldGVyICYmIHJlcy5sZW5ndGggPiAwID8gXCIsIFwiICsgcmVzIDogcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUZ1bmN0aW9uQm9keTogbm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnNjcmlwdC5zcGxpdChcIi0+XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuZG9jdW1lbnRhdGlvbiAmJiBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCAmJiBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dC5sZW5ndGggPiAwICYmIGV4dHJhY3RQYXJhbWV0ZXJzKG5vZGUuZG9jdW1lbnRhdGlvblswXS50ZXh0LCBub2RlSWQsIG51bGwpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHRyYWN0UGFyYW1ldGVycyhub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCwgbm9kZUlkLCBudWxsKS5nZXQoXCJib2R5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25kaXRpb246IGZsb3dFZGdlID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb3dFZGdlLmNvbmRpdGlvbkV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmxvd0VkZ2UuY29uZGl0aW9uRXhwcmVzc2lvbi5ib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZsb3dFZGdlLm5hbWUgPyBmbG93RWRnZS5uYW1lIDogZmxvd0VkZ2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXM6IGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbG9jYWxTb2xpZGl0eSA9IGJwbW4yc29sVGVtcGxhdGUoY29kZUdlbmVyYXRpb25JbmZvKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29kZSBmb3IgdXNpbmcgdGhlIHdvcmtsaXN0IHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXNlclRhc2tMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyYW1ldGVySW5mbzogTWFwPHN0cmluZywgTWFwPHN0cmluZywgQXJyYXk8UGFyYW1ldGVySW5mbz4+PiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCAnYnBtbjpVc2VyVGFzaycpIHx8IGlzKG5vZGUsICdicG1uOlJlY2VpdmVUYXNrJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlclRhc2tMaXN0LnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xGbG93SW5mby5sb2NhbFBhcmFtZXRlcnMuaGFzKG5vZGVJZCkgJiYgKGNvbnRyb2xGbG93SW5mby5sb2NhbFBhcmFtZXRlcnMuZ2V0KG5vZGVJZCkuZ2V0KCdpbnB1dCcpLmxlbmd0aCA+IDAgfHwgY29udHJvbEZsb3dJbmZvLmxvY2FsUGFyYW1ldGVycy5nZXQobm9kZUlkKS5nZXQoJ291dHB1dCcpLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJJbmZvLnNldChub2RlSWQsIGNvbnRyb2xGbG93SW5mby5sb2NhbFBhcmFtZXRlcnMuZ2V0KG5vZGVJZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbEZsb3dJbmZvLmNhdGNoaW5nTWVzc2FnZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyVGFza0xpc3QgPSB1c2VyVGFza0xpc3QuY29uY2F0KGNvbnRyb2xGbG93SW5mby5jYXRjaGluZ01lc3NhZ2VzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd29ya2xpc3Q6IFNtYXJ0IENvbnRyYWN0IEdlbmVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3b3JrbGlzdEdlbmVyYXRpb25JbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMaXN0OiB1c2VyVGFza0xpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdHJpY3RSZWxhdGlvbjogcmVzdHJpY3RSZWxhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJJbmZvOiBwYXJhbWV0ZXJJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleDogZ2xvYmFsTm9kZUluZGV4TWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVNYXA6IGdsb2JhbE5vZGVNYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0lkOiAoKSA9PiBjb250cm9sRmxvd0luZm8uc2VsZi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlTmFtZTogbm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE5vZGVOYW1lKGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UGFyYW1ldGVyVHlwZTogKG5vZGVJZCwgaXNJbnB1dCwgaXNUeXBlLCBoYXNQcmV2aW91cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlckluZm8uZ2V0KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbFBhcmFtcyA9IGlzSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtZXRlckluZm8uZ2V0KG5vZGVJZCkuZ2V0KFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmFtZXRlckluZm8uZ2V0KG5vZGVJZCkuZ2V0KFwib3V0cHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsUGFyYW1zICYmIGxvY2FsUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBpc1R5cGUgPyBsb2NhbFBhcmFtc1swXS50eXBlIDogbG9jYWxQYXJhbXNbMF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxvY2FsUGFyYW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gaXNUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiLCBcIiArIGxvY2FsUGFyYW1zW2ldLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCIsIFwiICsgbG9jYWxQYXJhbXNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmxlbmd0aCA+IDAgJiYgaGFzUHJldmlvdXMgPyBcIiwgXCIgKyByZXMgOiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRQYXJhbWV0ZXJzOiAobm9kZUlkLCBpc0lucHV0LCBoYXNUeXBlLCBoYXNQcmV2aW91cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlckluZm8uZ2V0KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbFBhcmFtcyA9IGlzSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtZXRlckluZm8uZ2V0KG5vZGVJZCkuZ2V0KFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmFtZXRlckluZm8uZ2V0KG5vZGVJZCkuZ2V0KFwib3V0cHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsUGFyYW1zICYmIGxvY2FsUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBoYXNUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbG9jYWxQYXJhbXNbMF0udHlwZSArIFwiIFwiICsgbG9jYWxQYXJhbXNbMF0ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxvY2FsUGFyYW1zWzBdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsb2NhbFBhcmFtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IGhhc1R5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCIsIFwiICsgbG9jYWxQYXJhbXNbaV0udHlwZSArIFwiIFwiICsgbG9jYWxQYXJhbXNbaV0ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIiwgXCIgKyBsb2NhbFBhcmFtc1tpXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMubGVuZ3RoID4gMCAmJiBoYXNQcmV2aW91cyA/IFwiLCBcIiArIHJlcyA6IHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFdvcmtJdGVtc0dyb3VwQnlQYXJhbWV0ZXJzOiAoaXNJbnB1dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZTJJZHM6IE1hcDxzdHJpbmcsIHN0cmluZ1tdPiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmZvckVhY2gobm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCAnYnBtbjpVc2VyVGFzaycpIHx8IGlzKG5vZGUsICdicG1uOlJlY2VpdmVUYXNrJykgfHwgY2F0Y2hpbmdNZXNzYWdlcy5pbmRleE9mKG5vZGVJZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJhbXMgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmRvY3VtZW50YXRpb24gJiYgbm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQgJiYgbm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQubGVuZ3RoID4gMCAmJiBleHRyYWN0UGFyYW1ldGVycyhub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCwgbm9kZUlkLCBudWxsKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbFBhcmFtcyA9IGlzSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGVJZCwgbnVsbCkuZ2V0KFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGVJZCwgbnVsbCkuZ2V0KFwib3V0cHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gbG9jYWxQYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGxvY2FsUGFyYW1zLmxlbmd0aDsgaSArPSAyKSBwYXJhbXMgKz0gbG9jYWxQYXJhbXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBnZXROb2RlTmFtZShnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpKSArIHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWUySWRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lMklkcy5zZXQobmFtZSwgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lMklkcy5nZXQobmFtZSkucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUySWRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXM6IGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxJbmZvLnNvbGlkaXR5ICs9IGxvY2FsU29saWRpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlclRhc2tMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbEluZm8uc29saWRpdHkgKz0gd29ya2xpc3Qyc29sVGVtcGxhdGUod29ya2xpc3RHZW5lcmF0aW9uSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoSlNPTi5zdHJpbmdpZnkobW9kZWxJbmZvLnNvbGlkaXR5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsSW5mby5jb250cm9sRmxvd0luZm9NYXAuc2V0KGNvbnRyb2xGbG93SW5mby5zZWxmLmlkLCBjb250cm9sRmxvd0luZm8pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmZvckVhY2gobm9kZUlkID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVJbmRleE1hcC5zZXQobm9kZUlkLCBnbG9iYWxOb2RlSW5kZXhNYXAuZ2V0KG5vZGVJZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmVkZ2VMaXN0LmZvckVhY2goZWRnZUlkID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmVkZ2VJbmRleE1hcC5zZXQoZWRnZUlkLCBnbG9iYWxFZGdlSW5kZXhNYXAuZ2V0KGVkZ2VJZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAgICAgbW9kZWxJbmZvLmVudHJ5Q29udHJhY3ROYW1lID0gbW9kZWxJbmZvLm5hbWUgKyBcIjpcIiArIChwcm9jLm5hbWUgPyBwcm9jLm5hbWUucmVwbGFjZSgvXFxzKy9nLCBcIl9cIikgOiBwcm9jLmlkKSArIFwiX0NvbnRyYWN0XCI7XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlTW9kZWxcbiJdfQ==