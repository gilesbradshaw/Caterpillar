"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _debug2 = _interopRequireDefault(require("debug"));

var _bpmnModdle = _interopRequireDefault(require("bpmn-moddle"));

var ejs = _interopRequireWildcard(require("ejs"));

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _definitions = require("./definitions");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* babel-plugin-inline-import '../../../templates/bpmn2sol.ejs' */
const bpmn2solEJS = "\nimport \"AbstractFactory\";\nimport \"AbstractProcess\";\nimport \"AbstractRegistry\";\n<% if(oracleTaskMap.size > 0) { -%>\ncontract Oracle_Wrapper {\n<% oracleTaskMap.forEach((oracleKey, nodeId, map) => { -%>\n    function <%= getOracleFunction(nodeId) %> (<%= typeParameters(nodeId, true, false) %>, function (uint<%= typeParameters(nodeId, false, true) %>) external returns(bool)) external returns(uint);\n<% }) -%>\n}\n<% } -%>\n\ncontract <%= nodeName(processId()) %>_Factory is AbstractFactory {\n    function newInstance(address parent, address processRegistry) public returns(address) {\n        <%= nodeName(processId()) %>_Contract newContract = new <%= nodeName(processId()) %>_Contract(parent, worklist, processRegistry);\n        return address(newContract);\n    }\n\n    function startInstanceExecution(address processAddress) public {\n        <%= nodeName(processId()) %>_Contract(processAddress).startExecution();\n    }\n}\n\n<% var contracts2Call = getContracts2Call();\n   var subprocessToKill = getPossibleKillSubprocess();\n   var eventsToCatch = getCatchingEvents(processId());\n   var eventTypes = allEventTypes(); -%>\n\ncontract <%= nodeName(processId()) %>_Contract is AbstractProcess {\n\n    uint public marking = uint(<%= subprocessStartMarking(processId()) %>);\n    uint public startedActivities = 0;\n<% if(contracts2Call.length > 0) { -%>\n    address[] private subInstanceAddresses;\n    mapping(uint => uint) private subInstanceStartedIndexes;\n<% } -%>\n\n<% /* --------- Solidity events to throw when an end message event is thrown  ---------------------------- */ -%>\n<% var messages = getThrowingMessages();\n   if(messages.length > 0) {\n    messages.forEach(nodeId => { -%>\n    // <%= nodeName(nodeId) %>\n    event <%= nodeId %>_Mesage(bytes32 messageText);\n<% })} -%>\n\n<% /* --------- Fields for interacting with external resources by means of callbacks (Oracle)  --------------- */ -%>\n<% if(oracleInfo.size > 0) { -%>\n    mapping(uint => address) oracleAddresses;\n<% } -%>\n    // Process Variables\n    <%= globalDeclarations() -%>\n\n    constructor(address _parent, address _worklist, address _processRegistry) public AbstractProcess(_parent, _worklist, _processRegistry) {\n<% oracleTaskMap.forEach((oracleKey, nodeId, map) => { -%>\n        oracleAddresses[<%= flowNodeIndex(nodeId) %>] = <%= oracleInfo.get(oracleKey).address %>;\n<% }) -%>\n<% if(getCountExternalTasks() > 0) { -%>\n        for (uint i = 0; i < <%= getCountExternalTasks() %>; i++)\n            requestedID.push(0);\n<% } -%>\n    }\n\n    function startExecution() public {\n        require(marking == uint(<%= subprocessStartMarking(processId()) %>) && startedActivities == 0);\n        step(uint(<%= subprocessStartMarking(processId()) %>), 0);\n    }\n\n<% /* --------------------------------- Event Handling ---------------------------------- */ -%>\n    function handleEvent(bytes32 code, bytes32 eventType, uint _instanceIndex, bool isInstanceCompleted) public {\n<% if(contracts2Call.length > 0 ) { -%>\n        (uint256 tmpMarking, uint256 tmpStartedActivities)  = (marking, startedActivities);\n        uint maskIndex = uint(1) << _instanceIndex;\n        uint sourceChild = 0;\n<%   var first = true;\n       contracts2Call.forEach(nodeId => {\n          var inFirst = true;\n          var node = nodeMap.get(nodeId); -%>\n<% if(first) { first = false; -%>        if <% } else { -%>        else if <% }-%>(subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] & uint(maskIndex) != 0) {\n            if(isInstanceCompleted)\n                subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] &= uint(~maskIndex);\n<% if(is(node, 'bpmn:BoundaryEvent')) { -%>\n<% var terminateCandidates = getTerminateCandidates(processId());\n     if(terminateCandidates.length > 0 ) {\n       terminateCandidates.forEach(bEvtId => {\n         var evtParentId = nodeMap.get(bEvtId).$parent.id;\n         if (inFirst && evtParentId === node.$parent.id) {\n            inFirst = false; -%>\n            if(eventType == \"Terminate\") {\n  <%     if(evtParentId === processId()) { -%>\n                killProcess();\n                propagateEvent('Default', 'Default', 0, 0, <%= flowNodeIndex(nodeId) %>);\n  <%     } else { -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(evtParentId) %>), tmpMarking, tmpStartedActivities);\n                step(tmpMarking | uint(<%= postMarking(evtParentId) %>), tmpStartedActivities);\n  <%     } -%>\n            }\n  <% } }) } -%>\n<% } -%>\n<% if(inFirst) { inFirst = false; -%>            if <% } else { -%>            else if <% }-%>(eventType == \"Default\") {\n<% if (node.loopCharacteristics && node.loopCharacteristics.$type === 'bpmn:MultiInstanceLoopCharacteristics') { -%>\n<%   if (node.loopCharacteristics.isSequential) { -%>\n                if(++_instanceIndex < subInstanceAddresses.length && subInstanceAddresses[_instanceIndex] == 0) {\n                    AbstractProcess child_<%= flowNodeIndex(nodeId) %> = AbstractProcess(AbstractRegistry(processRegistry).newInstanceFor(uint(<%= nodeRealIndex(nodeId) %>), address(this)));\n                    subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] |= (uint(1) << _instanceIndex);\n                    subInstanceAddresses[_instanceIndex] = child_<%= flowNodeIndex(nodeId) %>;\n                    child_<%= flowNodeIndex(nodeId) %>.setInstanceIndex(_instanceIndex);\n                }\n                else {\n                    step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>));\n                }\n<%  } else { -%>\n                if (subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] == 0)\n                    step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>));\n<% }} else if(!is(node, 'bpmn:BoundaryEvent') && !node.triggeredByEvent) { -%>\n                step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>));\n<% } else { -%>\n                tmpStartedActivities &= uint(~<%= flowNodeIndex(nodeId) %>);\n                (marking, startedActivities) = (tmpMarking, tmpStartedActivities);\n                if(tmpMarking | tmpStartedActivities == 0)\n                    propagateEvent(\"<%= nodeName(nodeId) %>\", \"Default\", tmpMarking, tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<% } -%>\n            }\n<% if(eventsToCatch.length > 0) { -%>\n            else\n                sourceChild |= uint(<%= flowNodeIndex(nodeId) %>);\n<% } -%>\n        }\n<% }) -%>\n<% first = true;\n   eventsToCatch.forEach(evtId => {\n   var nodeEvt = nodeMap.get(evtId);\n   var evtType = eventType(evtId); -%>\n<% if (evtType === 'Error' || evtType === 'Escalation') {\n          var candidateSubprocMask = getProcessCandidatesMaskFrom(evtId, evtType, nodeName(evtId), contracts2Call, eventsToCatch); -%>\n<% if(first) { first = false; -%>        if <% } else { -%>        else if <% }-%>(eventType == \"<%= evtType %>\" && code == \"<%= nodeName(evtId) %>\" && sourceChild & uint(<%= candidateSubprocMask %>) != 0) {\n<%    if(isInterrupting(evtId)) {\n        if(nodeEvt.$parent.triggeredByEvent) {\n          var startingKill = nodeEvt.$parent.$parent.id === processId() ? 0 : flowNodeIndex(nodeEvt.$parent.$parent.id); -%>\n            (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= startingKill %>), tmpMarking, tmpStartedActivities);\n            step(tmpMarking | uint(<%= subprocessStartMarking(nodeEvt.$parent.id) %>), tmpStartedActivities | uint(<%= flowNodeIndex(nodeEvt.$parent.id) %>));\n<%            } else { -%>\n            (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(nodeEvt.attachedToRef.id) %>), tmpMarking, tmpStartedActivities);\n            step(tmpMarking | uint(<%= postMarking(evtId) %>), tmpStartedActivities);\n<%            } -%>\n<%          } else {  -%>\n            createNewSubprocessInstance(<%= nodeRealIndex(evtId) %>);\n<% if (nodeEvt.attachedToRef) {\n      let nodeId = nodeEvt.attachedToRef.id;\n      let node = nodeMap.get(nodeId);\n      if (node.loopCharacteristics && node.loopCharacteristics.$type === 'bpmn:MultiInstanceLoopCharacteristics') {\n        if (node.loopCharacteristics.isSequential) { -%>\n            if(++_instanceIndex < subInstanceAddresses.length && subInstanceAddresses[_instanceIndex] == 0) {\n                AbstractProcess child_<%= flowNodeIndex(nodeId) %> = AbstractProcess(AbstractRegistry(processRegistry).newInstanceFor(uint(<%= nodeRealIndex(nodeId) %>), address(this)));\n                subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] |= (uint(1) << _instanceIndex);\n                subInstanceAddresses[_instanceIndex] = child_<%= flowNodeIndex(nodeId) %>;\n                child_<%= flowNodeIndex(nodeId) %>.setInstanceIndex(_instanceIndex);\n                step(tmpMarking, tmpStartedActivities | uint(<%= flowNodeIndex(evtId) %>));\n            }\n            else {\n                step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>) | uint(<%= flowNodeIndex(evtId) %>));\n            }\n<%      } else { -%>\n            if (subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] == 0)\n                step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>) | uint(<%= flowNodeIndex(evtId) %>));\n<% }} else if(!is(node, 'bpmn:BoundaryEvent') && !node.triggeredByEvent) { -%>\n            step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>) | uint(<%= flowNodeIndex(evtId) %>));\n<% } -%>\n<% } else { -%>\n            step(tmpMarking, tmpStartedActivities | uint(<%= flowNodeIndex(evtId) %>));\n<%   }      } -%>\n            }\n<%  } -%>\n<% }); -%>\n        else {\n            (tmpMarking, tmpStartedActivities) = propagateEvent(code, eventType, tmpMarking, tmpStartedActivities, sourceChild);\n            step(tmpMarking, tmpStartedActivities);\n        }\n<% } else { -%>\n        // Process without calls to external contracts.\n        // No events to catch !!!\n<% } -%>\n    }\n\n<% /* --------------------------------- Kill Childrens & Broadcast ------------------------------ */ -%>\n    function killProcess() public {\n        (marking, startedActivities) = killProcess(0, marking, startedActivities);\n    }\n\n    function killProcess(uint processElementIndex, uint tmpMarking, uint tmpStartedActivities) internal returns(uint, uint) {\n<% if(contracts2Call.length == 0) {         /* Case No External contract call in the contract */ -%>\n        if(processElementIndex == 0)\n            tmpMarking = tmpStartedActivities = 0;\n<% if(subprocessToKill.length > 0) { -%>\n<%     subprocessToKill.forEach(subprocId => { -%>\n        else if(processElementIndex & uint(<%= flowNodeIndex(subprocId) %>) != 0) {\n            tmpMarking &= uint(~<%=subprocessFullMarking(subprocId)%>);\n            tmpStartedActivities &= uint(~<%= subprocessNodeFullMarking(subprocId) %>);\n        }\n<%      }) }\n} else {                                    /* Case External Contract Calls in Main contract */ -%>\n        uint externalContracts2Stop = 0;\n        uint allAddresses2Stop = 0;\n        if(processElementIndex == 0) {\n            tmpMarking = tmpStartedActivities = 0;\n<% var getContracts2CallMask = getContracts2CallMaskFrom(processId(), contracts2Call);\n   if(getContracts2CallMask > 0) { -%>\n            externalContracts2Stop = uint(<%= getContracts2CallMask %>);\n<% } -%>\n        }\n<% subprocessToKill.forEach(subprocId => { -%>\n        else if(processElementIndex & uint(<%= flowNodeIndex(subprocId) %>) != 0) {\n<% if(callActivities.indexOf(subprocId) >= 0) { -%>\n            externalContracts2Stop = uint(<%= flowNodeIndex(subprocId) %>);\n<% } else { -%>\n            tmpMarking &= uint(~<%= subprocessFullMarking(subprocId) %>);\n            tmpStartedActivities &= uint(~<%= subprocessNodeFullMarking(subprocId) %>);\n<%  var contracts2CallMask = getContracts2CallMaskFrom(subprocId, contracts2Call);\n    if (contracts2CallMask !== 0) { -%>\n            externalContracts2Stop = uint(<%= contracts2CallMask %>);\n<% } -%>\n<% } -%>\n        }\n<%  }) -%>\n<% contracts2Call.forEach(subprocId => { -%>\n        if(externalContracts2Stop & uint(<%= flowNodeIndex(subprocId) %>) != 0) {\n            allAddresses2Stop |= subInstanceStartedIndexes[<%= nodeRealIndex(subprocId) %>];\n            subInstanceStartedIndexes[<%= nodeRealIndex(subprocId) %>] = 0;\n        }\n<% }) -%>\n        for(uint j = 0; j < subInstanceAddresses.length; j++)\n            if(allAddresses2Stop & (uint(1) << j) != 0)\n                AbstractProcess(subInstanceAddresses[j]).killProcess();\n<% } -%>\n        return (tmpMarking, tmpStartedActivities);\n    }\n\n    function broadcastSignal() public {\n        (uint256 tmpMarking, uint256 tmpStartedActivities) = broadcastSignal(marking, startedActivities, 0);\n        step(tmpMarking, tmpStartedActivities);\n    }\n\n    function broadcastSignal(uint tmpMarking, uint tmpStartedActivities, uint sourceChild) internal returns(uint, uint) {\n<% eventsToCatch.forEach(nodeId => {\n     if(eventType(nodeId) === 'Signal') {\n       var node = nodeMap.get(nodeId);\n        if(is(node, 'bpmn:IntermediateCatchEvent')) {\n          if (isPartOfDeferredChoice(nodeId)) { -%>\n        if(tmpMarking & uint(<%= deferredChoiceMarking(nodeId) %>) == uint(<%= deferredChoiceMarking(nodeId) %>))\n            tmpMarking = tmpMarking & uint(~<%= deferredChoiceMarking(nodeId) %>) | uint(<%= postMarking(nodeId) %>);\n<%            var deferredNodeMarking = deferredChoiceNodeMarking(nodeId);\n              if(deferredNodeMarking != 0) { -%>\n            tmpStartedActivities &= uint(~<%= deferredNodeMarking %>);\n<%    } -%>\n<%        } else {      -%>\n        if(tmpMarking & uint(<%= preMarking(nodeId) %>) == uint(<%= preMarking(nodeId) %>))\n            tmpMarking = tmpMarking & uint(~<%= preMarking(nodeId) %>) | uint(<%= postMarking(nodeId) %>);\n<%  }} else if(is(node, 'bpmn:StartEvent')) {\n           var parent = nodeMap.get(node.$parent.id);\n           if (parent.triggeredByEvent) {\n              if (isInterrupting(nodeId)) { -%>\n        if(tmpMarking & uint(~<%= subprocessFullMarking(parent.id) %>) != 0 || tmpStartedActivities & uint(~<%= subprocessNodeFullMarking(parent.id) %>) != 0) {\n            (tmpMarking, tmpStartedActivities) = killProcess(0, tmpMarking, tmpStartedActivities);\n            tmpStartedActivities |= uint(<%= flowNodeIndex(parent.id) %>);\n            tmpMarking |= uint(<%= subprocessStartMarking(parent.id) %>);\n        }\n<%            } else { -%>\n        if(tmpMarking & uint(<%= subprocessFullMarking(processId()) %>) != 0 || tmpStartedActivities & uint(~<%= flowNodeIndex(parent.id) %>) != 0) {\n            createNewSubprocessInstance(<%= nodeRealIndex(nodeId) %>);\n            tmpStartedActivities |= <%= flowNodeIndex(nodeId) %>;\n        }\n<%            } -%>\n<%         } else { -%>\n               /* Starting subprocess (not event subprocess) */\n<%         } -%>\n<%      } else if (is(node, 'bpmn:BoundaryEvent')) { -%>\n        if(tmpStartedActivities & uint(<%= flowNodeIndex(node.attachedToRef.id) %>) != 0) {\n<%          if(isInterrupting(nodeId)) { -%>\n            (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(node.attachedToRef.id) %>), tmpMarking, tmpStartedActivities);\n            tmpMarking |= uint(<%= postMarking(nodeId) %>);\n<%          } else { -%>\n            createNewSubprocessInstance(<%= nodeRealIndex(nodeId) %>);\n            tmpStartedActivities |= uint(<%= flowNodeIndex(nodeId) %>);\n<%          } -%>\n        }\n<% } -%>\n<% }}) -%>\n<% if (contracts2Call.length > 0) { -%>\n        uint contracts2Broadcast = 0;\n<%  contracts2Call.forEach(nodeId => { -%>\n        if (tmpStartedActivities & uint(<%= flowNodeIndex(nodeId) %>) != 0)\n            contracts2Broadcast |= subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>];\n<%  }) -%>\n        contracts2Broadcast &= uint(~sourceChild);\n        if(contracts2Broadcast != 0)\n            for(uint j = 0; j < subInstanceAddresses.length; j++)\n                if(contracts2Broadcast & (uint(1) << j) != 0)\n                    AbstractProcess(subInstanceAddresses[j]).broadcastSignal();\n<%  }   -%>\n        return (tmpMarking, tmpStartedActivities);\n    }\n\n<% /* --------------------------------- Functions from BPMN elements -------------------------- */ -%>\n<%  nodeList.forEach( nodeId => {\n        let node = nodeMap.get(nodeId),\n            nodePreMarking = preMarking(nodeId),\n            nodePostMarking = postMarking(nodeId);\n    if (is(node, 'bpmn:ServiceTask')) { -%>\n    // <%= nodeName(node.id) %>\n    function <%= nodeName(node.id) %>_callbak (uint reqId<%= concatParameters(name2Ids.get(nodeName[0]), false, true, true) %>) external returns(bool) {\n        require(msg.sender == oracleAddresses[<%= flowNodeIndex(node.id) %>]);\n        uint index = uint(1) << reqId;\n        if(requestedID[<%= nodeRealIndex(node.id) %>] & index == index) {\n            <%= nodeFunctionBody(nodeId) %>\n            requestedID[<%= nodeRealIndex(node.id) %>] &= ~uint(index);\n            step(marking | uint(<%= nodePostMarking %>), startedActivities);\n            return true;\n        }\n        return false ;\n    }\n<% }}); -%>\n\n<%  boundaryMessages = getMessages();\n    groupedIds = getWorkItemsGroupByParameters(false);\n    groupedIds.forEach(idGroup => { -%>\n    function <%= nodeName(idGroup[0]) %>_complete(uint elementIndex<%= concatParameters(idGroup[0], false, true, true) %>) external {\n        (uint256 tmpMarking, uint256 tmpStartedActivities) = (marking, startedActivities);\n<%    idGroup.forEach(nodeId => {\n        var node = nodeMap.get(nodeId); -%>\n        if(elementIndex == uint(<%= nodeRealIndex(nodeId) %>)) {\n            require(msg.sender == worklist && tmpStartedActivities & uint(<%= flowNodeIndex(nodeId) %>) != 0);\n<% if(boundaryMessages.indexOf(nodeId) < 0) {\n     var functionBody = nodeFunctionBody(nodeId);\n     if(functionBody.length > 0) { -%>\n           <%- functionBody %>\n<%   } -%>\n<% if (isPartOfDeferredChoice(nodeId)) {\n          var deferredNodeMarking = deferredChoiceNodeMarking(nodeId);\n          if(deferredNodeMarking != 0) { -%>\n            step(tmpMarking & uint(~<%= deferredChoiceMarking(nodeId) %>) | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= deferredNodeMarking %>));\n<%        } else { -%>\n            step(tmpMarking & uint(~<%= deferredChoiceMarking(nodeId) %>) | uint(<%= postMarking(nodeId) %>), tmpStartedActivities);\n<%        } -%>\n<% } else { -%>\n            step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities & uint(~<%= flowNodeIndex(nodeId) %>));\n<% }} else {\n  var parent = nodeMap.get(node.$parent.id);\n  if(parent.triggeredByEvent) { -%>\n<% if (isInterrupting(nodeId)) { -%>\n            killProcess();\n            step(uint(<%= subprocessStartMarking(parent.id) %>), uint(<%= flowNodeIndex(parent.id) %>));\n<% } else { -%>\n            createNewSubprocessInstance(<%= nodeRealIndex(nodeId) %>);\n            step(tmpMarking, tmpStartedActivities | <%= flowNodeIndex(parent.id) %>);\n<%   } -%>\n<% } else {\n    var attachedTo = node.attachedToRef.id;\n    if (isInterrupting(nodeId)) { -%>\n            (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(attachedTo) %>), tmpMarking, tmpStartedActivities);\n            step(tmpMarking | uint(<%= postMarking(nodeId) %>), tmpStartedActivities);\n<%  } else { -%>\n            createNewSubprocessInstance(<%= nodeRealIndex(nodeId) %>);\n            step(tmpMarking, tmpStartedActivities | <%= flowNodeIndex(nodeId) %>);\n<%     }}} -%>\n            return;\n        }\n<% }) -%>\n    }\n<%   }) -%>\n\n<% if(contracts2Call.length > 0) { -%>\n    function createNewSubprocessInstance(uint nodeIndex) private {\n        AbstractProcess child = AbstractProcess(AbstractRegistry(processRegistry).newInstanceFor(nodeIndex, address(this)));\n        uint index = subInstanceAddresses.length;\n        subInstanceAddresses.push(address(child));\n        subInstanceStartedIndexes[nodeIndex] |= (uint(1) << index);\n        child.setInstanceIndex(index);\n    }\n<% } -%>\n\n<% /* ----------------- Step: Method to execute internal activities automatically ------------------ */ -%>\n    function step(uint tmpMarking, uint tmpStartedActivities) internal {\n        while (true) {\n<% nodeList.forEach(nodeId => {\n    var node = nodeMap.get(nodeId);\n    var nodePostMarking = postMarking(nodeId);\n    if(catchingMessages.indexOf(nodeId) < 0) {\n        var nodePreMarking = preMarking(nodeId);\n     if (node.loopCharacteristics && node.loopCharacteristics.$type === 'bpmn:MultiInstanceLoopCharacteristics') { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n<%        if(!is (node, \"bpmn:Task\")) { -%>\n                for(uint i = 0; i < <%= node.loopCharacteristics.loopCardinality ? node.loopCharacteristics.loopCardinality.body : 1 %>; i++) {\n<% if (node.loopCharacteristics.isSequential) { -%>\n                    subInstanceAddresses.push(0);\n<% } else { -%>\n                    createNewSubprocessInstance(<%= nodeRealIndex(nodeId) %>);\n<% } -%>\n                }\n<% if (node.loopCharacteristics.isSequential) { -%>\n                AbstractProcess child_<%= flowNodeIndex(nodeId) %> = AbstractProcess(AbstractRegistry(processRegistry).newInstanceFor(uint(<%= nodeRealIndex(nodeId) %>), address(this)));\n                uint index = subInstanceAddresses.length - <%= node.loopCharacteristics.loopCardinality ? node.loopCharacteristics.loopCardinality.body : 1 %>;\n                subInstanceStartedIndexes[<%= nodeRealIndex(nodeId) %>] |= (uint(1) << index);\n                subInstanceAddresses[index] = child_<%= flowNodeIndex(nodeId) %>;\n                child_<%= flowNodeIndex(nodeId) %>.setInstanceIndex(index);\n<% } -%>\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                tmpStartedActivities |= <%= flowNodeIndex(nodeId) %>;\n<%      } -%>\n                continue;\n            }\n<% } else if (is(node, 'bpmn:ExclusiveGateway')) { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n<%          if (node.outgoing && node.outgoing.length > 1) {\n            var i = 0; node.outgoing.forEach( outgoing => { -%>\n<%= i > 0 ? 'else ' : '' %><%if (i < node.outgoing.length - 1){ %>if (<%- getCondition(outgoing) %>)<% } -%>\n                tmpMarking |= uint(<%= flowEdgeIndex(outgoing.id) %>);\n<% i++;}) -%>\n<%          } else { -%>\n                tmpMarking |= uint(<%= postMarking(nodeId) %>);\n<%          } -%>\n                continue;\n            }\n<% } else if(is(node, 'bpmn:ParallelGateway') || is(node,'bpmn:EventBasedGateway')) { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) == uint(<%= nodePreMarking %>)) {\n                tmpMarking = tmpMarking & uint(~<%= nodePreMarking %>) | uint(<%= nodePostMarking %>);\n                continue;\n            }\n<% } else if(is(node, 'bpmn:SubProcess') && !node.triggeredByEvent && multiinstanceActivities.indexOf(nodeId) < 0) { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeId) %>);\n                tmpMarking = tmpMarking & uint(~<%= nodePreMarking %>) | uint(<%= subprocessStartMarking(nodeId) %>);\n                continue;\n            }\n<% } else if(is(node, 'bpmn:ReceiveTask')) {\n    if (isPartOfDeferredChoice(nodeId)) { -%>\n            if (tmpStartedActivities & uint(<%= flowNodeIndex(nodeId) %>) == 0 && tmpMarking & uint(<%= deferredChoiceMarking(nodeId) %>) == uint(<%= deferredChoiceMarking(nodeId) %>)) {\n                <%= nodeName(processId()) %>_AbstractWorklist(worklist).<%= nodeName(nodeId) %>_start(<%= nodeRealIndex(nodeId) %><%= concatParameters(nodeId, true, false, true) %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeId) %>);\n                continue;\n            }\n<%  } else { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n                <%= nodeName(processId()) %>_AbstractWorklist(worklist).<%= nodeName(nodeId) %>_start(<%= nodeRealIndex(nodeId) %><%= concatParameters(nodeId, true, false, true) %>);\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(node.id) %>);\n                continue;\n            }\n<% }} else if((is(node, 'bpmn:Task'))) { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n<%    if (is(node, 'bpmn:UserTask'))  { -%>\n                <%= nodeName(processId()) %>_AbstractWorklist(worklist).<%= nodeName(nodeId) %>_start(<%= nodeRealIndex(nodeId) %><%= concatParameters(nodeId, true, false, true) %>);\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(node.id) %>);\n<%  } else if(is(node, 'bpmn:ServiceTask')) {\n          var functName = oracleTaskMap.get(nodeId);\n          var localInfo = oracleInfo.get(functName); -%>\n                uint reqId = Oracle_Wrapper(oracleAddresses[<%= flowNodeIndex(nodeId) %>]).<%= localInfo.functionName %>(<%= concatParameters(node.id, true, false, false) %>, this.<%= nodeName(nodeId) %>_callbak);\n                requestedID[<%= nodeRealIndex(node.id) %>] |= uint(1) << reqId;\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(node.id) %>);\n<%  } else if (is(node, 'bpmn:ScriptTask')) {\n         if (node.script) { -%>\n                <%- nodeFunctionBody(nodeId) -%>\n<%       } -%>\n                tmpMarking = tmpMarking & uint(~<%= nodePreMarking %>) | uint(<%= nodePostMarking %>);\n<%  } else { -%>\n                tmpMarking = tmpMarking & uint(~<%= nodePreMarking %>) | uint(<%= nodePostMarking %>);\n<%  } -%>\n                continue;\n            }\n<% } else if(is(node, 'bpmn:EndEvent')) {\n          var evtType = eventType(nodeId); -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n<% if(evtType === 'Default' || evtType === 'Message') { -%>\n<% if(evtType === 'Message') { -%>\n                <%= nodeId %>_Mesage('<%= nodeName(nodeId) %>');\n<% } -%>\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                if (tmpMarking & uint(<%= subprocessFullMarking(node.$parent.id) %>) == 0 && tmpStartedActivities & uint(<%= subprocessNodeMarking(node.$parent.id) %>) == 0) {\n<% if(node.$parent.id === processId() || nodeMap.get(node.$parent.id).triggeredByEvent || (is(nodeMap.get(processId()), 'bpmn:BoundaryEvent') && node.$parent.id === nodeMap.get(processId()).$parent.id)) { -%>\n<% if(nodeMap.get(node.$parent.id).triggeredByEvent) { -%>\n                    tmpStartedActivities &= uint(~<%= flowNodeIndex(node.$parent.id) %>);\n<% } -%>\n                    (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"Default\", tmpMarking, tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<% } else { -%>\n                    tmpStartedActivities &= uint(~<%= flowNodeIndex(node.$parent.id) %>);\n                    tmpMarking |= uint(<%= postMarking(node.$parent.id) %>);\n<% } -%>\n                }\n<% } else if (evtType === 'Terminate') { -%>\n<% if(is(nodeMap.get(processId()), 'bpmn:BoundaryEvent') && node.$parent.id === nodeMap.get(processId()).$parent.id) { -%>\n                (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"Terminate\", tmpMarking, tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<% } else if(node.$parent.id === processId()) { -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(0, tmpMarking, tmpStartedActivities);\n                (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"Default\", tmpMarking, tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<% } else { -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(node.$parent.id) %>), tmpMarking, tmpStartedActivities);\n                tmpMarking |= uint(<%= postMarking(node.$parent.id) %>);\n                tmpStartedActivities &= uint(~<%= flowNodeIndex(node.$parent.id) %>);\n<% } -%>\n<% } else if (evtType === 'Signal') { -%>\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"Signal\", tmpMarking, tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<% } else if (evtType === 'Error' || evtType === 'Escalation') {\n        var localEvents2Catch = getCatchingEventsFrom(node.$parent.id, evtType, nodeName(nodeId));\n        if(localEvents2Catch.length == 0) { -%>\n                (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"<%= evtType %>\", tmpMarking & uint(~<%= nodePreMarking %>), tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<%      } else {\n        localEvents2Catch.forEach(evtId => {\n            var nodeEvt = nodeMap.get(evtId);\n            if(isInterrupting(evtId)) {\n              if(nodeEvt.$parent.triggeredByEvent) {\n                 var startingKill = nodeEvt.$parent.$parent.id === processId() ? 0 : flowNodeIndex(nodeEvt.$parent.$parent.id); -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= startingKill %>), tmpMarking & uint(~<%= nodePreMarking %>), tmpStartedActivities);\n                tmpMarking |= uint(<%= subprocessStartMarking(nodeEvt.$parent.id) %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeEvt.$parent.id) %>);\n<%            } else { -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(nodeEvt.attachedToRef.id) %>), tmpMarking & uint(~<%= nodePreMarking %>), tmpStartedActivities);\n                tmpMarking |= uint(<%= postMarking(evtId) %>);\n<%            } -%>\n<%          } else {  -%>\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                createNewSubprocessInstance(<%= nodeRealIndex(evtId) %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(evtId) %>);\n<%          } }) -%>\n<%   } } -%>\n                continue;\n            }\n<% } else if(is(node, 'bpmn:IntermediateThrowEvent')) {\n       var evtType = eventType(nodeId); -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n<% if(evtType === 'Default') { -%>\n                tmpMarking = tmpMarking & uint(~<%= nodePreMarking %>) | uint(<%= nodePostMarking %>);\n<% } else {\n    if (isPartOfDeferredChoice(nodeId)) { -%>\n                tmpMarking = tmpMarking & uint(~<%= deferredChoiceMarking(nodeId) %>) | uint(<%= nodePostMarking %>);\n<%    var deferredNodeMarking = deferredChoiceNodeMarking(nodeId);\n      if(deferredNodeMarking != 0) { -%>\n              tmpStartedActivities &= uint(~<%= deferredNodeMarking %>);\n<%    } -%>\n<%  } else { -%>\n                tmpMarking = tmpMarking & uint(~<%= nodePreMarking %>) | uint(<%= nodePostMarking %>);\n<%  }  if (evtType === 'Signal') { -%>\n                (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"Signal\", tmpMarking, tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n<%  } else if(evtType === 'Message') { -%>\n                <%= nodeId %>_Mesage('<%= nodeName(nodeId) %>');\n<%  } else if(evtType === 'Escalation') {\n          var localEvents2Catch = getCatchingEventsFrom(node.$parent.id, evtType, nodeName(nodeId));\n          if(localEvents2Catch.length == 0) { -%>\n                (tmpMarking, tmpStartedActivities) = propagateEvent(\"<%= nodeName(nodeId) %>\", \"<%= evtType %>\", tmpMarking & uint(~<%= nodePreMarking %>), tmpStartedActivities, uint(<%= flowNodeIndex(nodeId) %>));\n  <%      } else {\n          localEvents2Catch.forEach(evtId => {\n              var nodeEvt = nodeMap.get(evtId);\n              if(isInterrupting(evtId)) {\n                if(nodeEvt.$parent.triggeredByEvent) {\n                   var startingKill = nodeEvt.$parent.$parent.id === processId() ? 0 : flowNodeIndex(nodeEvt.$parent.$parent.id); -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= startingKill %>), tmpMarking & uint(~<%= nodePreMarking %>), tmpStartedActivities);\n                tmpMarking |= uint(<%= subprocessStartMarking(nodeEvt.$parent.id) %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeEvt.$parent.id) %>);\n  <%            } else { -%>\n                (tmpMarking, tmpStartedActivities) = killProcess(uint(<%= flowNodeIndex(nodeEvt.attachedToRef.id) %>), tmpMarking & uint(~<%= nodePreMarking %>), tmpStartedActivities);\n                tmpMarking |= uint(<%= postMarking(evtId) %>);\n  <%            } -%>\n  <%          } else {  -%>\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                createNewSubprocessInstance(<%= nodeRealIndex(evtId) %>);\n  <% if(nodeEvt.$parent.triggeredByEvent) { -%>\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeEvt.$parent.id) %>);\n  <% } else { -%>\n                tmpStartedActivities |= uint(<%= flowNodeIndex(evtId) %>);\n  <% }         } }) -%>\n  <%   } -%>\n<% }} -%>\n                continue;\n            }\n<% } else if (callActivities.indexOf(nodeId) >= 0) { -%>\n            if (tmpMarking & uint(<%= nodePreMarking %>) != 0) {\n                createNewSubprocessInstance(<%= nodeRealIndex(nodeId) %>);\n                tmpMarking &= uint(~<%= nodePreMarking %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeId) %>);\n                continue;\n            }\n<% }} else {\n  if(isBoundaryEvent(nodeId)) {\n    var attachedTo = node.attachedToRef.id; -%>\n            if (tmpStartedActivities & uint(<%= flowNodeIndex(attachedTo) %>) != 0 && tmpStartedActivities & uint(<%= flowNodeIndex(nodeId) %>) == 0) {\n                <%= nodeName(processId()) %>_AbstractWorklist(worklist).<%= nodeName(nodeId) %>_start(<%= nodeRealIndex(nodeId) %><%= concatParameters(nodeId, true, false, true) %>);\n                tmpStartedActivities |= uint(<%= flowNodeIndex(nodeId) %>);\n                continue;\n            }\n            if (tmpStartedActivities & uint(<%= flowNodeIndex(attachedTo) %>) == 0 && tmpStartedActivities & uint(<%= flowNodeIndex(nodeId) %>) != 0) {\n                tmpStartedActivities &= uint(~<%= flowNodeIndex(nodeId) %>);\n                continue;\n            }\n  <% } -%>\n<% }}); -%>\n            break;\n        }\n        if(marking != 0 || startedActivities != 0) {\n            marking = tmpMarking;\n            startedActivities = tmpStartedActivities;\n        }\n    }\n\n    function getWorklistAddress() external view returns(address) {\n        return worklist;\n    }\n\n    function getInstanceIndex() external view returns(uint) {\n        return instanceIndex;\n    }\n\n<% /* ------------- Methods to obtain information about multiple contract instances running ------------------ */ -%>\n<% if (callActivities.length > 0 || multiinstanceActivities.length > 0 || nonInterruptingEvents.length > 0) { -%>\n    function allInstanceAddresses() external view returns(address [] memory) {\n        return subInstanceAddresses;\n    }\n\n    function startedInstanceIndexFor(uint instanceNode) external view returns(uint) {\n        return subInstanceStartedIndexes[instanceNode];\n    }\n\n<% } -%>\n}\n";

/* babel-plugin-inline-import '../../../templates/workList2sol.ejs' */
const workList2solEJS = "pragma solidity ^0.5.6;\n\nimport \"AbstractWorklist\";\n\ncontract <%= nodeName(processId()) %>_AbstractWorklist {\n\n  <%  groupedIds = getWorkItemsGroupByParameters(true);\n      groupedIds.forEach(idGroup => {\n          var nodeId = idGroup[0]; -%>\n    function <%= nodeName(nodeId) %>_start(uint<%= getParameterType(nodeId, true, true, true) %>) external;\n  <% }) -%>\n\n  <%  groupedIds = getWorkItemsGroupByParameters(false);\n      groupedIds.forEach(idGroup => {\n          var nodeId = idGroup[0]; -%>\n    function <%= nodeName(nodeId) %>_complete(uint<%= getParameterType(nodeId, false, true, true) %>) external;\n  <% }) -%>\n\n}\n\ncontract <%= nodeName(processId()) %>_Worklist is AbstractWorklist {\n\n    // Events with the information to include in the Log when a workitem is registered\n<%  groupedIds = getWorkItemsGroupByParameters(true);\n    groupedIds.forEach(idGroup => { -%>\n    event <%= nodeName(idGroup[0]) %>_Requested(uint<%= getParameterType(idGroup[0], true, true, true) %>);\n<% }) -%>\n\n<%  groupedIds = getWorkItemsGroupByParameters(true);\n    groupedIds.forEach(idGroup => {\n        var nodeId = idGroup[0]; -%>\n    function <%= nodeName(nodeId) %>_start(uint elementIndex<%= getParameters(nodeId, true, true, true) %>) external {\n        workitems.push(Workitem(elementIndex, msg.sender));\n        emit <%= nodeName(nodeId) %>_Requested(workitems.length - 1<%= getParameters(nodeId, true, false, true) %>);\n    }\n<% }) -%>\n\n<%  groupedIds = getWorkItemsGroupByParameters(false);\n    groupedIds.forEach(idGroup => {\n        var nodeId = idGroup[0]; -%>\n    function <%= nodeName(nodeId) %>(uint workitemId<%= getParameters(nodeId, false, true, true) %>) external {\n        require(workitemId < workitems.length && workitems[workitemId].processInstanceAddr != address(0) && \n        canPerform(msg.sender, workitems[workitemId].processInstanceAddr, workitems[workitemId].elementIndex));\n        <%= nodeName(processId()) %>_AbstractWorklist(workitems[workitemId].processInstanceAddr).<%= nodeName(nodeId) %>_complete(workitems[workitemId].elementIndex<%= getParameters(nodeId, false, false, true) %>);\n        workitems[workitemId].processInstanceAddr = address(0);\n    }\n<% }) -%>\n\n}\n";
const debug = (0, _debug2.default)('caterpillarql:parse-model');
const bpmn2solTemplate = ejs.compile(bpmn2solEJS);
const workList2solTemplate = ejs.compile(workList2solEJS);
let moddle = new _bpmnModdle.default();

let parseBpmn = bpmnDoc => {
  return new Promise((resolve, reject) => {
    moddle.fromXML(bpmnDoc, (err, definitions) => {
      if (!err) resolve(definitions);else reject(err);
    });
  });
};

let is = (element, type) => element.$instanceOf(type);

let collectControlFlowInfo;

collectControlFlowInfo = (proc, globalNodeMap, globalControlFlowInfo) => {
  let nodeList = [];
  let edgeList = [];
  let boundaryEvents = [];
  let nonBlockingBoundaryEvents = [];
  let controlFlowInfo;

  for (let node of proc.flowElements.filter(e => is(e, "bpmn:FlowNode"))) {
    if (is(node, "bpmn:BoundaryEvent")) {
      boundaryEvents.push(node.id);
      if (node.cancelActivity == false) nonBlockingBoundaryEvents.push(node.id);
    } else {
      nodeList.push(node.id);
    }

    globalNodeMap.set(node.id, node);
  }

  let sources = [...nodeList];

  for (let flowEdge of proc.flowElements.filter(e => is(e, "bpmn:SequenceFlow"))) {
    if (sources.indexOf(flowEdge.targetRef.id) > -1) {
      sources.splice(sources.indexOf(flowEdge.targetRef.id), 1);
    }

    edgeList.push(flowEdge.id);
  } // Let us remove all source elements from the node list


  nodeList = nodeList.filter(node => sources.indexOf(node) < 0);

  if (nonBlockingBoundaryEvents.length > 0) {
    let dfs = sources => {
      let open = [...sources];
      let nodeList = [];
      let edgeList = [];

      while (open.length > 0) {
        let currId = open.pop();
        let curr = globalNodeMap.get(currId);
        nodeList.push(currId);
        if (curr.outgoing && curr.outgoing.length > 0) for (let succEdge of curr.outgoing) {
          let succ = succEdge.targetRef;
          edgeList.push(succEdge.id);
          if (open.indexOf(succ.id) < 0 && nodeList.indexOf(succ.id) < 0) open.push(succ.id);
        }
      }

      return [nodeList, edgeList];
    };

    let [mainPathNodeList, mainPathEdgeList] = dfs(sources);
    let localBoundary = [];
    boundaryEvents.forEach(evtId => {
      if (nonBlockingBoundaryEvents.indexOf(evtId) < 0) localBoundary.push(evtId);
    });

    if (localBoundary.length > 0) {
      let [boundaryNodePath, boundaryEdgePath] = dfs(localBoundary);
      boundaryNodePath = boundaryNodePath.filter(node => localBoundary.indexOf(node) < 0);
      mainPathNodeList = mainPathNodeList.concat(boundaryNodePath);
      mainPathEdgeList = mainPathEdgeList.concat(boundaryEdgePath);
    } // Let us remove all source elements from the node list


    mainPathNodeList = mainPathNodeList.filter(node => sources.indexOf(node) < 0);
    controlFlowInfo = new _definitions.ControlFlowInfo(proc, mainPathNodeList, mainPathEdgeList, sources, boundaryEvents);
    globalControlFlowInfo.push(controlFlowInfo);

    for (let eventId of nonBlockingBoundaryEvents) {
      let event = globalNodeMap.get(eventId);

      if (!mainPathNodeList.find(e => event.attachedToRef.id === e)) {
        throw new Error("ERROR: Found non-interrupting event which is not attached to a subprocess in the main process path");
      }

      let [localNodeList, localEdgeList] = dfs([eventId]);
      if (mainPathNodeList.filter(nodeId => localNodeList.indexOf(nodeId) >= 0).length > 0) throw new Error("ERROR: Non-interrupting event outgoing path is not synchronized and merges with main process path"); // Let us remove all source elements from the node list

      localNodeList = localNodeList.filter(node => sources.indexOf(node) < 0);
      let childControlFlowInfo = new _definitions.ControlFlowInfo(event, localNodeList, localEdgeList, [eventId], []);
      childControlFlowInfo.parent = proc;
      globalControlFlowInfo.push(childControlFlowInfo);
    }
  } else {
    controlFlowInfo = new _definitions.ControlFlowInfo(proc, nodeList, edgeList, sources, boundaryEvents);
    globalControlFlowInfo.push(controlFlowInfo);
  }

  for (let subprocess of proc.flowElements.filter(e => is(e, "bpmn:SubProcess"))) {
    let subprocessControlFlowInfo = collectControlFlowInfo(subprocess, globalNodeMap, globalControlFlowInfo);
    subprocessControlFlowInfo.parent = proc;

    if (!(subprocess.loopCharacteristics && subprocess.loopCharacteristics.$type === "bpmn:MultiInstanceLoopCharacteristics")) {
      // Subprocess is embedded ... then copy all nodes and edges to the parent process
      subprocessControlFlowInfo.isEmbedded = true;
      controlFlowInfo.nodeList = controlFlowInfo.nodeList.concat(subprocessControlFlowInfo.nodeList);
      controlFlowInfo.edgeList = controlFlowInfo.edgeList.concat(subprocessControlFlowInfo.edgeList);
      controlFlowInfo.boundaryEvents = controlFlowInfo.boundaryEvents.concat(subprocessControlFlowInfo.boundaryEvents);
    }
  }

  if (proc.documentation) {
    controlFlowInfo.globalParameters = proc.documentation[0].text;
  }

  return controlFlowInfo;
};

let restrictRelation = new Map();

let extractParameters = (cad, nodeId, controlFlowInfo) => {
  // Extracting Roles from UserTasks functionBody
  let arr = cad.split('@');

  if (arr.length >= 3) {
    if (controlFlowInfo != null) controlFlowInfo.taskRoleMap.set(nodeId, arr[1].trim());
    if (arr[2].length > 1) cad = arr[2];else return undefined;
  } // Extracting Information of Oracle from Service Tasks (if aplicable)


  let oracle_Data = "";

  for (let j = 0, first = false; j < cad.length; j++) {
    if (cad.charAt(j) === "(") {
      if (!first) first = true;else {
        cad = cad.substr(j);
        break;
      }
    }

    if (cad.charAt(j) === ":") {
      oracle_Data = "";
      break;
    }

    oracle_Data += cad.charAt(j);
  } // Processing Information of function parameters (both service and user tasks)


  cad = cad.replace("(", " ").replace(")", " ").trim();
  cad = cad.replace("(", " ").replace(")", " ").trim();
  let firstSplit = cad.split(":");

  if (firstSplit.length > 2) {
    let aux = '';

    for (let i = 1; i < firstSplit.length; i++) aux += firstSplit[i];

    firstSplit = [firstSplit[0], aux];
  }

  let secondSplit = firstSplit[firstSplit.length - 1].trim().split("->");
  let resMap = new Map();
  let inputOutput = [firstSplit[0].trim(), secondSplit[0].trim()];
  let parameterType = ["input", "output"];
  resMap.set("body", [secondSplit[secondSplit.length - 1].trim()]);

  for (let i = 0; i < inputOutput.length; i++) {
    let temp = inputOutput[i].split(",");
    let res = [];
    temp.forEach(subCad => {
      let aux = subCad.trim().split(" ");

      if (aux[0].trim().length > 0) {
        res.push(aux[0].trim());
        res.push(aux[aux.length - 1].trim());
      }
    });
    resMap.set(parameterType[i], res);
  } // Updating Information of Oracle in controlFlowInfo


  if (controlFlowInfo != null) {
    let inParameters = [];
    let outParameters = [];
    let toIterate = resMap.get('input');

    for (let i = 0; i < toIterate.length; i += 2) inParameters.push(new _definitions.ParameterInfo(toIterate[i], toIterate[i + 1]));

    toIterate = resMap.get('output');
    let parameters = new Map();
    parameters.set('input', inParameters);
    parameters.set('output', outParameters);

    for (let i = 0; i < toIterate.length; i += 2) outParameters.push(new _definitions.ParameterInfo(toIterate[i], toIterate[i + 1]));

    if (oracle_Data.length > 0) {
      oracle_Data = oracle_Data.trim().replace(" ", "_");
      oracle_Data = oracle_Data.replace("(", " ").replace(").", " ").trim();
      let splitResult = oracle_Data.split(" ");

      if (!controlFlowInfo.oracleInfo.has(splitResult[0])) {
        controlFlowInfo.oracleInfo.set(splitResult[0], new _definitions.OracleInfo(splitResult[0]));
      }

      controlFlowInfo.oracleTaskMap.set(nodeId, splitResult[0]);
      let localOracle = controlFlowInfo.oracleInfo.get(splitResult[0]);
      localOracle.address = splitResult[1];
      localOracle.functionName = splitResult[2];
      localOracle.functionParameters = parameters.get('input');
    } else controlFlowInfo.localParameters.set(nodeId, parameters);
  }

  return resMap;
};

let getNodeName = node => node.name ? node.name.replace(/\s+/g, "_") : node.id;

let parseModel = modelInfo => {
  return new Promise((resolve, reject) => {
    parseBpmn(modelInfo.bpmn).then(definitions => {
      debug('parsed model', definitions);
      modelInfo.solidity = "pragma solidity ^0.5.6;\n";
      modelInfo.controlFlowInfoMap = new Map(); // Sanity checks

      if (!definitions.diagrams || definitions.diagrams.length == 0) throw new Error("ERROR: No diagram found in BPMN file");
      let proc = definitions.diagrams[0].plane.bpmnElement;
      modelInfo.name = proc.name ? proc.name.replace(/\s+/g, "_") : proc.id;
      modelInfo.id = proc.id;

      if (proc.$type !== "bpmn:Process") {
        if (proc.$type === "bpmn:Collaboration") {
          for (let i = 0; i < definitions.rootElements.length; i++) if (definitions.rootElements[i].$type === "bpmn:Process") {
            proc = definitions.rootElements[i];
            modelInfo.name = proc.name ? proc.name.replace(/\s+/g, "_") : proc.id;
            modelInfo.id = proc.id;
            break;
          }
        } else {
          throw new Error("ERROR: No root process model found");
        }
      } // BPMN to Solidity parsing


      let globalNodeMap = new Map(),
          globalNodeIndexMap = new Map(),
          globalEdgeIndexMap = new Map(),
          globalControlFlowInfo = []; ////////////////////////////////////////////////////////////

      globalNodeMap.set(proc.id, proc);
      let mainControlFlowInfo = collectControlFlowInfo(proc, globalNodeMap, globalControlFlowInfo);
      let globalControlFlowInfoMap = new Map();
      globalControlFlowInfo.forEach(controlFlowInfo => globalControlFlowInfoMap.set(controlFlowInfo.self.id, controlFlowInfo)); // Event sub-processes appear in the source list, and not in the nodeList
      // In addition, all the elements of a non interrupting subprocess event appears embedded on its parent process

      for (let controlFlowInfo of globalControlFlowInfo) {
        let indexesToRemove = [];
        controlFlowInfo.sources.forEach(nodeId => {
          if (globalNodeMap.get(nodeId).triggeredByEvent) {
            controlFlowInfo.nodeList.push(nodeId);
            indexesToRemove.push(controlFlowInfo.sources.indexOf(nodeId));
            let nodeInfo = globalControlFlowInfoMap.get(nodeId);
            if (!globalNodeMap.get(nodeInfo.sources[0]).isInterrupting) nodeInfo.nodeList.forEach(childId => {
              let index = controlFlowInfo.nodeList.indexOf(childId);
              if (index >= 0) controlFlowInfo.nodeList.splice(index, 1);
            });
          }
        });
        indexesToRemove.sort((ind1, ind2) => {
          return ind2 - ind1;
        });
        indexesToRemove.forEach(index => {
          controlFlowInfo.sources.splice(index, 1);
        });

        if (is(globalNodeMap.get(controlFlowInfo.self.id), "bpmn:SubProcess") && controlFlowInfo.self.triggeredByEvent && globalNodeMap.get(controlFlowInfo.sources[0]).isInterrupting == false) {
          controlFlowInfo.isEmbedded = false;
        }
      }

      let hasExternalCall = nodeId => {
        let node = globalNodeMap.get(nodeId);
        return is(node, "bpmn:ServiceTask");
      };

      modelInfo.globalNodeMap = globalNodeMap;

      for (let controlFlowInfo of globalControlFlowInfo) {
        if (!controlFlowInfo.isEmbedded) {
          let multiinstanceActivities = [],
              callActivities = [],
              nonInterruptingEvents = [],
              catchingMessages = [];
          controlFlowInfo.nodeList.map(nodeId => globalNodeMap.get(nodeId)).forEach(e => {
            if ((is(e, "bpmn:Task") || is(e, "bpmn:SubProcess")) && e.loopCharacteristics && e.loopCharacteristics.$type === "bpmn:MultiInstanceLoopCharacteristics") {
              controlFlowInfo.multiinstanceActivities.set(e.id, getNodeName(e));
              multiinstanceActivities.push(e.id);
            } else if (is(e, "bpmn:CallActivity")) {
              controlFlowInfo.callActivities.set(e.id, getNodeName(e));
              callActivities.push(e.id);
            } else if (is(e, "bpmn:IntermediateCatchEvent") && is(e.eventDefinitions[0], "bpmn:MessageEventDefinition")) catchingMessages.push(e.id);else if (is(e, "bpmn:StartEvent") && is(e.eventDefinitions[0], "bpmn:MessageEventDefinition")) catchingMessages.push(e.id);
          }); // It is also necessary to add boundary events of embedded sub-processes

          controlFlowInfo.sources.forEach(nodeId => {
            let start = globalNodeMap.get(nodeId);

            if (start.eventDefinitions && start.eventDefinitions[0] && is(start.eventDefinitions[0], "bpmn:MessageEventDefinition") && controlFlowInfo.nodeList.indexOf(nodeId) < 0) {
              controlFlowInfo.nodeList.push(nodeId);
              if (catchingMessages.indexOf(nodeId) < 0) catchingMessages.push(nodeId);
            }
          });
          controlFlowInfo.boundaryEvents.forEach(nodeId => {
            let node = globalNodeMap.get(nodeId);
            if (node.outgoing) for (let outgoing of node.outgoing) controlFlowInfo.edgeList.push(outgoing.id);

            if (!node.cancelActivity) {
              controlFlowInfo.nonInterruptingEvents.set(node.id, getNodeName(node));
              nonInterruptingEvents.push(node.id);
              controlFlowInfo.nodeList.push(nodeId); // Eager reinsertion

              if (node.eventDefinitions[0] && is(node.eventDefinitions[0], 'bpmn:MessageEventDefinition')) {
                if (catchingMessages.indexOf(nodeId) < 0) catchingMessages.push(nodeId);
              }
            } else if (node.eventDefinitions && is(node.eventDefinitions[0], "bpmn:MessageEventDefinition")) {
              if (controlFlowInfo.nodeList.indexOf(nodeId) < 0) controlFlowInfo.nodeList.push(nodeId);
              if (catchingMessages.indexOf(nodeId) < 0) catchingMessages.push(nodeId);
            }
          });
          globalNodeMap.forEach(node => {
            if (is(node, "bpmn:SubProcess") && node.triggeredByEvent && controlFlowInfo.nodeList.indexOf(node.id)) {
              for (let start of node.flowElements.filter(e => is(e, "bpmn:FlowNode") && is(e, "bpmn:StartEvent"))) {
                if (start.isInterrupting == false) {
                  let parent = globalNodeMap.get(start.$parent.id);
                  controlFlowInfo.nonInterruptingEvents.set(start.id, getNodeName(parent));
                  nonInterruptingEvents.push(start.id);
                  controlFlowInfo.nodeList.push(start.id);

                  if (start.eventDefinitions[0] && is(start.eventDefinitions[0], "bpmn:MessageEventDefinition")) {
                    if (catchingMessages.indexOf(start.id) < 0) catchingMessages.push(start.id);
                  }
                }

                if (controlFlowInfo.boundaryEvents.indexOf(start.id) < 0) {
                  controlFlowInfo.boundaryEvents.push(start.id);
                  if (controlFlowInfo.nodeList.indexOf(start.$parent.id) < 0) controlFlowInfo.nodeList.push(start.$parent.id);
                }

                if (start.eventDefinitions[0] && is(start.eventDefinitions[0], "bpmn:MessageEventDefinition")) {
                  if (controlFlowInfo.nodeList.indexOf(start.id) < 0) controlFlowInfo.nodeList.push(start.id);
                  if (catchingMessages.indexOf(start.id) < 0) catchingMessages.push(start.id);
                }

                if (start.outgoing) for (let outgoing of start.outgoing) controlFlowInfo.edgeList.push(outgoing.id);
              }
            }
          });
          let part1 = [];
          let part2 = [];
          controlFlowInfo.nodeList.forEach(nodeId => {
            if (hasExternalCall(nodeId)) part1.push(nodeId);else part2.push(nodeId);
          });
          controlFlowInfo.nodeList = part1.concat(part2);
          controlFlowInfo.nodeList.forEach((nodeId, index) => {
            let node = globalNodeMap.get(nodeId);
            controlFlowInfo.nodeIndexMap.set(nodeId, index + 1);
            globalNodeIndexMap.set(nodeId, index + 1);
            controlFlowInfo.nodeNameMap.set(nodeId, getNodeName(globalNodeMap.get(nodeId)));

            if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0) {
              if (is(node, 'bpmn:CallActivity')) controlFlowInfo.externalBundles.set(nodeId, node.documentation[0].text);else extractParameters(node.documentation[0].text, node.id, controlFlowInfo);
            }
          });
          controlFlowInfo.edgeList.forEach((edgeId, index) => {
            controlFlowInfo.edgeIndexMap.set(edgeId, index + 1);
            globalEdgeIndexMap.set(edgeId, index + 1);
          });
          controlFlowInfo.catchingMessages = catchingMessages; // ControlFlow Perspective: Generation of Smart Contracts

          let codeGenerationInfo = {
            nodeList: controlFlowInfo.nodeList,
            nodeMap: globalNodeMap,
            catchingMessages: controlFlowInfo.catchingMessages,
            multiinstanceActivities: multiinstanceActivities,
            callActivities: callActivities,
            nonInterruptingEvents: nonInterruptingEvents,
            oracleInfo: controlFlowInfo.oracleInfo,
            oracleTaskMap: controlFlowInfo.oracleTaskMap,
            processId: () => controlFlowInfo.self.id,
            nodeName: nodeId => getNodeName(globalNodeMap.get(nodeId)),
            eventType: nodeId => {
              let node = globalNodeMap.get(nodeId);

              if (node.eventDefinitions && node.eventDefinitions[0]) {
                let cad = node.eventDefinitions[0].$type;
                return cad.substring(5, cad.length - 15);
              }

              return "Default";
            },
            allEventTypes: () => {
              let taken = [];
              globalNodeMap.forEach(node => {
                if (node.eventDefinitions && node.eventDefinitions[0] && !is(node.eventDefinitions[0], "bpmn:TerminateEventDefinition") && !is(node.eventDefinitions[0], "bpmn:MessageEventDefinition")) {
                  let cad = node.eventDefinitions[0].$type;
                  if (taken.indexOf(cad.substring(5, cad.length - 15)) < 0) taken.push(cad.substring(5, cad.length - 15));
                }
              });
              return taken;
            },
            getMessages: () => {
              let taken = [];
              let candidates = controlFlowInfo.boundaryEvents;
              controlFlowInfo.nodeList.forEach(nodeId => {
                if (is(globalNodeMap.get(nodeId), "bpmn:SubProcess")) {
                  let subP = globalControlFlowInfoMap.get(nodeId);
                  candidates = candidates.concat(subP.boundaryEvents);
                  subP.sources.forEach(id => {
                    if (!is(globalNodeMap.get(id), "bpmn:Subprocess") && candidates.indexOf(id) < 0) candidates.push(id);
                  });
                }
              });
              candidates.forEach(evtId => {
                let evt = globalNodeMap.get(evtId);
                if (evt.eventDefinitions && evt.eventDefinitions[0] && is(evt.eventDefinitions[0], "bpmn:MessageEventDefinition")) taken.push(evtId);
              });
              return taken;
            },
            getThrowingMessages: () => {
              let res = [];
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);
                if ((is(node, "bpmn:EndEvent") || is(node, "bpmn:IntermediateThrowEvent")) && node.eventDefinitions && node.eventDefinitions[0] && is(node.eventDefinitions[0], "bpmn:MessageEventDefinition")) res.push(nodeId);
              });
              return res;
            },
            getThrowingEvents: (subprocId, evType) => {
              let res = [];
              globalNodeMap.forEach(node => {
                if (node.eventDefinitions && node.eventDefinitions[0]) {
                  let cad = node.eventDefinitions[0].$type;

                  if (cad.substring(5, cad.length - 15) === evType) {
                    if ((is(node, "bpmn:EndEvent") || is(node, "bpmn:IntermediateThrowEvent")) && (node.$parent.id === subprocId || controlFlowInfo.nodeList.indexOf(node.id) >= 0)) {
                      res.push(node.id);
                    }
                  }
                }
              });
              return res;
            },
            getCatchingEvents: subprocId => {
              let res = [];
              globalNodeMap.forEach(node => {
                if (node.eventDefinitions && node.eventDefinitions[0]) {
                  if (is(node, "bpmn:StartEvent")) {
                    let parent = globalNodeMap.get(node.$parent.id);
                    if (parent.triggeredByEvent && parent.$parent.id === subprocId) res.unshift(node.id);else if (!parent.triggeredByEvent && (parent.id === subprocId || controlFlowInfo.nodeList.indexOf(parent.id) > -1)) res.push(node.id);
                  } else if (is(node, "bpmn:BoundaryEvent") || is(node, "bpmn:IntermediateCatchEvent")) {
                    if (node.$parent.id === subprocId || controlFlowInfo.nodeList.indexOf(node.$parent.id) > -1) res.push(node.id);
                  }
                }
              });
              return res;
            },
            getTerminateCandidates: subprocId => {
              let res = [];
              globalNodeMap.forEach(node => {
                if (node.eventDefinitions && node.eventDefinitions[0]) {
                  if (is(node, "bpmn:BoundaryEvent") && node.cancelActivity == false) {
                    if (globalControlFlowInfoMap.has(node.id)) {
                      let localC = globalControlFlowInfoMap.get(node.id);
                      localC.nodeList.forEach(elemId => {
                        let elem = globalNodeMap.get(elemId);
                        if (elem.eventDefinitions && is(elem.eventDefinitions[0], "bpmn:TerminateEventDefinition") && elem.$parent.id === node.$parent.id) res.push(node.id);
                      });
                    } else {
                      debug('Missing Non Interrupting event');
                    }
                  }
                }
              });
              return res;
            },
            getProcessCandidatesMaskFrom: (evtId, evtType, evtCode, sourceProcesses, allEvents) => {
              let eventList = [];
              let bitarray = [];
              allEvents.forEach(nodeId => {
                let cad = globalNodeMap.get(nodeId).eventDefinitions[0].$type;
                if (evtType === cad.substring(5, cad.length - 15) && evtCode === getNodeName(globalNodeMap.get(nodeId))) eventList.push(nodeId);
              });
              sourceProcesses.forEach(procId => {
                let parent = globalNodeMap.get(procId);
                let previousParent = parent;
                let res = [];
                let eventFound = false;

                while (!eventFound && res.length == 0 && parent.$parent && controlFlowInfo.self.id !== parent.id) {
                  parent = globalNodeMap.get(parent.$parent.id);
                  eventList.forEach(nodeId => {
                    let node = globalNodeMap.get(nodeId);

                    if (!eventFound && is(node, "bpmn:BoundaryEvent") && node.attachedToRef.id === previousParent.id) {
                      eventFound = node.cancelActivity != false;
                      if (eventFound) res = [nodeId];else res.push(nodeId);
                    }
                  });

                  if (res.length == 0) {
                    eventList.forEach(nodeId => {
                      let node = globalNodeMap.get(nodeId);

                      if (!eventFound && is(node, "bpmn:StartEvent") && node.$parent.triggeredByEvent && node.$parent.$parent.id === parent.id) {
                        eventFound = node.isInterrupting != false;
                        if (eventFound) res = [nodeId];else res.push(nodeId);
                      }
                    });
                  }

                  previousParent = parent;
                }

                if (res.indexOf(evtId)) bitarray[globalNodeIndexMap.get(procId)] = 1;
              });
              let result = "0b";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return result === "0b" ? 0 : new _bignumber.default(result).toFixed();
            },
            getCatchingEventsFrom: (procId, evtType, evtCode) => {
              // Escalation and Error catching events.
              // No intermediate events in normal flow allowed
              let res = [];
              let parent = globalNodeMap.get(procId);
              let eventFound = false;
              let candidates = controlFlowInfo.boundaryEvents.concat(controlFlowInfo.nodeList);
              let eventList = [];
              candidates.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (node.eventDefinitions) {
                  let cad = node.eventDefinitions[0].$type;
                  let type = cad.substring(5, cad.length - 15);

                  if (type === evtType && evtCode === getNodeName(globalNodeMap.get(nodeId)) && eventList.indexOf(nodeId) < 0) {
                    eventList.push(nodeId);
                  }
                }
              });

              if (!parent.triggeredByEvent) {
                eventList.forEach(nodeId => {
                  let node = globalNodeMap.get(nodeId);

                  if (!eventFound && is(node, "bpmn:StartEvent") && node.$parent.triggeredByEvent && node.$parent.$parent.id === parent.id) {
                    eventFound = node.isInterrupting != false;
                    if (eventFound) res = [nodeId];else res.push(nodeId);
                  }
                });
              }

              if (controlFlowInfo.self.id === procId || res.length > 0) {
                return res;
              } else {
                if (parent.triggeredByEvent) parent = globalNodeMap.get(parent.$parent.id);
                let previousParent = parent;

                while (!eventFound && res.length == 0 && parent.$parent && controlFlowInfo.self.id !== parent.id) {
                  parent = globalNodeMap.get(parent.$parent.id);
                  eventList.forEach(nodeId => {
                    let node = globalNodeMap.get(nodeId);

                    if (!eventFound && is(node, "bpmn:BoundaryEvent") && node.attachedToRef.id === previousParent.id) {
                      eventFound = node.cancelActivity != false;
                      if (eventFound) res = [nodeId];else res.push(nodeId);
                    }
                  });

                  if (res.length == 0) {
                    eventList.forEach(nodeId => {
                      let node = globalNodeMap.get(nodeId);

                      if (!eventFound && is(node, "bpmn:StartEvent") && node.$parent.triggeredByEvent && node.$parent.$parent.id === parent.id) {
                        eventFound = node.isInterrupting != false;
                        if (eventFound) res = [nodeId];else res.push(nodeId);
                      }
                    });
                  }

                  previousParent = parent;
                }

                return res;
              }
            },
            getWorkItemsGroupByParameters: isInput => {
              let name2Ids = new Map();
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (is(node, 'bpmn:UserTask') || is(node, 'bpmn:ReceiveTask') || catchingMessages.indexOf(nodeId) >= 0) {
                  let params = "";

                  if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0 && extractParameters(node.documentation[0].text, nodeId, null) !== undefined) {
                    let localParams = isInput ? extractParameters(node.documentation[0].text, nodeId, null).get("input") : extractParameters(node.documentation[0].text, nodeId, null).get("output");

                    if (localParams.length > 0) {
                      params = localParams[0];

                      for (let i = 2; i < localParams.length; i += 2) params += localParams[i];
                    }
                  }

                  let name = getNodeName(globalNodeMap.get(nodeId)) + params;

                  if (!name2Ids.has(name)) {
                    name2Ids.set(name, []);
                  }

                  name2Ids.get(name).push(nodeId);
                }
              });
              return name2Ids;
            },
            getContracts2Call: () => {
              let res = callActivities.concat(multiinstanceActivities);
              nonInterruptingEvents.forEach(evtId => {
                let node = globalNodeMap.get(evtId);
                res.push(is(node, "bpmn:StartEvent") ? node.$parent.id : evtId);
              });
              return res;
            },
            getContracts2CallFrom: (subprocId, candidates) => {
              let res = [subprocId];

              if (!controlFlowInfo.callActivities.has(subprocId)) {
                candidates.forEach(nodeId => {
                  let node = globalNodeMap.get(nodeId);

                  while (node.$parent) {
                    if (node.$parent.id === subprocId) {
                      res.push(nodeId);
                      break;
                    }

                    node = node.$parent;
                  }
                });
              }

              return res;
            },
            getContracts2CallMaskFrom: (subprocId, candidates) => {
              let bitarray = [];
              candidates.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                while (node.$parent) {
                  if (node.$parent.id === subprocId) {
                    bitarray[globalNodeIndexMap.get(nodeId)] = 1;
                    break;
                  }

                  node = node.$parent;
                }
              });
              let result = "0b";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return result === "0b" ? 0 : new _bignumber.default(result).toFixed();
            },
            getContracts2CallArray: (subprocId, candidates) => {
              let res = '[uint(' + globalNodeIndexMap.get(candidates[0]) + ')';

              for (let i = 1; i < candidates.length; i++) res += ', uint(' + globalNodeIndexMap.get(candidates[i]) + ')';

              return res + ']';
            },
            getPossibleKillSubprocess: () => {
              let res = [];
              controlFlowInfo.boundaryEvents.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (node.$parent.triggeredByEvent && node.$parent.$parent.id !== controlFlowInfo.self.id) {
                  if (node.isInterrupting != false && res.indexOf(node.$parent.$parent.id) < 0) res.push(node.$parent.$parent.id);
                } else if (node.attachedToRef) {
                  let attachedTo = node.attachedToRef.id;

                  if (node.cancelActivity != false && res.indexOf(attachedTo) < 0) {
                    res.push(attachedTo);
                  }
                }
              });
              globalNodeMap.forEach(node => {
                if (node.eventDefinitions && node.eventDefinitions[0]) {
                  if (is(node, "bpmn:BoundaryEvent") && node.cancelActivity == false) {
                    if (globalControlFlowInfoMap.has(node.id)) {
                      let localC = globalControlFlowInfoMap.get(node.id);
                      localC.nodeList.forEach(elemId => {
                        let elem = globalNodeMap.get(elemId);

                        if (elem.eventDefinitions && is(elem.eventDefinitions[0], "bpmn:TerminateEventDefinition") && elem.$parent.id === node.$parent.id && controlFlowInfo.nodeList.indexOf(node.$parent.id) >= 0 && res.indexOf(node.$parent.id) < 0 && node.$parent.id != controlFlowInfo.self.id) {
                          res.push(node.$parent.id);
                        }
                      });
                    }
                  }
                }
              });
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (node.eventDefinitions && is(node.eventDefinitions[0], "bpmn:TerminateEventDefinition")) {
                  if (res.indexOf(node.$parent.id) < 0 && node.$parent.id != controlFlowInfo.self.id && !is(globalNodeMap.get(controlFlowInfo.self.id), "bpmn:BoundaryEvent")) {
                    debug('I am here 2');
                    res.push(node.$parent.id);
                  }
                }
              });
              return res;
            },
            getCountExternalTasks: () => {
              let res = 0;
              controlFlowInfo.nodeList.forEach(nodeId => {
                if (hasExternalCall(nodeId)) res++;
              });
              return res;
            },
            getStartedMessages: processId => {
              let res = [];
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);
                if (is(node, "bpmn:StartEvent") && node.$parent.id === processId && node.eventDefinitions && is(node.eventDefinitions[0], "bpmn:MessageEventDefinition") && globalNodeMap.get(node.$parent.id).triggeredByEvent) res.push(nodeId);
              });
              return res;
            },
            getParent: nodeId => {
              // Retrieves the id of the parent
              let node = globalNodeMap.get(nodeId);
              if (is(node, "bpmn:StartEvent") && node.$parent && globalNodeMap.get(node.$parent.id).triggeredByEvent) return globalNodeMap.get(node.$parent.id).$parent.id;
              if (is(node, "bpmn:BoundaryEvent") && node.cancelActivity) return node.attachedToRef.id;
              return node.$parent ? node.$parent.id : nodeId;
            },
            getContractName: nodeId => {
              // Retrieves the contract name related to the node.
              let node = globalNodeMap.get(nodeId);
              if (is(node, "bpmn:StartEvent") && node.$parent && globalNodeMap.get(node.$parent.id).triggeredByEvent) return node.$parent.id;
              if (is(node, "bpmn:BoundaryEvent")) return node.id;
              return controlFlowInfo.self.id;
            },
            getAllChildren: (subprocId, direct) => {
              let taken = direct ? [] : [subprocId];
              controlFlowInfo.nodeList.map(nodeId => globalNodeMap.get(nodeId)).forEach(e => {
                if (is(e, "bpmn:SubProcess") || callActivities.indexOf(e.id) >= 0 || nonInterruptingEvents.indexOf(e.id) >= 0 && !is(e, "bpmn:StartEvent")) if ((direct && subprocId !== e.id && e.$parent.id === subprocId || !direct) && taken.indexOf(e.id) < 0) taken.push(e.id);
              });
              return taken;
            },
            isStartingContractEvent: (eventId, processId) => {
              let evt = globalNodeMap.get(eventId);

              if (is(evt, "bpmn:StartEvent")) {
                if (globalNodeMap.get(evt.$parent.id).triggeredByEvent) return evt.$parent.id !== processId;
                if (is(evt.eventDefinitions[0], "bpmn:MessageEventDefinition")) return true;
              } else if (is(evt, "bpmn:BoundaryEvent")) {
                return eventId !== processId;
              } else if (is(evt, "bpmn:IntermediateCatchEvent") && is(evt.eventDefinitions[0], "bpmn:MessageEventDefinition")) return true;

              return false;
            },
            isInterrupting: eventId => {
              // True if an event is interrupting
              let node = globalNodeMap.get(eventId);
              if (node.eventDefinitions && is(node.eventDefinitions[0], "bpmn:ErrorEventDefinition")) return true;
              if (is(node, "bpmn:StartEvent") && node.$parent && globalNodeMap.get(node.$parent.id).triggeredByEvent) return node.isInterrupting != false;
              if (is(node, "bpmn:BoundaryEvent")) return node.cancelActivity != false;
              return false;
            },
            isEmbeddedSubprocess: subprocessId => {
              return globalControlFlowInfoMap.get(subprocessId).isEmbedded;
            },
            isBoundaryEvent: evtId => {
              return controlFlowInfo.boundaryEvents.indexOf(evtId) >= 0;
            },
            preMarking: nodeId => {
              let node = globalNodeMap.get(nodeId);
              let bitarray = [];
              if (node.incoming) for (let incoming of node.incoming) bitarray[controlFlowInfo.edgeIndexMap.get(incoming.id)] = 1;else bitarray[0] = 1;
              let result = "0b";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            postMarking: nodeId => {
              let node = globalNodeMap.get(nodeId);
              let bitarray = [];
              let result = "0b";
              if (node.outgoing) for (let outgoing of node.outgoing) {
                bitarray[controlFlowInfo.edgeIndexMap.get(outgoing.id)] = 1;
              } else result = "0";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            subprocessNodeMarking: subprocessId => {
              let bitarray = [];
              globalNodeMap.forEach(node => {
                if (node.$parent && node.$parent.id === subprocessId) {
                  if (is(node, "bpmn:Task") || is(node, 'bpmn:SubProcess')) bitarray[globalNodeIndexMap.get(node.id)] = 1;else if (!globalNodeMap.get(subprocessId).triggeredByEvent && node.eventDefinitions && node.eventDefinitions[0] && is(node.eventDefinitions[0], "bpmn:MessageEventDefinition")) bitarray[globalNodeIndexMap.get(node.id)] = 1;
                }
              });
              let result = bitarray.length > 0 ? "0b" : 0;

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            subprocessNodeFullMarking: subprocId => {
              let children = [subprocId];
              let bitarray = [];
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (is(node, "bpmn:SubProcess") || callActivities.indexOf(node.id) >= 0 || nonInterruptingEvents.indexOf(node.id) >= 0 && !is(node, "bpmn:StartEvent")) {
                  while (node.$parent) {
                    if (node.$parent.id === subprocId) {
                      if (multiinstanceActivities.indexOf(nodeId) >= 0 || callActivities.indexOf(node.id) >= 0 || nonInterruptingEvents.indexOf(node.id) >= 0) {
                        bitarray[globalNodeIndexMap.get(nodeId)] = 1;
                      } else if (children.indexOf(nodeId) < 0) {
                        children.push(nodeId);
                      }

                      break;
                    }

                    node = node.$parent;
                  }
                }
              });
              let result = "0b";
              if (globalNodeIndexMap.get(subprocId)) bitarray[globalNodeIndexMap.get(subprocId)] = 1;
              controlFlowInfo.nodeList.map(nodeId => globalNodeMap.get(nodeId)).forEach(node => {
                if (node.$parent && children.indexOf(node.$parent.id) >= 0) {
                  bitarray[globalNodeIndexMap.get(node.id)] = 1;
                }
              });
              catchingMessages.map(evtId => globalNodeMap.get(evtId)).forEach(evt => {
                if (evt.attachedToRef && children.indexOf(evt.attachedToRef) >= 0) {
                  bitarray[globalNodeIndexMap.get(evt.id)] = 1;
                }
              });

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return result === '0b' ? new _bignumber.default(0) : new _bignumber.default(result).toFixed();
            },
            subprocessStartMarking: subprocessId => {
              let toSearch = globalNodeMap.get(subprocessId);
              let bitarray = [];
              let result = "0b";

              if (is(toSearch, "bpmn:BoundaryEvent")) {
                for (let outgoing of toSearch.outgoing) bitarray[controlFlowInfo.edgeIndexMap.get(outgoing.id)] = 1;
              } else {
                for (let node of toSearch.flowElements.filter(e => is(e, "bpmn:FlowNode") && is(e, "bpmn:StartEvent"))) {
                  if (node.$parent.id === subprocessId) if (!globalNodeMap.get(node.$parent.id).triggeredByEvent && node.eventDefinitions && node.eventDefinitions[0] && is(node.eventDefinitions[0], "bpmn:MessageEventDefinition")) bitarray[0] = 1;else if (node.outgoing) for (let outgoing of node.outgoing) bitarray[controlFlowInfo.edgeIndexMap.get(outgoing.id)] = 1;
                }
              }

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            getAllAncestorsMask: subprocId => {
              let bitarray = [];
              let result = "0b";
              let node = globalNodeMap.get(subprocId);

              while (node.$parent) {
                bitarray[controlFlowInfo.nodeIndexMap.get(node.id)] = 1;
                node = node.$parent;
              }

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            subprocessMarking: subprocessId => {
              let bitarray = [];
              let result = "0b";
              let localInfo = globalControlFlowInfoMap.get(subprocessId);
              let edgeList = [];
              localInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (node.$parent && node.$parent.id === subprocessId && node.incoming) {
                  for (let incoming of node.incoming) {
                    edgeList.push(incoming.id);
                  }
                }
              });
              edgeList.forEach(edgeId => {
                bitarray[controlFlowInfo.edgeIndexMap.get(edgeId)] = 1;
              });

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            subprocessFullMarking: subprocId => {
              let bitarray = [];
              let result = "0b";
              let children = [subprocId];
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (is(node, "bpmn:SubProcess") && multiinstanceActivities.indexOf(nodeId) < 0) {
                  while (node.$parent) {
                    if (node.$parent.id === subprocId) {
                      if (children.indexOf(nodeId) < 0) children.push(nodeId);
                      break;
                    }

                    node = node.$parent;
                  }
                }
              });
              children.forEach(subprocessId => {
                let localInfo = globalControlFlowInfoMap.get(subprocessId);
                localInfo.edgeList.forEach(edgeId => {
                  bitarray[controlFlowInfo.edgeIndexMap.get(edgeId)] = 1;
                });
              });

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            flowEdgeIndex: flowEdgeId => {
              let bitarray = [];
              bitarray[controlFlowInfo.edgeIndexMap.get(flowEdgeId)] = 1;
              let result = "0b";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            flowNodeIndex: flowNodeId => {
              let bitarray = [];
              bitarray[globalNodeIndexMap.get(flowNodeId)] = 1;
              let result = "0b";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            nodeRealIndex: nodeId => {
              return globalNodeIndexMap.get(nodeId);
            },
            isPartOfDeferredChoice: eventId => {
              let event = globalNodeMap.get(eventId);

              if (event.incoming) {
                let node = event.incoming[0].sourceRef;
                return is(node, "bpmn:EventBasedGateway");
              }

              return false;
            },
            getDeferredChoiceElements: nodeId => {
              let event = globalNodeMap.get(nodeId);
              let res = [];

              if (event.incoming) {
                let node = event.incoming[0].sourceRef;

                if (is(node, "bpmn:EventBasedGateway")) {
                  for (let outgoing of node.outgoing) {
                    if (outgoing.targetRef.id !== nodeId) res.push(outgoing.targetRef.id);
                  }
                }
              }

              return res;
            },
            deferredChoiceNodeMarking: nodeId => {
              let event = globalNodeMap.get(nodeId);
              let bitarray = [];

              if (event.incoming) {
                let node = event.incoming[0].sourceRef;

                if (is(node, "bpmn:EventBasedGateway")) {
                  for (let outgoing of node.outgoing) {
                    bitarray[controlFlowInfo.nodeIndexMap.get(outgoing.targetRef.id)] = 1;
                  }
                }
              }

              let result = "0";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            deferredChoiceMarking: eventId => {
              let event = globalNodeMap.get(eventId);
              let node = event.incoming[0].sourceRef;
              let bitarray = [];
              let result = "0b";
              if (node.outgoing) for (let outgoing of node.outgoing) {
                bitarray[controlFlowInfo.edgeIndexMap.get(outgoing.id)] = 1;
              } else result = "0";

              for (let i = bitarray.length - 1; i >= 0; i--) result += bitarray[i] ? "1" : "0";

              return new _bignumber.default(result).toFixed();
            },
            globalDeclarations: () => {
              if (controlFlowInfo.globalParameters.length > 0) return controlFlowInfo.globalParameters;else return "";
            },
            getOracleFunction: nodeId => {
              if (controlFlowInfo.oracleTaskMap.has(nodeId)) return controlFlowInfo.oracleInfo.get(controlFlowInfo.oracleTaskMap.get(nodeId)).functionName;
              return "";
            },
            nodeParameters: nodeId => {
              let node = globalNodeMap.get(nodeId);

              if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0) {
                let resDict = extractParameters(node.documentation[0].text, nodeId, null);
                return resDict !== undefined ? resDict.get("input").length > 0 || resDict.get("output").length > 0 : false;
              }

              return false;
            },
            typeParameters: (nodeId, isInput, hasPreviousParameter) => {
              let node = globalNodeMap.get(nodeId);
              let res = "";

              if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0 && extractParameters(node.documentation[0].text, nodeId, null) !== undefined) {
                let localParams = isInput ? extractParameters(node.documentation[0].text, nodeId, null).get("input") : extractParameters(node.documentation[0].text, nodeId, null).get("output");

                if (localParams.length > 0) {
                  res = localParams[0];

                  for (let i = 2; i < localParams.length; i += 2) res += ", " + localParams[i];
                }
              }

              return hasPreviousParameter && res.length > 0 ? ", " + res : res;
            },
            concatParameters: (nodeId, isInput, hasType, hasPreviousParameter) => {
              let node = globalNodeMap.get(nodeId);
              let res = "";

              if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0 && extractParameters(node.documentation[0].text, nodeId, null) !== undefined) {
                let localParams = isInput ? extractParameters(node.documentation[0].text, nodeId, null).get("input") : extractParameters(node.documentation[0].text, nodeId, null).get("output");

                if (localParams.length > 0) {
                  res = hasType ? localParams[0] + " " + localParams[1] : localParams[1];

                  for (let i = 2; i < localParams.length; i += 2) res += "," + (hasType ? localParams[i] + " " + localParams[i + 1] : localParams[i + 1]);
                }
              }

              return hasPreviousParameter && res.length > 0 ? ", " + res : res;
            },
            nodeFunctionBody: nodeId => {
              let node = globalNodeMap.get(nodeId);

              if (node.script) {
                return node.script.split("->");
              } else if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0 && extractParameters(node.documentation[0].text, nodeId, null) !== undefined) {
                return extractParameters(node.documentation[0].text, nodeId, null).get("body");
              } else return "";
            },
            getCondition: flowEdge => flowEdge.conditionExpression ? flowEdge.conditionExpression.body : flowEdge.name ? flowEdge.name : flowEdge.id,
            is: is
          };
          let localSolidity = bpmn2solTemplate(codeGenerationInfo); // Code for using the WorkList template

          let userTaskList = [];
          let parameterInfo = new Map();
          controlFlowInfo.nodeList.forEach(nodeId => {
            let node = globalNodeMap.get(nodeId);

            if (is(node, 'bpmn:UserTask') || is(node, 'bpmn:ReceiveTask')) {
              userTaskList.push(nodeId);

              if (controlFlowInfo.localParameters.has(nodeId) && (controlFlowInfo.localParameters.get(nodeId).get('input').length > 0 || controlFlowInfo.localParameters.get(nodeId).get('output').length > 0)) {
                parameterInfo.set(nodeId, controlFlowInfo.localParameters.get(nodeId));
              }
            }
          });
          if (controlFlowInfo.catchingMessages.length > 0) userTaskList = userTaskList.concat(controlFlowInfo.catchingMessages); // WorkList: Smart Contract Generation

          let workListGenerationInfo = {
            nodeList: userTaskList,
            restrictRelation: restrictRelation,
            parameterInfo: parameterInfo,
            nodeIndex: globalNodeIndexMap,
            nodeMap: globalNodeMap,
            processId: () => controlFlowInfo.self.id,
            nodeName: nodeId => {
              return getNodeName(globalNodeMap.get(nodeId));
            },
            getParameterType: (nodeId, isInput, isType, hasPrevious) => {
              let res = "";

              if (parameterInfo.get(nodeId)) {
                let localParams = isInput ? parameterInfo.get(nodeId).get("input") : parameterInfo.get(nodeId).get("output");

                if (localParams && localParams.length > 0) {
                  res = isType ? localParams[0].type : localParams[0].name;

                  for (let i = 1; i < localParams.length; i++) res += isType ? ", " + localParams[i].type : ", " + localParams[i].name;
                }
              }

              return res.length > 0 && hasPrevious ? ", " + res : res;
            },
            getParameters: (nodeId, isInput, hasType, hasPrevious) => {
              let res = "";

              if (parameterInfo.get(nodeId)) {
                let localParams = isInput ? parameterInfo.get(nodeId).get("input") : parameterInfo.get(nodeId).get("output");

                if (localParams && localParams.length > 0) {
                  res = hasType ? localParams[0].type + " " + localParams[0].name : localParams[0].name;

                  for (let i = 1; i < localParams.length; i++) res += hasType ? ", " + localParams[i].type + " " + localParams[i].name : ", " + localParams[i].name;
                }
              }

              return res.length > 0 && hasPrevious ? ", " + res : res;
            },
            getWorkItemsGroupByParameters: isInput => {
              let name2Ids = new Map();
              controlFlowInfo.nodeList.forEach(nodeId => {
                let node = globalNodeMap.get(nodeId);

                if (is(node, 'bpmn:UserTask') || is(node, 'bpmn:ReceiveTask') || catchingMessages.indexOf(nodeId) >= 0) {
                  let params = "";

                  if (node.documentation && node.documentation[0].text && node.documentation[0].text.length > 0 && extractParameters(node.documentation[0].text, nodeId, null) !== undefined) {
                    let localParams = isInput ? extractParameters(node.documentation[0].text, nodeId, null).get("input") : extractParameters(node.documentation[0].text, nodeId, null).get("output");

                    if (localParams.length > 0) {
                      params = localParams[0];

                      for (let i = 2; i < localParams.length; i += 2) params += localParams[i];
                    }
                  }

                  let name = getNodeName(globalNodeMap.get(nodeId)) + params;

                  if (!name2Ids.has(name)) {
                    name2Ids.set(name, []);
                  }

                  name2Ids.get(name).push(nodeId);
                }
              });
              return name2Ids;
            },
            is: is
          };
          modelInfo.solidity += localSolidity;

          if (userTaskList.length > 0) {
            modelInfo.solidity += workList2solTemplate(workListGenerationInfo);
          }

          modelInfo.controlFlowInfoMap.set(controlFlowInfo.self.id, controlFlowInfo);
        } else {
          controlFlowInfo.nodeList.forEach(nodeId => controlFlowInfo.nodeIndexMap.set(nodeId, globalNodeIndexMap.get(nodeId)));
          controlFlowInfo.edgeList.forEach(edgeId => controlFlowInfo.edgeIndexMap.set(edgeId, globalEdgeIndexMap.get(edgeId)));
        }
      } //////////////////////////////////////////////////////////////////////////////////


      modelInfo.entryContractName = modelInfo.name + ":" + (proc.name ? proc.name.replace(/\s+/g, "_") : proc.id) + "_Contract";
      resolve();
    }).catch(err => {
      throw new Error(err);
      reject();
    });
  });
};

var _default = parseModel;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2FwcC9yZXNvbHZlcnMvbXV0YXRpb24vbW9kZWwvcGFyc2UtbW9kZWwudHMiXSwibmFtZXMiOlsiZGVidWciLCJicG1uMnNvbFRlbXBsYXRlIiwiZWpzIiwiY29tcGlsZSIsImJwbW4yc29sRUpTIiwid29ya0xpc3Qyc29sVGVtcGxhdGUiLCJ3b3JrTGlzdDJzb2xFSlMiLCJtb2RkbGUiLCJCcG1uTW9kZGxlIiwicGFyc2VCcG1uIiwiYnBtbkRvYyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnJvbVhNTCIsImVyciIsImRlZmluaXRpb25zIiwiaXMiLCJlbGVtZW50IiwidHlwZSIsIiRpbnN0YW5jZU9mIiwiY29sbGVjdENvbnRyb2xGbG93SW5mbyIsInByb2MiLCJnbG9iYWxOb2RlTWFwIiwiZ2xvYmFsQ29udHJvbEZsb3dJbmZvIiwibm9kZUxpc3QiLCJlZGdlTGlzdCIsImJvdW5kYXJ5RXZlbnRzIiwibm9uQmxvY2tpbmdCb3VuZGFyeUV2ZW50cyIsImNvbnRyb2xGbG93SW5mbyIsIm5vZGUiLCJmbG93RWxlbWVudHMiLCJmaWx0ZXIiLCJlIiwicHVzaCIsImlkIiwiY2FuY2VsQWN0aXZpdHkiLCJzZXQiLCJzb3VyY2VzIiwiZmxvd0VkZ2UiLCJpbmRleE9mIiwidGFyZ2V0UmVmIiwic3BsaWNlIiwibGVuZ3RoIiwiZGZzIiwib3BlbiIsImN1cnJJZCIsInBvcCIsImN1cnIiLCJnZXQiLCJvdXRnb2luZyIsInN1Y2NFZGdlIiwic3VjYyIsIm1haW5QYXRoTm9kZUxpc3QiLCJtYWluUGF0aEVkZ2VMaXN0IiwibG9jYWxCb3VuZGFyeSIsImZvckVhY2giLCJldnRJZCIsImJvdW5kYXJ5Tm9kZVBhdGgiLCJib3VuZGFyeUVkZ2VQYXRoIiwiY29uY2F0IiwiQ29udHJvbEZsb3dJbmZvIiwiZXZlbnRJZCIsImV2ZW50IiwiZmluZCIsImF0dGFjaGVkVG9SZWYiLCJFcnJvciIsImxvY2FsTm9kZUxpc3QiLCJsb2NhbEVkZ2VMaXN0Iiwibm9kZUlkIiwiY2hpbGRDb250cm9sRmxvd0luZm8iLCJwYXJlbnQiLCJzdWJwcm9jZXNzIiwic3VicHJvY2Vzc0NvbnRyb2xGbG93SW5mbyIsImxvb3BDaGFyYWN0ZXJpc3RpY3MiLCIkdHlwZSIsImlzRW1iZWRkZWQiLCJkb2N1bWVudGF0aW9uIiwiZ2xvYmFsUGFyYW1ldGVycyIsInRleHQiLCJyZXN0cmljdFJlbGF0aW9uIiwiTWFwIiwiZXh0cmFjdFBhcmFtZXRlcnMiLCJjYWQiLCJhcnIiLCJzcGxpdCIsInRhc2tSb2xlTWFwIiwidHJpbSIsInVuZGVmaW5lZCIsIm9yYWNsZV9EYXRhIiwiaiIsImZpcnN0IiwiY2hhckF0Iiwic3Vic3RyIiwicmVwbGFjZSIsImZpcnN0U3BsaXQiLCJhdXgiLCJpIiwic2Vjb25kU3BsaXQiLCJyZXNNYXAiLCJpbnB1dE91dHB1dCIsInBhcmFtZXRlclR5cGUiLCJ0ZW1wIiwicmVzIiwic3ViQ2FkIiwiaW5QYXJhbWV0ZXJzIiwib3V0UGFyYW1ldGVycyIsInRvSXRlcmF0ZSIsIlBhcmFtZXRlckluZm8iLCJwYXJhbWV0ZXJzIiwic3BsaXRSZXN1bHQiLCJvcmFjbGVJbmZvIiwiaGFzIiwiT3JhY2xlSW5mbyIsIm9yYWNsZVRhc2tNYXAiLCJsb2NhbE9yYWNsZSIsImFkZHJlc3MiLCJmdW5jdGlvbk5hbWUiLCJmdW5jdGlvblBhcmFtZXRlcnMiLCJsb2NhbFBhcmFtZXRlcnMiLCJnZXROb2RlTmFtZSIsIm5hbWUiLCJwYXJzZU1vZGVsIiwibW9kZWxJbmZvIiwiYnBtbiIsInRoZW4iLCJzb2xpZGl0eSIsImNvbnRyb2xGbG93SW5mb01hcCIsImRpYWdyYW1zIiwicGxhbmUiLCJicG1uRWxlbWVudCIsInJvb3RFbGVtZW50cyIsImdsb2JhbE5vZGVJbmRleE1hcCIsImdsb2JhbEVkZ2VJbmRleE1hcCIsIm1haW5Db250cm9sRmxvd0luZm8iLCJnbG9iYWxDb250cm9sRmxvd0luZm9NYXAiLCJzZWxmIiwiaW5kZXhlc1RvUmVtb3ZlIiwidHJpZ2dlcmVkQnlFdmVudCIsIm5vZGVJbmZvIiwiaXNJbnRlcnJ1cHRpbmciLCJjaGlsZElkIiwiaW5kZXgiLCJzb3J0IiwiaW5kMSIsImluZDIiLCJoYXNFeHRlcm5hbENhbGwiLCJtdWx0aWluc3RhbmNlQWN0aXZpdGllcyIsImNhbGxBY3Rpdml0aWVzIiwibm9uSW50ZXJydXB0aW5nRXZlbnRzIiwiY2F0Y2hpbmdNZXNzYWdlcyIsIm1hcCIsImV2ZW50RGVmaW5pdGlvbnMiLCJzdGFydCIsIiRwYXJlbnQiLCJwYXJ0MSIsInBhcnQyIiwibm9kZUluZGV4TWFwIiwibm9kZU5hbWVNYXAiLCJleHRlcm5hbEJ1bmRsZXMiLCJlZGdlSWQiLCJlZGdlSW5kZXhNYXAiLCJjb2RlR2VuZXJhdGlvbkluZm8iLCJub2RlTWFwIiwicHJvY2Vzc0lkIiwibm9kZU5hbWUiLCJldmVudFR5cGUiLCJzdWJzdHJpbmciLCJhbGxFdmVudFR5cGVzIiwidGFrZW4iLCJnZXRNZXNzYWdlcyIsImNhbmRpZGF0ZXMiLCJzdWJQIiwiZXZ0IiwiZ2V0VGhyb3dpbmdNZXNzYWdlcyIsImdldFRocm93aW5nRXZlbnRzIiwic3VicHJvY0lkIiwiZXZUeXBlIiwiZ2V0Q2F0Y2hpbmdFdmVudHMiLCJ1bnNoaWZ0IiwiZ2V0VGVybWluYXRlQ2FuZGlkYXRlcyIsImxvY2FsQyIsImVsZW1JZCIsImVsZW0iLCJnZXRQcm9jZXNzQ2FuZGlkYXRlc01hc2tGcm9tIiwiZXZ0VHlwZSIsImV2dENvZGUiLCJzb3VyY2VQcm9jZXNzZXMiLCJhbGxFdmVudHMiLCJldmVudExpc3QiLCJiaXRhcnJheSIsInByb2NJZCIsInByZXZpb3VzUGFyZW50IiwiZXZlbnRGb3VuZCIsInJlc3VsdCIsIkJpZ051bWJlciIsInRvRml4ZWQiLCJnZXRDYXRjaGluZ0V2ZW50c0Zyb20iLCJnZXRXb3JrSXRlbXNHcm91cEJ5UGFyYW1ldGVycyIsImlzSW5wdXQiLCJuYW1lMklkcyIsInBhcmFtcyIsImxvY2FsUGFyYW1zIiwiZ2V0Q29udHJhY3RzMkNhbGwiLCJnZXRDb250cmFjdHMyQ2FsbEZyb20iLCJnZXRDb250cmFjdHMyQ2FsbE1hc2tGcm9tIiwiZ2V0Q29udHJhY3RzMkNhbGxBcnJheSIsImdldFBvc3NpYmxlS2lsbFN1YnByb2Nlc3MiLCJhdHRhY2hlZFRvIiwiZ2V0Q291bnRFeHRlcm5hbFRhc2tzIiwiZ2V0U3RhcnRlZE1lc3NhZ2VzIiwiZ2V0UGFyZW50IiwiZ2V0Q29udHJhY3ROYW1lIiwiZ2V0QWxsQ2hpbGRyZW4iLCJkaXJlY3QiLCJpc1N0YXJ0aW5nQ29udHJhY3RFdmVudCIsImlzRW1iZWRkZWRTdWJwcm9jZXNzIiwic3VicHJvY2Vzc0lkIiwiaXNCb3VuZGFyeUV2ZW50IiwicHJlTWFya2luZyIsImluY29taW5nIiwicG9zdE1hcmtpbmciLCJzdWJwcm9jZXNzTm9kZU1hcmtpbmciLCJzdWJwcm9jZXNzTm9kZUZ1bGxNYXJraW5nIiwiY2hpbGRyZW4iLCJzdWJwcm9jZXNzU3RhcnRNYXJraW5nIiwidG9TZWFyY2giLCJnZXRBbGxBbmNlc3RvcnNNYXNrIiwic3VicHJvY2Vzc01hcmtpbmciLCJsb2NhbEluZm8iLCJzdWJwcm9jZXNzRnVsbE1hcmtpbmciLCJmbG93RWRnZUluZGV4IiwiZmxvd0VkZ2VJZCIsImZsb3dOb2RlSW5kZXgiLCJmbG93Tm9kZUlkIiwibm9kZVJlYWxJbmRleCIsImlzUGFydE9mRGVmZXJyZWRDaG9pY2UiLCJzb3VyY2VSZWYiLCJnZXREZWZlcnJlZENob2ljZUVsZW1lbnRzIiwiZGVmZXJyZWRDaG9pY2VOb2RlTWFya2luZyIsImRlZmVycmVkQ2hvaWNlTWFya2luZyIsImdsb2JhbERlY2xhcmF0aW9ucyIsImdldE9yYWNsZUZ1bmN0aW9uIiwibm9kZVBhcmFtZXRlcnMiLCJyZXNEaWN0IiwidHlwZVBhcmFtZXRlcnMiLCJoYXNQcmV2aW91c1BhcmFtZXRlciIsImNvbmNhdFBhcmFtZXRlcnMiLCJoYXNUeXBlIiwibm9kZUZ1bmN0aW9uQm9keSIsInNjcmlwdCIsImdldENvbmRpdGlvbiIsImNvbmRpdGlvbkV4cHJlc3Npb24iLCJib2R5IiwibG9jYWxTb2xpZGl0eSIsInVzZXJUYXNrTGlzdCIsInBhcmFtZXRlckluZm8iLCJ3b3JrTGlzdEdlbmVyYXRpb25JbmZvIiwibm9kZUluZGV4IiwiZ2V0UGFyYW1ldGVyVHlwZSIsImlzVHlwZSIsImhhc1ByZXZpb3VzIiwiZ2V0UGFyYW1ldGVycyIsImVudHJ5Q29udHJhY3ROYW1lIiwiY2F0Y2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFHQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7QUFTQSxNQUFNQSxLQUFLLEdBQUcscUJBQU8sMkJBQVAsQ0FBZDtBQUVBLE1BQU1DLGdCQUFnQixHQUFHQyxHQUFHLENBQUNDLE9BQUosQ0FBWUMsV0FBWixDQUF6QjtBQUVBLE1BQU1DLG9CQUFvQixHQUFHSCxHQUFHLENBQUNDLE9BQUosQ0FBWUcsZUFBWixDQUE3QjtBQUVBLElBQUlDLE1BQU0sR0FBRyxJQUFJQyxtQkFBSixFQUFiOztBQUNBLElBQUlDLFNBQVMsR0FBR0MsT0FBTyxJQUFJO0FBQ3ZCLFNBQU8sSUFBSUMsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUNwQ04sSUFBQUEsTUFBTSxDQUFDTyxPQUFQLENBQWVKLE9BQWYsRUFBd0IsQ0FBQ0ssR0FBRCxFQUFNQyxXQUFOLEtBQXNCO0FBQzFDLFVBQUksQ0FBQ0QsR0FBTCxFQUFVSCxPQUFPLENBQUNJLFdBQUQsQ0FBUCxDQUFWLEtBQ0tILE1BQU0sQ0FBQ0UsR0FBRCxDQUFOO0FBQ1IsS0FIRDtBQUlILEdBTE0sQ0FBUDtBQU1ILENBUEQ7O0FBU0EsSUFBSUUsRUFBRSxHQUFHLENBQUNDLE9BQUQsRUFBVUMsSUFBVixLQUFtQkQsT0FBTyxDQUFDRSxXQUFSLENBQW9CRCxJQUFwQixDQUE1Qjs7QUFDQSxJQUFJRSxzQkFBSjs7QUFDQUEsc0JBQXNCLEdBQUcsQ0FBQ0MsSUFBRCxFQUNDQyxhQURELEVBRUNDLHFCQUZELEtBRW9FO0FBQ3pGLE1BQUlDLFFBQXVCLEdBQUcsRUFBOUI7QUFDQSxN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SW1ELEtBQUosQ0FBVW5ELEdBQVYsQ0FBTjtBQUNBRixNQUFBQSxNQUFNO0FBQ1QsS0F6L0JMO0FBMC9CSCxHQTMvQk0sQ0FBUDtBQTQvQkgsQ0E3L0JEOztlQSsvQmU2RyxVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWJ1ZyBmcm9tICdkZWJ1ZydcbmltcG9ydCBCcG1uTW9kZGxlIGZyb20gXCJicG1uLW1vZGRsZVwiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyBlanMgZnJvbSBcImVqc1wiO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XG5pbXBvcnQge1xuICAgIENvbnRyb2xGbG93SW5mbyxcbiAgICBNb2RlbEluZm8sXG4gICAgUGFyYW1ldGVySW5mbyxcbiAgICBPcmFjbGVJbmZvXG59IGZyb20gXCIuL2RlZmluaXRpb25zXCI7XG5pbXBvcnQgYnBtbjJzb2xFSlMgZnJvbSAnLi4vLi4vLi4vdGVtcGxhdGVzL2JwbW4yc29sLmVqcycgXG5pbXBvcnQgd29ya0xpc3Qyc29sRUpTIGZyb20gJy4uLy4uLy4uL3RlbXBsYXRlcy93b3JrTGlzdDJzb2wuZWpzJyBcblxuY29uc3QgZGVidWcgPSBfZGVidWcoJ2NhdGVycGlsbGFycWw6cGFyc2UtbW9kZWwnKVxuXG5jb25zdCBicG1uMnNvbFRlbXBsYXRlID0gZWpzLmNvbXBpbGUoYnBtbjJzb2xFSlMpO1xuXG5jb25zdCB3b3JrTGlzdDJzb2xUZW1wbGF0ZSA9IGVqcy5jb21waWxlKHdvcmtMaXN0MnNvbEVKUyk7XG5cbmxldCBtb2RkbGUgPSBuZXcgQnBtbk1vZGRsZSgpO1xubGV0IHBhcnNlQnBtbiA9IGJwbW5Eb2MgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIG1vZGRsZS5mcm9tWE1MKGJwbW5Eb2MsIChlcnIsIGRlZmluaXRpb25zKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycikgcmVzb2x2ZShkZWZpbml0aW9ucyk7XG4gICAgICAgICAgICBlbHNlIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbmxldCBpcyA9IChlbGVtZW50LCB0eXBlKSA9PiBlbGVtZW50LiRpbnN0YW5jZU9mKHR5cGUpO1xubGV0IGNvbGxlY3RDb250cm9sRmxvd0luZm86IChwcm9jOiBhbnksIGdsb2JhbE5vZGVNYXA6IE1hcDxzdHJpbmcsIGFueT4sIGdsb2JhbENvbnRyb2xGbG93SW5mbzogQXJyYXk8Q29udHJvbEZsb3dJbmZvPikgPT4gQ29udHJvbEZsb3dJbmZvO1xuY29sbGVjdENvbnRyb2xGbG93SW5mbyA9IChwcm9jOiBhbnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbE5vZGVNYXA6IE1hcDxzdHJpbmcsIGFueT4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbENvbnRyb2xGbG93SW5mbzogQXJyYXk8Q29udHJvbEZsb3dJbmZvPik6IENvbnRyb2xGbG93SW5mbyA9PiB7XG4gICAgbGV0IG5vZGVMaXN0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgbGV0IGVkZ2VMaXN0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgbGV0IGJvdW5kYXJ5RXZlbnRzOiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgbGV0IG5vbkJsb2NraW5nQm91bmRhcnlFdmVudHM6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICBsZXQgY29udHJvbEZsb3dJbmZvOiBDb250cm9sRmxvd0luZm87XG5cbiAgICBmb3IgKGxldCBub2RlIG9mIHByb2MuZmxvd0VsZW1lbnRzLmZpbHRlcihlID0+IGlzKGUsIFwiYnBtbjpGbG93Tm9kZVwiKSkpIHtcbiAgICAgICAgaWYgKGlzKG5vZGUsIFwiYnBtbjpCb3VuZGFyeUV2ZW50XCIpKSB7XG4gICAgICAgICAgICBib3VuZGFyeUV2ZW50cy5wdXNoKG5vZGUuaWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2FuY2VsQWN0aXZpdHkgPT0gZmFsc2UpIG5vbkJsb2NraW5nQm91bmRhcnlFdmVudHMucHVzaChub2RlLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVMaXN0LnB1c2gobm9kZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsTm9kZU1hcC5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgfVxuXG4gICAgbGV0IHNvdXJjZXMgPSBbLi4ubm9kZUxpc3RdO1xuXG4gICAgZm9yIChsZXQgZmxvd0VkZ2Ugb2YgcHJvYy5mbG93RWxlbWVudHMuZmlsdGVyKGUgPT5cbiAgICAgICAgaXMoZSwgXCJicG1uOlNlcXVlbmNlRmxvd1wiKVxuICAgICkpIHtcbiAgICAgICAgaWYgKHNvdXJjZXMuaW5kZXhPZihmbG93RWRnZS50YXJnZXRSZWYuaWQpID4gLTEpIHtcbiAgICAgICAgICAgIHNvdXJjZXMuc3BsaWNlKHNvdXJjZXMuaW5kZXhPZihmbG93RWRnZS50YXJnZXRSZWYuaWQpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlZGdlTGlzdC5wdXNoKGZsb3dFZGdlLmlkKTtcbiAgICB9XG5cbiAgICAvLyBMZXQgdXMgcmVtb3ZlIGFsbCBzb3VyY2UgZWxlbWVudHMgZnJvbSB0aGUgbm9kZSBsaXN0XG4gICAgbm9kZUxpc3QgPSBub2RlTGlzdC5maWx0ZXIoKG5vZGU6IHN0cmluZykgPT4gc291cmNlcy5pbmRleE9mKG5vZGUpIDwgMCk7XG5cbiAgICBpZiAobm9uQmxvY2tpbmdCb3VuZGFyeUV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBkZnMgPSAoc291cmNlczogc3RyaW5nW10pID0+IHtcbiAgICAgICAgICAgIGxldCBvcGVuID0gWy4uLnNvdXJjZXNdO1xuICAgICAgICAgICAgbGV0IG5vZGVMaXN0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgICAgICBsZXQgZWRnZUxpc3Q6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChvcGVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycklkID0gb3Blbi5wb3AoKTtcbiAgICAgICAgICAgICAgICBsZXQgY3VyciA9IGdsb2JhbE5vZGVNYXAuZ2V0KGN1cnJJZCk7XG4gICAgICAgICAgICAgICAgbm9kZUxpc3QucHVzaChjdXJySWQpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyLm91dGdvaW5nICYmIGN1cnIub3V0Z29pbmcubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3VjY0VkZ2Ugb2YgY3Vyci5vdXRnb2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1Y2MgPSBzdWNjRWRnZS50YXJnZXRSZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlTGlzdC5wdXNoKHN1Y2NFZGdlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVuLmluZGV4T2Yoc3VjYy5pZCkgPCAwICYmIG5vZGVMaXN0LmluZGV4T2Yoc3VjYy5pZCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4ucHVzaChzdWNjLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtub2RlTGlzdCwgZWRnZUxpc3RdO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgW21haW5QYXRoTm9kZUxpc3QsIG1haW5QYXRoRWRnZUxpc3RdID0gZGZzKHNvdXJjZXMpO1xuICAgICAgICBsZXQgbG9jYWxCb3VuZGFyeSA9IFtdO1xuICAgICAgICBib3VuZGFyeUV2ZW50cy5mb3JFYWNoKGV2dElkID0+IHtcbiAgICAgICAgICAgIGlmIChub25CbG9ja2luZ0JvdW5kYXJ5RXZlbnRzLmluZGV4T2YoZXZ0SWQpIDwgMClcbiAgICAgICAgICAgICAgICBsb2NhbEJvdW5kYXJ5LnB1c2goZXZ0SWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxvY2FsQm91bmRhcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IFtib3VuZGFyeU5vZGVQYXRoLCBib3VuZGFyeUVkZ2VQYXRoXSA9IGRmcyhsb2NhbEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIGJvdW5kYXJ5Tm9kZVBhdGggPSBib3VuZGFyeU5vZGVQYXRoLmZpbHRlcihcbiAgICAgICAgICAgICAgICAobm9kZTogc3RyaW5nKSA9PiBsb2NhbEJvdW5kYXJ5LmluZGV4T2Yobm9kZSkgPCAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFpblBhdGhOb2RlTGlzdCA9IG1haW5QYXRoTm9kZUxpc3QuY29uY2F0KGJvdW5kYXJ5Tm9kZVBhdGgpO1xuICAgICAgICAgICAgbWFpblBhdGhFZGdlTGlzdCA9IG1haW5QYXRoRWRnZUxpc3QuY29uY2F0KGJvdW5kYXJ5RWRnZVBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGV0IHVzIHJlbW92ZSBhbGwgc291cmNlIGVsZW1lbnRzIGZyb20gdGhlIG5vZGUgbGlzdFxuICAgICAgICBtYWluUGF0aE5vZGVMaXN0ID0gbWFpblBhdGhOb2RlTGlzdC5maWx0ZXIoKG5vZGU6IHN0cmluZykgPT4gc291cmNlcy5pbmRleE9mKG5vZGUpIDwgMCk7XG5cbiAgICAgICAgY29udHJvbEZsb3dJbmZvID0gbmV3IENvbnRyb2xGbG93SW5mbyhcbiAgICAgICAgICAgIHByb2MsXG4gICAgICAgICAgICBtYWluUGF0aE5vZGVMaXN0LFxuICAgICAgICAgICAgbWFpblBhdGhFZGdlTGlzdCxcbiAgICAgICAgICAgIHNvdXJjZXMsXG4gICAgICAgICAgICBib3VuZGFyeUV2ZW50c1xuICAgICAgICApO1xuICAgICAgICBnbG9iYWxDb250cm9sRmxvd0luZm8ucHVzaChjb250cm9sRmxvd0luZm8pO1xuICAgICAgICBmb3IgKGxldCBldmVudElkIG9mIG5vbkJsb2NraW5nQm91bmRhcnlFdmVudHMpIHtcbiAgICAgICAgICAgIGxldCBldmVudCA9IGdsb2JhbE5vZGVNYXAuZ2V0KGV2ZW50SWQpO1xuICAgICAgICAgICAgaWYgKCFtYWluUGF0aE5vZGVMaXN0LmZpbmQoKGU6IHN0cmluZykgPT4gZXZlbnQuYXR0YWNoZWRUb1JlZi5pZCA9PT0gZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRVJST1I6IEZvdW5kIG5vbi1pbnRlcnJ1cHRpbmcgZXZlbnQgd2hpY2ggaXMgbm90IGF0dGFjaGVkIHRvIGEgc3VicHJvY2VzcyBpbiB0aGUgbWFpbiBwcm9jZXNzIHBhdGhcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBbbG9jYWxOb2RlTGlzdCwgbG9jYWxFZGdlTGlzdF0gPSBkZnMoW2V2ZW50SWRdKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBtYWluUGF0aE5vZGVMaXN0LmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgKG5vZGVJZDogc3RyaW5nKSA9PiBsb2NhbE5vZGVMaXN0LmluZGV4T2Yobm9kZUlkKSA+PSAwXG4gICAgICAgICAgICAgICAgKS5sZW5ndGggPiAwXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkVSUk9SOiBOb24taW50ZXJydXB0aW5nIGV2ZW50IG91dGdvaW5nIHBhdGggaXMgbm90IHN5bmNocm9uaXplZCBhbmQgbWVyZ2VzIHdpdGggbWFpbiBwcm9jZXNzIHBhdGhcIlxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIExldCB1cyByZW1vdmUgYWxsIHNvdXJjZSBlbGVtZW50cyBmcm9tIHRoZSBub2RlIGxpc3RcbiAgICAgICAgICAgIGxvY2FsTm9kZUxpc3QgPSBsb2NhbE5vZGVMaXN0LmZpbHRlcigobm9kZTogc3RyaW5nKSA9PiBzb3VyY2VzLmluZGV4T2Yobm9kZSkgPCAwKTtcblxuICAgICAgICAgICAgbGV0IGNoaWxkQ29udHJvbEZsb3dJbmZvID0gbmV3IENvbnRyb2xGbG93SW5mbyhcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBsb2NhbE5vZGVMaXN0LFxuICAgICAgICAgICAgICAgIGxvY2FsRWRnZUxpc3QsXG4gICAgICAgICAgICAgICAgW2V2ZW50SWRdLFxuICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY2hpbGRDb250cm9sRmxvd0luZm8ucGFyZW50ID0gcHJvYztcbiAgICAgICAgICAgIGdsb2JhbENvbnRyb2xGbG93SW5mby5wdXNoKGNoaWxkQ29udHJvbEZsb3dJbmZvKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xGbG93SW5mbyA9IG5ldyBDb250cm9sRmxvd0luZm8oXG4gICAgICAgICAgICBwcm9jLFxuICAgICAgICAgICAgbm9kZUxpc3QsXG4gICAgICAgICAgICBlZGdlTGlzdCxcbiAgICAgICAgICAgIHNvdXJjZXMsXG4gICAgICAgICAgICBib3VuZGFyeUV2ZW50c1xuICAgICAgICApO1xuICAgICAgICBnbG9iYWxDb250cm9sRmxvd0luZm8ucHVzaChjb250cm9sRmxvd0luZm8pO1xuICAgIH1cblxuICAgIGZvciAobGV0IHN1YnByb2Nlc3Mgb2YgcHJvYy5mbG93RWxlbWVudHMuZmlsdGVyKGUgPT4gaXMoZSwgXCJicG1uOlN1YlByb2Nlc3NcIikpKSB7XG4gICAgICAgIGxldCBzdWJwcm9jZXNzQ29udHJvbEZsb3dJbmZvID0gY29sbGVjdENvbnRyb2xGbG93SW5mbyhzdWJwcm9jZXNzLCBnbG9iYWxOb2RlTWFwLCBnbG9iYWxDb250cm9sRmxvd0luZm8pO1xuICAgICAgICBzdWJwcm9jZXNzQ29udHJvbEZsb3dJbmZvLnBhcmVudCA9IHByb2M7XG5cbiAgICAgICAgaWYgKCEoc3VicHJvY2Vzcy5sb29wQ2hhcmFjdGVyaXN0aWNzICYmIHN1YnByb2Nlc3MubG9vcENoYXJhY3RlcmlzdGljcy4kdHlwZSA9PT0gXCJicG1uOk11bHRpSW5zdGFuY2VMb29wQ2hhcmFjdGVyaXN0aWNzXCIpKSB7XG4gICAgICAgICAgICAvLyBTdWJwcm9jZXNzIGlzIGVtYmVkZGVkIC4uLiB0aGVuIGNvcHkgYWxsIG5vZGVzIGFuZCBlZGdlcyB0byB0aGUgcGFyZW50IHByb2Nlc3NcbiAgICAgICAgICAgIHN1YnByb2Nlc3NDb250cm9sRmxvd0luZm8uaXNFbWJlZGRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdCA9IGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5jb25jYXQoc3VicHJvY2Vzc0NvbnRyb2xGbG93SW5mby5ub2RlTGlzdCk7XG4gICAgICAgICAgICBjb250cm9sRmxvd0luZm8uZWRnZUxpc3QgPSBjb250cm9sRmxvd0luZm8uZWRnZUxpc3QuY29uY2F0KHN1YnByb2Nlc3NDb250cm9sRmxvd0luZm8uZWRnZUxpc3QpO1xuICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzID0gY29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzLmNvbmNhdChzdWJwcm9jZXNzQ29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvYy5kb2N1bWVudGF0aW9uKSB7XG4gICAgICAgIGNvbnRyb2xGbG93SW5mby5nbG9iYWxQYXJhbWV0ZXJzID0gcHJvYy5kb2N1bWVudGF0aW9uWzBdLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sRmxvd0luZm87XG59O1xuXG5sZXQgcmVzdHJpY3RSZWxhdGlvbjogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXAoKTtcblxuXG5cbmxldCBleHRyYWN0UGFyYW1ldGVycyA9IChjYWQsIG5vZGVJZCwgY29udHJvbEZsb3dJbmZvKSA9PiB7XG4gICAgICAgIC8vIEV4dHJhY3RpbmcgUm9sZXMgZnJvbSBVc2VyVGFza3MgZnVuY3Rpb25Cb2R5XG5cbiAgICBsZXQgYXJyID0gY2FkLnNwbGl0KCdAJyk7XG4gICAgaWYoYXJyLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIGlmKGNvbnRyb2xGbG93SW5mbyAhPSBudWxsKVxuICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLnRhc2tSb2xlTWFwLnNldChub2RlSWQsIGFyclsxXS50cmltKCkpO1xuICAgICAgICBpZihhcnJbMl0ubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIGNhZCA9IGFyclsyXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0aW5nIEluZm9ybWF0aW9uIG9mIE9yYWNsZSBmcm9tIFNlcnZpY2UgVGFza3MgKGlmIGFwbGljYWJsZSlcbiAgICBsZXQgb3JhY2xlX0RhdGEgPSBcIlwiO1xuICAgIGZvciAobGV0IGogPSAwLCBmaXJzdCA9IGZhbHNlOyBqIDwgY2FkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChjYWQuY2hhckF0KGopID09PSBcIihcIikge1xuICAgICAgICAgICAgaWYgKCFmaXJzdCkgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FkID0gY2FkLnN1YnN0cihqKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FkLmNoYXJBdChqKSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgIG9yYWNsZV9EYXRhID0gXCJcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9yYWNsZV9EYXRhICs9IGNhZC5jaGFyQXQoaik7XG4gICAgfVxuXG4gICAgLy8gUHJvY2Vzc2luZyBJbmZvcm1hdGlvbiBvZiBmdW5jdGlvbiBwYXJhbWV0ZXJzIChib3RoIHNlcnZpY2UgYW5kIHVzZXIgdGFza3MpXG4gICAgY2FkID0gY2FkXG4gICAgICAgIC5yZXBsYWNlKFwiKFwiLCBcIiBcIilcbiAgICAgICAgLnJlcGxhY2UoXCIpXCIsIFwiIFwiKVxuICAgICAgICAudHJpbSgpO1xuICAgIGNhZCA9IGNhZFxuICAgICAgICAucmVwbGFjZShcIihcIiwgXCIgXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiKVwiLCBcIiBcIilcbiAgICAgICAgLnRyaW0oKTtcblxuICAgIGxldCBmaXJzdFNwbGl0ID0gY2FkLnNwbGl0KFwiOlwiKTtcbiAgICBpZiAoZmlyc3RTcGxpdC5sZW5ndGggPiAyKSB7XG4gICAgICAgIGxldCBhdXggPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBmaXJzdFNwbGl0Lmxlbmd0aDsgaSsrKSBhdXggKz0gZmlyc3RTcGxpdFtpXTtcbiAgICAgICAgZmlyc3RTcGxpdCA9IFtmaXJzdFNwbGl0WzBdLCBhdXhdO1xuICAgIH1cbiAgICBsZXQgc2Vjb25kU3BsaXQgPSBmaXJzdFNwbGl0W2ZpcnN0U3BsaXQubGVuZ3RoIC0gMV0udHJpbSgpLnNwbGl0KFwiLT5cIik7XG4gICAgbGV0IHJlc01hcDogTWFwPHN0cmluZywgQXJyYXk8c3RyaW5nPj4gPSBuZXcgTWFwKCk7XG5cbiAgICBsZXQgaW5wdXRPdXRwdXQgPSBbZmlyc3RTcGxpdFswXS50cmltKCksIHNlY29uZFNwbGl0WzBdLnRyaW0oKV07XG4gICAgbGV0IHBhcmFtZXRlclR5cGUgPSBbXCJpbnB1dFwiLCBcIm91dHB1dFwiXTtcbiAgICByZXNNYXAuc2V0KFwiYm9keVwiLCBbc2Vjb25kU3BsaXRbc2Vjb25kU3BsaXQubGVuZ3RoIC0gMV0udHJpbSgpXSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0T3V0cHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0ZW1wID0gaW5wdXRPdXRwdXRbaV0uc3BsaXQoXCIsXCIpO1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIHRlbXAuZm9yRWFjaChzdWJDYWQgPT4ge1xuICAgICAgICAgICAgbGV0IGF1eCA9IHN1YkNhZC50cmltKCkuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgaWYgKGF1eFswXS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGF1eFswXS50cmltKCkpO1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGF1eFthdXgubGVuZ3RoIC0gMV0udHJpbSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlc01hcC5zZXQocGFyYW1ldGVyVHlwZVtpXSwgcmVzKTtcbiAgICB9XG4gICAgLy8gVXBkYXRpbmcgSW5mb3JtYXRpb24gb2YgT3JhY2xlIGluIGNvbnRyb2xGbG93SW5mb1xuICAgIGlmIChjb250cm9sRmxvd0luZm8gIT0gbnVsbCkge1xuICAgICAgICBsZXQgaW5QYXJhbWV0ZXJzOiBBcnJheTxQYXJhbWV0ZXJJbmZvPiA9IFtdO1xuICAgICAgICBsZXQgb3V0UGFyYW1ldGVyczogQXJyYXk8UGFyYW1ldGVySW5mbz4gPSBbXTtcbiAgICAgICAgbGV0IHRvSXRlcmF0ZSA9IHJlc01hcC5nZXQoJ2lucHV0Jyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9JdGVyYXRlLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgaW5QYXJhbWV0ZXJzLnB1c2gobmV3IFBhcmFtZXRlckluZm8odG9JdGVyYXRlW2ldLCB0b0l0ZXJhdGVbaSArIDFdKSk7XG4gICAgICAgIHRvSXRlcmF0ZSA9IHJlc01hcC5nZXQoJ291dHB1dCcpO1xuICAgICAgICBsZXQgcGFyYW1ldGVyczogTWFwPHN0cmluZywgQXJyYXk8UGFyYW1ldGVySW5mbz4+ID0gbmV3IE1hcCgpO1xuICAgICAgICBwYXJhbWV0ZXJzLnNldCgnaW5wdXQnLCBpblBhcmFtZXRlcnMpO1xuICAgICAgICBwYXJhbWV0ZXJzLnNldCgnb3V0cHV0Jywgb3V0UGFyYW1ldGVycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9JdGVyYXRlLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgb3V0UGFyYW1ldGVycy5wdXNoKG5ldyBQYXJhbWV0ZXJJbmZvKHRvSXRlcmF0ZVtpXSwgdG9JdGVyYXRlW2kgKyAxXSkpO1xuICAgICAgICBpZiAob3JhY2xlX0RhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3JhY2xlX0RhdGEgPSBvcmFjbGVfRGF0YS50cmltKCkucmVwbGFjZShcIiBcIiwgXCJfXCIpO1xuICAgICAgICAgICAgb3JhY2xlX0RhdGEgPSBvcmFjbGVfRGF0YVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiKFwiLCBcIiBcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcIikuXCIsIFwiIFwiKVxuICAgICAgICAgICAgICAgIC50cmltKCk7XG4gICAgICAgICAgICBsZXQgc3BsaXRSZXN1bHQgPSBvcmFjbGVfRGF0YS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICBpZiAoIWNvbnRyb2xGbG93SW5mby5vcmFjbGVJbmZvLmhhcyhzcGxpdFJlc3VsdFswXSkpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ub3JhY2xlSW5mby5zZXQoXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0UmVzdWx0WzBdLFxuICAgICAgICAgICAgICAgICAgICBuZXcgT3JhY2xlSW5mbyhzcGxpdFJlc3VsdFswXSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm9yYWNsZVRhc2tNYXAuc2V0KG5vZGVJZCwgc3BsaXRSZXN1bHRbMF0pO1xuICAgICAgICAgICAgbGV0IGxvY2FsT3JhY2xlID0gY29udHJvbEZsb3dJbmZvLm9yYWNsZUluZm8uZ2V0KHNwbGl0UmVzdWx0WzBdKTtcbiAgICAgICAgICAgIGxvY2FsT3JhY2xlLmFkZHJlc3MgPSBzcGxpdFJlc3VsdFsxXTtcbiAgICAgICAgICAgIGxvY2FsT3JhY2xlLmZ1bmN0aW9uTmFtZSA9IHNwbGl0UmVzdWx0WzJdO1xuICAgICAgICAgICAgbG9jYWxPcmFjbGUuZnVuY3Rpb25QYXJhbWV0ZXJzID0gcGFyYW1ldGVycy5nZXQoJ2lucHV0Jyk7XG4gICAgICAgIH0gZWxzZSBjb250cm9sRmxvd0luZm8ubG9jYWxQYXJhbWV0ZXJzLnNldChub2RlSWQsIHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzTWFwO1xufTtcblxubGV0IGdldE5vZGVOYW1lID0gKG5vZGU6IGFueSkgPT5cbiAgICBub2RlLm5hbWUgPyBub2RlLm5hbWUucmVwbGFjZSgvXFxzKy9nLCBcIl9cIikgOiBub2RlLmlkO1xuXG5sZXQgcGFyc2VNb2RlbCA9IChtb2RlbEluZm86IE1vZGVsSW5mbykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHBhcnNlQnBtbihtb2RlbEluZm8uYnBtbilcbiAgICAgICAgICAgIC50aGVuKChkZWZpbml0aW9uczogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ3BhcnNlZCBtb2RlbCcsIGRlZmluaXRpb25zKVxuICAgICAgICAgICAgICAgIG1vZGVsSW5mby5zb2xpZGl0eSA9IFwicHJhZ21hIHNvbGlkaXR5IF4wLjUuNjtcXG5cIjtcbiAgICAgICAgICAgICAgICBtb2RlbEluZm8uY29udHJvbEZsb3dJbmZvTWFwID0gbmV3IE1hcCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrc1xuICAgICAgICAgICAgICAgIGlmICghZGVmaW5pdGlvbnMuZGlhZ3JhbXMgfHwgZGVmaW5pdGlvbnMuZGlhZ3JhbXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBObyBkaWFncmFtIGZvdW5kIGluIEJQTU4gZmlsZVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgcHJvYyA9IGRlZmluaXRpb25zLmRpYWdyYW1zWzBdLnBsYW5lLmJwbW5FbGVtZW50O1xuICAgICAgICAgICAgICAgIG1vZGVsSW5mby5uYW1lID0gcHJvYy5uYW1lID8gcHJvYy5uYW1lLnJlcGxhY2UoL1xccysvZywgXCJfXCIpIDogcHJvYy5pZDtcbiAgICAgICAgICAgICAgICBtb2RlbEluZm8uaWQgPSBwcm9jLmlkO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jLiR0eXBlICE9PSBcImJwbW46UHJvY2Vzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jLiR0eXBlID09PSBcImJwbW46Q29sbGFib3JhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmluaXRpb25zLnJvb3RFbGVtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbnMucm9vdEVsZW1lbnRzW2ldLiR0eXBlID09PSBcImJwbW46UHJvY2Vzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2MgPSBkZWZpbml0aW9ucy5yb290RWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsSW5mby5uYW1lID0gcHJvYy5uYW1lID8gcHJvYy5uYW1lLnJlcGxhY2UoL1xccysvZywgXCJfXCIpIDogcHJvYy5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxJbmZvLmlkID0gcHJvYy5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IE5vIHJvb3QgcHJvY2VzcyBtb2RlbCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEJQTU4gdG8gU29saWRpdHkgcGFyc2luZ1xuXG4gICAgICAgICAgICAgICAgbGV0IGdsb2JhbE5vZGVNYXA6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbE5vZGVJbmRleE1hcDogTWFwPHN0cmluZywgbnVtYmVyPiA9IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRWRnZUluZGV4TWFwOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxDb250cm9sRmxvd0luZm86IEFycmF5PENvbnRyb2xGbG93SW5mbz4gPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAgICAgZ2xvYmFsTm9kZU1hcC5zZXQocHJvYy5pZCwgcHJvYyk7XG4gICAgICAgICAgICAgICAgbGV0IG1haW5Db250cm9sRmxvd0luZm8gPSBjb2xsZWN0Q29udHJvbEZsb3dJbmZvKHByb2MsIGdsb2JhbE5vZGVNYXAsIGdsb2JhbENvbnRyb2xGbG93SW5mbyk7XG4gICAgICAgICAgICAgICAgbGV0IGdsb2JhbENvbnRyb2xGbG93SW5mb01hcDogTWFwPHN0cmluZywgQ29udHJvbEZsb3dJbmZvPiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBnbG9iYWxDb250cm9sRmxvd0luZm8uZm9yRWFjaChjb250cm9sRmxvd0luZm8gPT5cbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsQ29udHJvbEZsb3dJbmZvTWFwLnNldChjb250cm9sRmxvd0luZm8uc2VsZi5pZCwgY29udHJvbEZsb3dJbmZvKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBFdmVudCBzdWItcHJvY2Vzc2VzIGFwcGVhciBpbiB0aGUgc291cmNlIGxpc3QsIGFuZCBub3QgaW4gdGhlIG5vZGVMaXN0XG4gICAgICAgICAgICAgICAgLy8gSW4gYWRkaXRpb24sIGFsbCB0aGUgZWxlbWVudHMgb2YgYSBub24gaW50ZXJydXB0aW5nIHN1YnByb2Nlc3MgZXZlbnQgYXBwZWFycyBlbWJlZGRlZCBvbiBpdHMgcGFyZW50IHByb2Nlc3NcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb250cm9sRmxvd0luZm8gb2YgZ2xvYmFsQ29udHJvbEZsb3dJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleGVzVG9SZW1vdmUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLnNvdXJjZXMuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCkudHJpZ2dlcmVkQnlFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVtb3ZlLnB1c2goY29udHJvbEZsb3dJbmZvLnNvdXJjZXMuaW5kZXhPZihub2RlSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZUluZm8gPSBnbG9iYWxDb250cm9sRmxvd0luZm9NYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFnbG9iYWxOb2RlTWFwLmdldChub2RlSW5mby5zb3VyY2VzWzBdKS5pc0ludGVycnVwdGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZm8ubm9kZUxpc3QuZm9yRWFjaChjaGlsZElkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5pbmRleE9mKGNoaWxkSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXNUb1JlbW92ZS5zb3J0KChpbmQxLCBpbmQyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kMiAtIGluZDE7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVzVG9SZW1vdmUuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8uc291cmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzKGdsb2JhbE5vZGVNYXAuZ2V0KGNvbnRyb2xGbG93SW5mby5zZWxmLmlkKSwgXCJicG1uOlN1YlByb2Nlc3NcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5zZWxmLnRyaWdnZXJlZEJ5RXZlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbE5vZGVNYXAuZ2V0KGNvbnRyb2xGbG93SW5mby5zb3VyY2VzWzBdKS5pc0ludGVycnVwdGluZyA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmlzRW1iZWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBoYXNFeHRlcm5hbENhbGwgPSBub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpcyhub2RlLCBcImJwbW46U2VydmljZVRhc2tcIik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG1vZGVsSW5mby5nbG9iYWxOb2RlTWFwID0gZ2xvYmFsTm9kZU1hcDtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbnRyb2xGbG93SW5mbyBvZiBnbG9iYWxDb250cm9sRmxvd0luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250cm9sRmxvd0luZm8uaXNFbWJlZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG11bHRpaW5zdGFuY2VBY3Rpdml0aWVzID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEFjdGl2aXRpZXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25JbnRlcnJ1cHRpbmdFdmVudHMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaGluZ01lc3NhZ2VzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobm9kZUlkID0+IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaXMoZSwgXCJicG1uOlRhc2tcIikgfHwgaXMoZSwgXCJicG1uOlN1YlByb2Nlc3NcIikpICYmIGUubG9vcENoYXJhY3RlcmlzdGljcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5sb29wQ2hhcmFjdGVyaXN0aWNzLiR0eXBlID09PSBcImJwbW46TXVsdGlJbnN0YW5jZUxvb3BDaGFyYWN0ZXJpc3RpY3NcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm11bHRpaW5zdGFuY2VBY3Rpdml0aWVzLnNldChlLmlkLCBnZXROb2RlTmFtZShlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWluc3RhbmNlQWN0aXZpdGllcy5wdXNoKGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzKGUsIFwiYnBtbjpDYWxsQWN0aXZpdHlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5jYWxsQWN0aXZpdGllcy5zZXQoZS5pZCwgZ2V0Tm9kZU5hbWUoZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEFjdGl2aXRpZXMucHVzaChlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhlLCBcImJwbW46SW50ZXJtZWRpYXRlQ2F0Y2hFdmVudFwiKSAmJiBpcyhlLmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hpbmdNZXNzYWdlcy5wdXNoKGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpcyhlLCBcImJwbW46U3RhcnRFdmVudFwiKSAmJiBpcyhlLmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hpbmdNZXNzYWdlcy5wdXNoKGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBhbHNvIG5lY2Vzc2FyeSB0byBhZGQgYm91bmRhcnkgZXZlbnRzIG9mIGVtYmVkZGVkIHN1Yi1wcm9jZXNzZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLnNvdXJjZXMuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0LmV2ZW50RGVmaW5pdGlvbnMgJiYgc3RhcnQuZXZlbnREZWZpbml0aW9uc1swXSAmJiBpcyhzdGFydC5ldmVudERlZmluaXRpb25zWzBdLCBcImJwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvblwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuaW5kZXhPZihub2RlSWQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0Y2hpbmdNZXNzYWdlcy5pbmRleE9mKG5vZGVJZCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hpbmdNZXNzYWdlcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ib3VuZGFyeUV2ZW50cy5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm91dGdvaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBvdXRnb2luZyBvZiBub2RlLm91dGdvaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmVkZ2VMaXN0LnB1c2gob3V0Z29pbmcuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5jYW5jZWxBY3Rpdml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9uSW50ZXJydXB0aW5nRXZlbnRzLnNldChub2RlLmlkLCBnZXROb2RlTmFtZShub2RlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbkludGVycnVwdGluZ0V2ZW50cy5wdXNoKG5vZGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QucHVzaChub2RlSWQpOyAvLyBFYWdlciByZWluc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ldmVudERlZmluaXRpb25zWzBdICYmIGlzKG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSwgJ2JwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0Y2hpbmdNZXNzYWdlcy5pbmRleE9mKG5vZGVJZCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoaW5nTWVzc2FnZXMucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmV2ZW50RGVmaW5pdGlvbnMgJiYgaXMobm9kZS5ldmVudERlZmluaXRpb25zWzBdLCBcImJwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmluZGV4T2Yobm9kZUlkKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0Y2hpbmdNZXNzYWdlcy5pbmRleE9mKG5vZGVJZCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hpbmdNZXNzYWdlcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbE5vZGVNYXAuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOlN1YlByb2Nlc3NcIikgJiYgbm9kZS50cmlnZ2VyZWRCeUV2ZW50ICYmIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5pbmRleE9mKG5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHN0YXJ0IG9mIG5vZGUuZmxvd0VsZW1lbnRzLmZpbHRlcihlID0+IGlzKGUsIFwiYnBtbjpGbG93Tm9kZVwiKSAmJiBpcyhlLCBcImJwbW46U3RhcnRFdmVudFwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydC5pc0ludGVycnVwdGluZyA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBnbG9iYWxOb2RlTWFwLmdldChzdGFydC4kcGFyZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9uSW50ZXJydXB0aW5nRXZlbnRzLnNldChzdGFydC5pZCwgZ2V0Tm9kZU5hbWUocGFyZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uSW50ZXJydXB0aW5nRXZlbnRzLnB1c2goc3RhcnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5wdXNoKHN0YXJ0LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQuZXZlbnREZWZpbml0aW9uc1swXSAmJiBpcyhzdGFydC5ldmVudERlZmluaXRpb25zWzBdLCBcImJwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0Y2hpbmdNZXNzYWdlcy5pbmRleE9mKHN0YXJ0LmlkKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaGluZ01lc3NhZ2VzLnB1c2goc3RhcnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sRmxvd0luZm8uYm91bmRhcnlFdmVudHMuaW5kZXhPZihzdGFydC5pZCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzLnB1c2goc3RhcnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuaW5kZXhPZihzdGFydC4kcGFyZW50LmlkKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5wdXNoKHN0YXJ0LiRwYXJlbnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0LmV2ZW50RGVmaW5pdGlvbnNbMF0gJiYgaXMoc3RhcnQuZXZlbnREZWZpbml0aW9uc1swXSwgXCJicG1uOk1lc3NhZ2VFdmVudERlZmluaXRpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmluZGV4T2Yoc3RhcnQuaWQpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LnB1c2goc3RhcnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXRjaGluZ01lc3NhZ2VzLmluZGV4T2Yoc3RhcnQuaWQpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hpbmdNZXNzYWdlcy5wdXNoKHN0YXJ0LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydC5vdXRnb2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBvdXRnb2luZyBvZiBzdGFydC5vdXRnb2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmVkZ2VMaXN0LnB1c2gob3V0Z29pbmcuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0MTogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnQyOiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNFeHRlcm5hbENhbGwobm9kZUlkKSkgcGFydDEucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcGFydDIucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QgPSBwYXJ0MS5jb25jYXQocGFydDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGVJZDogc3RyaW5nLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVJbmRleE1hcC5zZXQobm9kZUlkLCBpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxOb2RlSW5kZXhNYXAuc2V0KG5vZGVJZCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVOYW1lTWFwLnNldChub2RlSWQsIGdldE5vZGVOYW1lKGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZG9jdW1lbnRhdGlvbiAmJiBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCAmJiBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgJ2JwbW46Q2FsbEFjdGl2aXR5JykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmV4dGVybmFsQnVuZGxlcy5zZXQobm9kZUlkLCBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGUuaWQsIGNvbnRyb2xGbG93SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmVkZ2VMaXN0LmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVkZ2VJZDogc3RyaW5nLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5lZGdlSW5kZXhNYXAuc2V0KGVkZ2VJZCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRWRnZUluZGV4TWFwLnNldChlZGdlSWQsIGluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5jYXRjaGluZ01lc3NhZ2VzID0gY2F0Y2hpbmdNZXNzYWdlcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udHJvbEZsb3cgUGVyc3BlY3RpdmU6IEdlbmVyYXRpb24gb2YgU21hcnQgQ29udHJhY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29kZUdlbmVyYXRpb25JbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMaXN0OiBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU1hcDogZ2xvYmFsTm9kZU1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaGluZ01lc3NhZ2VzOiBjb250cm9sRmxvd0luZm8uY2F0Y2hpbmdNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWluc3RhbmNlQWN0aXZpdGllczogbXVsdGlpbnN0YW5jZUFjdGl2aXRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEFjdGl2aXRpZXM6IGNhbGxBY3Rpdml0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbkludGVycnVwdGluZ0V2ZW50czogbm9uSW50ZXJydXB0aW5nRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yYWNsZUluZm86IGNvbnRyb2xGbG93SW5mby5vcmFjbGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yYWNsZVRhc2tNYXA6IGNvbnRyb2xGbG93SW5mby5vcmFjbGVUYXNrTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NJZDogKCkgPT4gY29udHJvbEZsb3dJbmZvLnNlbGYuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWU6IG5vZGVJZCA9PiBnZXROb2RlTmFtZShnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGU6IG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZXZlbnREZWZpbml0aW9ucyAmJiBub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYWQgPSBub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0uJHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FkLnN1YnN0cmluZyg1LCBjYWQubGVuZ3RoIC0gMTUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkRlZmF1bHRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEV2ZW50VHlwZXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRha2VuID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbE5vZGVNYXAuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmV2ZW50RGVmaW5pdGlvbnMgJiYgbm9kZS5ldmVudERlZmluaXRpb25zWzBdICYmICFpcyhub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpUZXJtaW5hdGVFdmVudERlZmluaXRpb25cIikgJiYgIWlzKG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSwgXCJicG1uOk1lc3NhZ2VFdmVudERlZmluaXRpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FkID0gbm9kZS5ldmVudERlZmluaXRpb25zWzBdLiR0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWtlbi5pbmRleE9mKGNhZC5zdWJzdHJpbmcoNSwgY2FkLmxlbmd0aCAtIDE1KSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWtlbi5wdXNoKGNhZC5zdWJzdHJpbmcoNSwgY2FkLmxlbmd0aCAtIDE1KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFrZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRNZXNzYWdlczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFrZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZXMgPSBjb250cm9sRmxvd0luZm8uYm91bmRhcnlFdmVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMoZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKSwgXCJicG1uOlN1YlByb2Nlc3NcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3ViUCA9IGdsb2JhbENvbnRyb2xGbG93SW5mb01hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5jb25jYXQoc3ViUC5ib3VuZGFyeUV2ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViUC5zb3VyY2VzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzKGdsb2JhbE5vZGVNYXAuZ2V0KGlkKSwgXCJicG1uOlN1YnByb2Nlc3NcIikgJiYgY2FuZGlkYXRlcy5pbmRleE9mKGlkKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5mb3JFYWNoKGV2dElkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldnQgPSBnbG9iYWxOb2RlTWFwLmdldChldnRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0LmV2ZW50RGVmaW5pdGlvbnMgJiYgZXZ0LmV2ZW50RGVmaW5pdGlvbnNbMF0gJiYgaXMoZXZ0LmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRha2VuLnB1c2goZXZ0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRha2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VGhyb3dpbmdNZXNzYWdlczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGlzKG5vZGUsIFwiYnBtbjpFbmRFdmVudFwiKSB8fCBpcyhub2RlLCBcImJwbW46SW50ZXJtZWRpYXRlVGhyb3dFdmVudFwiKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmV2ZW50RGVmaW5pdGlvbnMgJiYgbm9kZS5ldmVudERlZmluaXRpb25zWzBdICYmIGlzKG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSwgXCJicG1uOk1lc3NhZ2VFdmVudERlZmluaXRpb25cIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRUaHJvd2luZ0V2ZW50czogKHN1YnByb2NJZCwgZXZUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsTm9kZU1hcC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZXZlbnREZWZpbml0aW9ucyAmJiBub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FkID0gbm9kZS5ldmVudERlZmluaXRpb25zWzBdLiR0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWQuc3Vic3RyaW5nKDUsIGNhZC5sZW5ndGggLSAxNSkgPT09IGV2VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGlzKG5vZGUsIFwiYnBtbjpFbmRFdmVudFwiKSB8fCBpcyhub2RlLCBcImJwbW46SW50ZXJtZWRpYXRlVGhyb3dFdmVudFwiKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLiRwYXJlbnQuaWQgPT09IHN1YnByb2NJZCB8fCBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuaW5kZXhPZihub2RlLmlkKSA+PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q2F0Y2hpbmdFdmVudHM6IChzdWJwcm9jSWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxOb2RlTWFwLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ldmVudERlZmluaXRpb25zICYmIG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCBcImJwbW46U3RhcnRFdmVudFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZS4kcGFyZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC50cmlnZ2VyZWRCeUV2ZW50ICYmIHBhcmVudC4kcGFyZW50LmlkID09PSBzdWJwcm9jSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMudW5zaGlmdChub2RlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXBhcmVudC50cmlnZ2VyZWRCeUV2ZW50ICYmIChwYXJlbnQuaWQgPT09IHN1YnByb2NJZCB8fCBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuaW5kZXhPZihwYXJlbnQuaWQpID4gLTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhub2RlLCBcImJwbW46Qm91bmRhcnlFdmVudFwiKSB8fCBpcyhub2RlLCBcImJwbW46SW50ZXJtZWRpYXRlQ2F0Y2hFdmVudFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS4kcGFyZW50LmlkID09PSBzdWJwcm9jSWQgfHwgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmluZGV4T2Yobm9kZS4kcGFyZW50LmlkKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFRlcm1pbmF0ZUNhbmRpZGF0ZXM6IChzdWJwcm9jSWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbE5vZGVNYXAuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ldmVudERlZmluaXRpb25zICYmIG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOkJvdW5kYXJ5RXZlbnRcIikgJiYgbm9kZS5jYW5jZWxBY3Rpdml0eSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihnbG9iYWxDb250cm9sRmxvd0luZm9NYXAuaGFzKG5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsQyA9IGdsb2JhbENvbnRyb2xGbG93SW5mb01hcC5nZXQobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxDLm5vZGVMaXN0LmZvckVhY2goZWxlbUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbSA9IGdsb2JhbE5vZGVNYXAuZ2V0KGVsZW1JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWxlbS5ldmVudERlZmluaXRpb25zICYmIGlzKGVsZW0uZXZlbnREZWZpbml0aW9uc1swXSwgXCJicG1uOlRlcm1pbmF0ZUV2ZW50RGVmaW5pdGlvblwiKSAmJiBlbGVtLiRwYXJlbnQuaWQgPT09IG5vZGUuJHBhcmVudC5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKCdNaXNzaW5nIE5vbiBJbnRlcnJ1cHRpbmcgZXZlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UHJvY2Vzc0NhbmRpZGF0ZXNNYXNrRnJvbTogKGV2dElkLCBldnRUeXBlLCBldnRDb2RlLCBzb3VyY2VQcm9jZXNzZXMsIGFsbEV2ZW50cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxFdmVudHMuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhZCA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCkuZXZlbnREZWZpbml0aW9uc1swXS4kdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldnRUeXBlID09PSBjYWQuc3Vic3RyaW5nKDUsIGNhZC5sZW5ndGggLSAxNSkgJiYgZXZ0Q29kZSA9PT0gZ2V0Tm9kZU5hbWUoZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0LnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVByb2Nlc3Nlcy5mb3JFYWNoKHByb2NJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gZ2xvYmFsTm9kZU1hcC5nZXQocHJvY0lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcmV2aW91c1BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIWV2ZW50Rm91bmQgJiYgcmVzLmxlbmd0aCA9PSAwICYmIHBhcmVudC4kcGFyZW50ICYmIGNvbnRyb2xGbG93SW5mby5zZWxmLmlkICE9PSBwYXJlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBnbG9iYWxOb2RlTWFwLmdldChwYXJlbnQuJHBhcmVudC5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0LmZvckVhY2gobm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Rm91bmQgJiYgaXMobm9kZSwgXCJicG1uOkJvdW5kYXJ5RXZlbnRcIikgJiYgbm9kZS5hdHRhY2hlZFRvUmVmLmlkID09PSBwcmV2aW91c1BhcmVudC5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRGb3VuZCA9IG5vZGUuY2FuY2VsQWN0aXZpdHkgIT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRGb3VuZCkgcmVzID0gW25vZGVJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHJlcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Rm91bmQgJiYgaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikgJiYgbm9kZS4kcGFyZW50LnRyaWdnZXJlZEJ5RXZlbnQgJiYgbm9kZS4kcGFyZW50LiRwYXJlbnQuaWQgPT09IHBhcmVudC5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Rm91bmQgPSBub2RlLmlzSW50ZXJydXB0aW5nICE9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEZvdW5kKSByZXMgPSBbbm9kZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHJlcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5pbmRleE9mKGV2dElkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRhcnJheVtnbG9iYWxOb2RlSW5kZXhNYXAuZ2V0KHByb2NJZCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBcIjBiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IFwiMGJcIiA/IDAgOiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q2F0Y2hpbmdFdmVudHNGcm9tOiAocHJvY0lkLCBldnRUeXBlLCBldnRDb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzY2FsYXRpb24gYW5kIEVycm9yIGNhdGNoaW5nIGV2ZW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gaW50ZXJtZWRpYXRlIGV2ZW50cyBpbiBub3JtYWwgZmxvdyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IGdsb2JhbE5vZGVNYXAuZ2V0KHByb2NJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYW5kaWRhdGVzID0gY29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzLmNvbmNhdChjb250cm9sRmxvd0luZm8ubm9kZUxpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZXZlbnREZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYWQgPSBub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0uJHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBjYWQuc3Vic3RyaW5nKDUsIGNhZC5sZW5ndGggLSAxNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IGV2dFR5cGUgJiYgZXZ0Q29kZSA9PT0gZ2V0Tm9kZU5hbWUoZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKSkgJiYgZXZlbnRMaXN0LmluZGV4T2Yobm9kZUlkKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0LnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudC50cmlnZ2VyZWRCeUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudExpc3QuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Rm91bmQgJiYgaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikgJiYgbm9kZS4kcGFyZW50LnRyaWdnZXJlZEJ5RXZlbnQgJiYgbm9kZS4kcGFyZW50LiRwYXJlbnQuaWQgPT09IHBhcmVudC5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEZvdW5kID0gbm9kZS5pc0ludGVycnVwdGluZyAhPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Rm91bmQpIHJlcyA9IFtub2RlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHJlcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xGbG93SW5mby5zZWxmLmlkID09PSBwcm9jSWQgfHwgcmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnRyaWdnZXJlZEJ5RXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gZ2xvYmFsTm9kZU1hcC5nZXQocGFyZW50LiRwYXJlbnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzUGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFldmVudEZvdW5kICYmIHJlcy5sZW5ndGggPT0gMCAmJiBwYXJlbnQuJHBhcmVudCAmJiBjb250cm9sRmxvd0luZm8uc2VsZi5pZCAhPT0gcGFyZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gZ2xvYmFsTm9kZU1hcC5nZXQocGFyZW50LiRwYXJlbnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudEZvdW5kICYmIGlzKG5vZGUsIFwiYnBtbjpCb3VuZGFyeUV2ZW50XCIpICYmIG5vZGUuYXR0YWNoZWRUb1JlZi5pZCA9PT0gcHJldmlvdXNQYXJlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Rm91bmQgPSBub2RlLmNhbmNlbEFjdGl2aXR5ICE9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Rm91bmQpIHJlcyA9IFtub2RlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSByZXMucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudExpc3QuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudEZvdW5kICYmIGlzKG5vZGUsIFwiYnBtbjpTdGFydEV2ZW50XCIpICYmIG5vZGUuJHBhcmVudC50cmlnZ2VyZWRCeUV2ZW50ICYmIG5vZGUuJHBhcmVudC4kcGFyZW50LmlkID09PSBwYXJlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEZvdW5kID0gbm9kZS5pc0ludGVycnVwdGluZyAhPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRGb3VuZCkgcmVzID0gW25vZGVJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSByZXMucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFdvcmtJdGVtc0dyb3VwQnlQYXJhbWV0ZXJzOiAoaXNJbnB1dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZTJJZHM6IE1hcDxzdHJpbmcsIHN0cmluZ1tdPiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmZvckVhY2gobm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCAnYnBtbjpVc2VyVGFzaycpIHx8IGlzKG5vZGUsICdicG1uOlJlY2VpdmVUYXNrJykgfHwgY2F0Y2hpbmdNZXNzYWdlcy5pbmRleE9mKG5vZGVJZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJhbXMgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmRvY3VtZW50YXRpb24gJiYgbm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQgJiYgbm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQubGVuZ3RoID4gMCAmJiBleHRyYWN0UGFyYW1ldGVycyhub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCwgbm9kZUlkLCBudWxsKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbFBhcmFtcyA9IGlzSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGVJZCwgbnVsbCkuZ2V0KFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGVJZCwgbnVsbCkuZ2V0KFwib3V0cHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gbG9jYWxQYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGxvY2FsUGFyYW1zLmxlbmd0aDsgaSArPSAyKSBwYXJhbXMgKz0gbG9jYWxQYXJhbXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBnZXROb2RlTmFtZShnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpKSArIHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWUySWRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lMklkcy5zZXQobmFtZSwgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lMklkcy5nZXQobmFtZSkucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUySWRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29udHJhY3RzMkNhbGw6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IGNhbGxBY3Rpdml0aWVzLmNvbmNhdChtdWx0aWluc3RhbmNlQWN0aXZpdGllcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbkludGVycnVwdGluZ0V2ZW50cy5mb3JFYWNoKGV2dElkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQoZXZ0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikgPyBub2RlLiRwYXJlbnQuaWQgOiBldnRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29udHJhY3RzMkNhbGxGcm9tOiAoc3VicHJvY0lkLCBjYW5kaWRhdGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBbc3VicHJvY0lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250cm9sRmxvd0luZm8uY2FsbEFjdGl2aXRpZXMuaGFzKHN1YnByb2NJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZS4kcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLiRwYXJlbnQuaWQgPT09IHN1YnByb2NJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLiRwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbnRyYWN0czJDYWxsTWFza0Zyb206IChzdWJwcm9jSWQsIGNhbmRpZGF0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpdGFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUuJHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLiRwYXJlbnQuaWQgPT09IHN1YnByb2NJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRhcnJheVtnbG9iYWxOb2RlSW5kZXhNYXAuZ2V0KG5vZGVJZCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLiRwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gXCIwYlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gYml0YXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYml0YXJyYXlbaV0gPyBcIjFcIiA6IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBcIjBiXCIgPyAwIDogbmV3IEJpZ051bWJlcihyZXN1bHQpLnRvRml4ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbnRyYWN0czJDYWxsQXJyYXk6IChzdWJwcm9jSWQsIGNhbmRpZGF0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9ICdbdWludCgnICsgZ2xvYmFsTm9kZUluZGV4TWFwLmdldChjYW5kaWRhdGVzWzBdKSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9ICcsIHVpbnQoJyArIGdsb2JhbE5vZGVJbmRleE1hcC5nZXQoY2FuZGlkYXRlc1tpXSkgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMgKyAnXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRQb3NzaWJsZUtpbGxTdWJwcm9jZXNzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzLmZvckVhY2gobm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLiRwYXJlbnQudHJpZ2dlcmVkQnlFdmVudCAmJiBub2RlLiRwYXJlbnQuJHBhcmVudC5pZCAhPT0gY29udHJvbEZsb3dJbmZvLnNlbGYuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pc0ludGVycnVwdGluZyAhPSBmYWxzZSAmJiByZXMuaW5kZXhPZihub2RlLiRwYXJlbnQuJHBhcmVudC5pZCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChub2RlLiRwYXJlbnQuJHBhcmVudC5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuYXR0YWNoZWRUb1JlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhdHRhY2hlZFRvID0gbm9kZS5hdHRhY2hlZFRvUmVmLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNhbmNlbEFjdGl2aXR5ICE9IGZhbHNlICYmIHJlcy5pbmRleE9mKGF0dGFjaGVkVG8pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChhdHRhY2hlZFRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxOb2RlTWFwLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ldmVudERlZmluaXRpb25zICYmIG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCBcImJwbW46Qm91bmRhcnlFdmVudFwiKSAmJiBub2RlLmNhbmNlbEFjdGl2aXR5ID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZ2xvYmFsQ29udHJvbEZsb3dJbmZvTWFwLmhhcyhub2RlLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsQyA9IGdsb2JhbENvbnRyb2xGbG93SW5mb01hcC5nZXQobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEMubm9kZUxpc3QuZm9yRWFjaChlbGVtSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW0gPSBnbG9iYWxOb2RlTWFwLmdldChlbGVtSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWxlbS5ldmVudERlZmluaXRpb25zICYmIGlzKGVsZW0uZXZlbnREZWZpbml0aW9uc1swXSwgXCJicG1uOlRlcm1pbmF0ZUV2ZW50RGVmaW5pdGlvblwiKSAmJiBlbGVtLiRwYXJlbnQuaWQgPT09IG5vZGUuJHBhcmVudC5pZCAmJiBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuaW5kZXhPZihub2RlLiRwYXJlbnQuaWQpID49IDAgJiYgcmVzLmluZGV4T2Yobm9kZS4kcGFyZW50LmlkKSA8IDAgJiYgbm9kZS4kcGFyZW50LmlkICE9IGNvbnRyb2xGbG93SW5mby5zZWxmLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS4kcGFyZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ldmVudERlZmluaXRpb25zICYmIGlzKG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSwgXCJicG1uOlRlcm1pbmF0ZUV2ZW50RGVmaW5pdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXMuaW5kZXhPZihub2RlLiRwYXJlbnQuaWQpIDwgMCAmJiBub2RlLiRwYXJlbnQuaWQgIT0gY29udHJvbEZsb3dJbmZvLnNlbGYuaWQgJiYgIWlzKGdsb2JhbE5vZGVNYXAuZ2V0KGNvbnRyb2xGbG93SW5mby5zZWxmLmlkKSwgXCJicG1uOkJvdW5kYXJ5RXZlbnRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKCdJIGFtIGhlcmUgMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS4kcGFyZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvdW50RXh0ZXJuYWxUYXNrczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmZvckVhY2gobm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNFeHRlcm5hbENhbGwobm9kZUlkKSkgcmVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhcnRlZE1lc3NhZ2VzOiBwcm9jZXNzSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikgJiYgbm9kZS4kcGFyZW50LmlkID09PSBwcm9jZXNzSWQgJiYgbm9kZS5ldmVudERlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgaXMobm9kZS5ldmVudERlZmluaXRpb25zWzBdLCBcImJwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvblwiKSAmJiBnbG9iYWxOb2RlTWFwLmdldChub2RlLiRwYXJlbnQuaWQpLnRyaWdnZXJlZEJ5RXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRQYXJlbnQ6IG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHJpZXZlcyB0aGUgaWQgb2YgdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCBcImJwbW46U3RhcnRFdmVudFwiKSAmJiBub2RlLiRwYXJlbnQgJiYgZ2xvYmFsTm9kZU1hcC5nZXQobm9kZS4kcGFyZW50LmlkKS50cmlnZ2VyZWRCeUV2ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGUuJHBhcmVudC5pZCkuJHBhcmVudC5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKG5vZGUsIFwiYnBtbjpCb3VuZGFyeUV2ZW50XCIpICYmIG5vZGUuY2FuY2VsQWN0aXZpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5hdHRhY2hlZFRvUmVmLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS4kcGFyZW50ID8gbm9kZS4kcGFyZW50LmlkIDogbm9kZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29udHJhY3ROYW1lOiBub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZXMgdGhlIGNvbnRyYWN0IG5hbWUgcmVsYXRlZCB0byB0aGUgbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikgJiYgbm9kZS4kcGFyZW50ICYmIGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGUuJHBhcmVudC5pZCkudHJpZ2dlcmVkQnlFdmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLiRwYXJlbnQuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCBcImJwbW46Qm91bmRhcnlFdmVudFwiKSkgcmV0dXJuIG5vZGUuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sRmxvd0luZm8uc2VsZi5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFsbENoaWxkcmVuOiAoc3VicHJvY0lkLCBkaXJlY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRha2VuID0gZGlyZWN0ID8gW10gOiBbc3VicHJvY0lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKG5vZGVJZCA9PiBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKGUsIFwiYnBtbjpTdWJQcm9jZXNzXCIpIHx8IGNhbGxBY3Rpdml0aWVzLmluZGV4T2YoZS5pZCkgPj0gMCB8fCAobm9uSW50ZXJydXB0aW5nRXZlbnRzLmluZGV4T2YoZS5pZCkgPj0gMCAmJiAhaXMoZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChkaXJlY3QgJiYgc3VicHJvY0lkICE9PSBlLmlkICYmIGUuJHBhcmVudC5pZCA9PT0gc3VicHJvY0lkKSB8fCAhZGlyZWN0KSAmJiB0YWtlbi5pbmRleE9mKGUuaWQpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRha2VuLnB1c2goZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRha2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGFydGluZ0NvbnRyYWN0RXZlbnQ6IChldmVudElkLCBwcm9jZXNzSWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2dCA9IGdsb2JhbE5vZGVNYXAuZ2V0KGV2ZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMoZXZ0LCBcImJwbW46U3RhcnRFdmVudFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbE5vZGVNYXAuZ2V0KGV2dC4kcGFyZW50LmlkKS50cmlnZ2VyZWRCeUV2ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldnQuJHBhcmVudC5pZCAhPT0gcHJvY2Vzc0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKGV2dC5ldmVudERlZmluaXRpb25zWzBdLCBcImJwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvblwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhldnQsIFwiYnBtbjpCb3VuZGFyeUV2ZW50XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRJZCAhPT0gcHJvY2Vzc0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzKGV2dCwgXCJicG1uOkludGVybWVkaWF0ZUNhdGNoRXZlbnRcIikgJiYgaXMoZXZ0LmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSW50ZXJydXB0aW5nOiBldmVudElkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ1ZSBpZiBhbiBldmVudCBpcyBpbnRlcnJ1cHRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChldmVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZXZlbnREZWZpbml0aW9ucyAmJiBpcyhub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpFcnJvckV2ZW50RGVmaW5pdGlvblwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikgJiYgbm9kZS4kcGFyZW50ICYmIGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGUuJHBhcmVudC5pZCkudHJpZ2dlcmVkQnlFdmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmlzSW50ZXJydXB0aW5nICE9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOkJvdW5kYXJ5RXZlbnRcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5jYW5jZWxBY3Rpdml0eSAhPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNFbWJlZGRlZFN1YnByb2Nlc3M6IHN1YnByb2Nlc3NJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxDb250cm9sRmxvd0luZm9NYXAuZ2V0KHN1YnByb2Nlc3NJZCkuaXNFbWJlZGRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQm91bmRhcnlFdmVudDogZXZ0SWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbEZsb3dJbmZvLmJvdW5kYXJ5RXZlbnRzLmluZGV4T2YoZXZ0SWQpID49IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVNYXJraW5nOiBub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pbmNvbWluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluY29taW5nIG9mIG5vZGUuaW5jb21pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0YXJyYXlbY29udHJvbEZsb3dJbmZvLmVkZ2VJbmRleE1hcC5nZXQoaW5jb21pbmcuaWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgYml0YXJyYXlbMF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gXCIwYlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gYml0YXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYml0YXJyYXlbaV0gPyBcIjFcIiA6IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihyZXN1bHQpLnRvRml4ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNYXJraW5nOiBub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gXCIwYlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5vdXRnb2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG91dGdvaW5nIG9mIG5vZGUub3V0Z29pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRhcnJheVtjb250cm9sRmxvd0luZm8uZWRnZUluZGV4TWFwLmdldChvdXRnb2luZy5pZCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSByZXN1bHQgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJpdGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJpdGFycmF5W2ldID8gXCIxXCIgOiBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIocmVzdWx0KS50b0ZpeGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJwcm9jZXNzTm9kZU1hcmtpbmc6IHN1YnByb2Nlc3NJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxOb2RlTWFwLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS4kcGFyZW50ICYmIG5vZGUuJHBhcmVudC5pZCA9PT0gc3VicHJvY2Vzc0lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKG5vZGUsIFwiYnBtbjpUYXNrXCIpIHx8IGlzKG5vZGUsICdicG1uOlN1YlByb2Nlc3MnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0YXJyYXlbZ2xvYmFsTm9kZUluZGV4TWFwLmdldChub2RlLmlkKV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFnbG9iYWxOb2RlTWFwLmdldChzdWJwcm9jZXNzSWQpLnRyaWdnZXJlZEJ5RXZlbnQgJiYgbm9kZS5ldmVudERlZmluaXRpb25zICYmIG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyhub2RlLmV2ZW50RGVmaW5pdGlvbnNbMF0sIFwiYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRhcnJheVtnbG9iYWxOb2RlSW5kZXhNYXAuZ2V0KG5vZGUuaWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gYml0YXJyYXkubGVuZ3RoID4gMCA/IFwiMGJcIiA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicHJvY2Vzc05vZGVGdWxsTWFya2luZzogc3VicHJvY0lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gW3N1YnByb2NJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3QuZm9yRWFjaChub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKG5vZGUsIFwiYnBtbjpTdWJQcm9jZXNzXCIpIHx8IGNhbGxBY3Rpdml0aWVzLmluZGV4T2Yobm9kZS5pZCkgPj0gMCB8fCAobm9uSW50ZXJydXB0aW5nRXZlbnRzLmluZGV4T2Yobm9kZS5pZCkgPj0gMCAmJiAhaXMobm9kZSwgXCJicG1uOlN0YXJ0RXZlbnRcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUuJHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS4kcGFyZW50LmlkID09PSBzdWJwcm9jSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aWluc3RhbmNlQWN0aXZpdGllcy5pbmRleE9mKG5vZGVJZCkgPj0gMCB8fCBjYWxsQWN0aXZpdGllcy5pbmRleE9mKG5vZGUuaWQpID49IDAgfHwgbm9uSW50ZXJydXB0aW5nRXZlbnRzLmluZGV4T2Yobm9kZS5pZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2dsb2JhbE5vZGVJbmRleE1hcC5nZXQobm9kZUlkKV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRyZW4uaW5kZXhPZihub2RlSWQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLiRwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiMGJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbE5vZGVJbmRleE1hcC5nZXQoc3VicHJvY0lkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2dsb2JhbE5vZGVJbmRleE1hcC5nZXQoc3VicHJvY0lkKV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0luZm8ubm9kZUxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobm9kZUlkID0+IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS4kcGFyZW50ICYmIGNoaWxkcmVuLmluZGV4T2Yobm9kZS4kcGFyZW50LmlkKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2dsb2JhbE5vZGVJbmRleE1hcC5nZXQobm9kZS5pZCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaGluZ01lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGV2dElkID0+IGdsb2JhbE5vZGVNYXAuZ2V0KGV2dElkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGV2dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2dC5hdHRhY2hlZFRvUmVmICYmIGNoaWxkcmVuLmluZGV4T2YoZXZ0LmF0dGFjaGVkVG9SZWYpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0YXJyYXlbZ2xvYmFsTm9kZUluZGV4TWFwLmdldChldnQuaWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJpdGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJpdGFycmF5W2ldID8gXCIxXCIgOiBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gJzBiJyA/IG5ldyBCaWdOdW1iZXIoMCkgOiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicHJvY2Vzc1N0YXJ0TWFya2luZzogc3VicHJvY2Vzc0lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvU2VhcmNoID0gZ2xvYmFsTm9kZU1hcC5nZXQoc3VicHJvY2Vzc0lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpdGFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBcIjBiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyh0b1NlYXJjaCwgXCJicG1uOkJvdW5kYXJ5RXZlbnRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG91dGdvaW5nIG9mIHRvU2VhcmNoLm91dGdvaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2NvbnRyb2xGbG93SW5mby5lZGdlSW5kZXhNYXAuZ2V0KG91dGdvaW5nLmlkKV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0b1NlYXJjaC5mbG93RWxlbWVudHMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPT4gaXMoZSwgXCJicG1uOkZsb3dOb2RlXCIpICYmIGlzKGUsIFwiYnBtbjpTdGFydEV2ZW50XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuJHBhcmVudC5pZCA9PT0gc3VicHJvY2Vzc0lkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdsb2JhbE5vZGVNYXAuZ2V0KG5vZGUuJHBhcmVudC5pZCkudHJpZ2dlcmVkQnlFdmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ldmVudERlZmluaXRpb25zICYmIG5vZGUuZXZlbnREZWZpbml0aW9uc1swXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMobm9kZS5ldmVudERlZmluaXRpb25zWzBdLCBcImJwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvblwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5WzBdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5vdXRnb2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG91dGdvaW5nIG9mIG5vZGUub3V0Z29pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0YXJyYXlbY29udHJvbEZsb3dJbmZvLmVkZ2VJbmRleE1hcC5nZXQob3V0Z29pbmcuaWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJpdGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJpdGFycmF5W2ldID8gXCIxXCIgOiBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIocmVzdWx0KS50b0ZpeGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRBbGxBbmNlc3RvcnNNYXNrOiBzdWJwcm9jSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0YXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiMGJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChzdWJwcm9jSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZS4kcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRhcnJheVtjb250cm9sRmxvd0luZm8ubm9kZUluZGV4TWFwLmdldChub2RlLmlkKV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuJHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gYml0YXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYml0YXJyYXlbaV0gPyBcIjFcIiA6IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihyZXN1bHQpLnRvRml4ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnByb2Nlc3NNYXJraW5nOiBzdWJwcm9jZXNzSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0YXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiMGJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsSW5mbyA9IGdsb2JhbENvbnRyb2xGbG93SW5mb01hcC5nZXQoc3VicHJvY2Vzc0lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVkZ2VMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsSW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS4kcGFyZW50ICYmIG5vZGUuJHBhcmVudC5pZCA9PT0gc3VicHJvY2Vzc0lkICYmIG5vZGUuaW5jb21pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmNvbWluZyBvZiBub2RlLmluY29taW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VMaXN0LnB1c2goaW5jb21pbmcuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VMaXN0LmZvckVhY2goZWRnZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2NvbnRyb2xGbG93SW5mby5lZGdlSW5kZXhNYXAuZ2V0KGVkZ2VJZCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicHJvY2Vzc0Z1bGxNYXJraW5nOiBzdWJwcm9jSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0YXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiMGJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gW3N1YnByb2NJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMobm9kZSwgXCJicG1uOlN1YlByb2Nlc3NcIikgJiYgbXVsdGlpbnN0YW5jZUFjdGl2aXRpZXMuaW5kZXhPZihub2RlSWQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlLiRwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuJHBhcmVudC5pZCA9PT0gc3VicHJvY0lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4uaW5kZXhPZihub2RlSWQpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS4kcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goc3VicHJvY2Vzc0lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbEluZm8gPSBnbG9iYWxDb250cm9sRmxvd0luZm9NYXAuZ2V0KHN1YnByb2Nlc3NJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEluZm8uZWRnZUxpc3QuZm9yRWFjaChlZGdlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2NvbnRyb2xGbG93SW5mby5lZGdlSW5kZXhNYXAuZ2V0KGVkZ2VJZCldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJpdGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJpdGFycmF5W2ldID8gXCIxXCIgOiBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIocmVzdWx0KS50b0ZpeGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG93RWRnZUluZGV4OiBmbG93RWRnZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpdGFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdGFycmF5W2NvbnRyb2xGbG93SW5mby5lZGdlSW5kZXhNYXAuZ2V0KGZsb3dFZGdlSWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBcIjBiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvd05vZGVJbmRleDogZmxvd05vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRhcnJheVtnbG9iYWxOb2RlSW5kZXhNYXAuZ2V0KGZsb3dOb2RlSWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBcIjBiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlYWxJbmRleDogbm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbE5vZGVJbmRleE1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFydE9mRGVmZXJyZWRDaG9pY2U6IGV2ZW50SWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSBnbG9iYWxOb2RlTWFwLmdldChldmVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmluY29taW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGV2ZW50LmluY29taW5nWzBdLnNvdXJjZVJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpcyhub2RlLCBcImJwbW46RXZlbnRCYXNlZEdhdGV3YXlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RGVmZXJyZWRDaG9pY2VFbGVtZW50czogbm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuaW5jb21pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZXZlbnQuaW5jb21pbmdbMF0uc291cmNlUmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKG5vZGUsIFwiYnBtbjpFdmVudEJhc2VkR2F0ZXdheVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG91dGdvaW5nIG9mIG5vZGUub3V0Z29pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGdvaW5nLnRhcmdldFJlZi5pZCAhPT0gbm9kZUlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gob3V0Z29pbmcudGFyZ2V0UmVmLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2hvaWNlTm9kZU1hcmtpbmc6IG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudCA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaXRhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuaW5jb21pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZXZlbnQuaW5jb21pbmdbMF0uc291cmNlUmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKG5vZGUsIFwiYnBtbjpFdmVudEJhc2VkR2F0ZXdheVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG91dGdvaW5nIG9mIG5vZGUub3V0Z29pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0YXJyYXlbY29udHJvbEZsb3dJbmZvLm5vZGVJbmRleE1hcC5nZXQob3V0Z29pbmcudGFyZ2V0UmVmLmlkKV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDaG9pY2VNYXJraW5nOiBldmVudElkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gZ2xvYmFsTm9kZU1hcC5nZXQoZXZlbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZXZlbnQuaW5jb21pbmdbMF0uc291cmNlUmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0YXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiMGJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub3V0Z29pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBvdXRnb2luZyBvZiBub2RlLm91dGdvaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0YXJyYXlbY29udHJvbEZsb3dJbmZvLmVkZ2VJbmRleE1hcC5nZXQob3V0Z29pbmcuaWQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcmVzdWx0ID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBiaXRhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBiaXRhcnJheVtpXSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRGVjbGFyYXRpb25zOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sRmxvd0luZm8uZ2xvYmFsUGFyYW1ldGVycy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xGbG93SW5mby5nbG9iYWxQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3JhY2xlRnVuY3Rpb246IG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sRmxvd0luZm8ub3JhY2xlVGFza01hcC5oYXMobm9kZUlkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sRmxvd0luZm8ub3JhY2xlSW5mby5nZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm9yYWNsZVRhc2tNYXAuZ2V0KG5vZGVJZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkuZnVuY3Rpb25OYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVQYXJhbWV0ZXJzOiBub2RlSWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmRvY3VtZW50YXRpb24gJiYgbm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQgJiYgbm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc0RpY3QgPSBleHRyYWN0UGFyYW1ldGVycyhub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCwgbm9kZUlkLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNEaWN0ICE9PSB1bmRlZmluZWQgPyByZXNEaWN0LmdldChcImlucHV0XCIpLmxlbmd0aCA+IDAgfHwgcmVzRGljdC5nZXQoXCJvdXRwdXRcIikubGVuZ3RoID4gMCA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzOiAobm9kZUlkLCBpc0lucHV0LCBoYXNQcmV2aW91c1BhcmFtZXRlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5kb2N1bWVudGF0aW9uICYmIG5vZGUuZG9jdW1lbnRhdGlvblswXS50ZXh0ICYmIG5vZGUuZG9jdW1lbnRhdGlvblswXS50ZXh0Lmxlbmd0aCA+IDAgJiYgZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGVJZCwgbnVsbCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsUGFyYW1zID0gaXNJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGVJZCwgbnVsbCkuZ2V0KFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGV4dHJhY3RQYXJhbWV0ZXJzKG5vZGUuZG9jdW1lbnRhdGlvblswXS50ZXh0LCBub2RlSWQsIG51bGwpLmdldChcIm91dHB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gbG9jYWxQYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBsb2NhbFBhcmFtcy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiLCBcIiArIGxvY2FsUGFyYW1zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNQcmV2aW91c1BhcmFtZXRlciAmJiByZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIiwgXCIgKyByZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2F0UGFyYW1ldGVyczogKG5vZGVJZCwgaXNJbnB1dCwgaGFzVHlwZSwgaGFzUHJldmlvdXNQYXJhbWV0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZG9jdW1lbnRhdGlvbiAmJiBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCAmJiBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dC5sZW5ndGggPiAwICYmIGV4dHJhY3RQYXJhbWV0ZXJzKG5vZGUuZG9jdW1lbnRhdGlvblswXS50ZXh0LCBub2RlSWQsIG51bGwpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbFBhcmFtcyA9IGlzSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGV4dHJhY3RQYXJhbWV0ZXJzKG5vZGUuZG9jdW1lbnRhdGlvblswXS50ZXh0LCBub2RlSWQsIG51bGwpLmdldChcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBleHRyYWN0UGFyYW1ldGVycyhub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCwgbm9kZUlkLCBudWxsKS5nZXQoXCJvdXRwdXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGhhc1R5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsb2NhbFBhcmFtc1swXSArIFwiIFwiICsgbG9jYWxQYXJhbXNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBsb2NhbFBhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGxvY2FsUGFyYW1zLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gXCIsXCIgKyAoaGFzVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsb2NhbFBhcmFtc1tpXSArIFwiIFwiICsgbG9jYWxQYXJhbXNbaSArIDFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxvY2FsUGFyYW1zW2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc1ByZXZpb3VzUGFyYW1ldGVyICYmIHJlcy5sZW5ndGggPiAwID8gXCIsIFwiICsgcmVzIDogcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUZ1bmN0aW9uQm9keTogbm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnNjcmlwdC5zcGxpdChcIi0+XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuZG9jdW1lbnRhdGlvbiAmJiBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCAmJiBub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dC5sZW5ndGggPiAwICYmIGV4dHJhY3RQYXJhbWV0ZXJzKG5vZGUuZG9jdW1lbnRhdGlvblswXS50ZXh0LCBub2RlSWQsIG51bGwpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHRyYWN0UGFyYW1ldGVycyhub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCwgbm9kZUlkLCBudWxsKS5nZXQoXCJib2R5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25kaXRpb246IGZsb3dFZGdlID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb3dFZGdlLmNvbmRpdGlvbkV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmxvd0VkZ2UuY29uZGl0aW9uRXhwcmVzc2lvbi5ib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZsb3dFZGdlLm5hbWUgPyBmbG93RWRnZS5uYW1lIDogZmxvd0VkZ2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXM6IGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbG9jYWxTb2xpZGl0eSA9IGJwbW4yc29sVGVtcGxhdGUoY29kZUdlbmVyYXRpb25JbmZvKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29kZSBmb3IgdXNpbmcgdGhlIFdvcmtMaXN0IHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXNlclRhc2tMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyYW1ldGVySW5mbzogTWFwPHN0cmluZywgTWFwPHN0cmluZywgQXJyYXk8UGFyYW1ldGVySW5mbz4+PiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCAnYnBtbjpVc2VyVGFzaycpIHx8IGlzKG5vZGUsICdicG1uOlJlY2VpdmVUYXNrJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlclRhc2tMaXN0LnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xGbG93SW5mby5sb2NhbFBhcmFtZXRlcnMuaGFzKG5vZGVJZCkgJiYgKGNvbnRyb2xGbG93SW5mby5sb2NhbFBhcmFtZXRlcnMuZ2V0KG5vZGVJZCkuZ2V0KCdpbnB1dCcpLmxlbmd0aCA+IDAgfHwgY29udHJvbEZsb3dJbmZvLmxvY2FsUGFyYW1ldGVycy5nZXQobm9kZUlkKS5nZXQoJ291dHB1dCcpLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJJbmZvLnNldChub2RlSWQsIGNvbnRyb2xGbG93SW5mby5sb2NhbFBhcmFtZXRlcnMuZ2V0KG5vZGVJZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbEZsb3dJbmZvLmNhdGNoaW5nTWVzc2FnZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyVGFza0xpc3QgPSB1c2VyVGFza0xpc3QuY29uY2F0KGNvbnRyb2xGbG93SW5mby5jYXRjaGluZ01lc3NhZ2VzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV29ya0xpc3Q6IFNtYXJ0IENvbnRyYWN0IEdlbmVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3b3JrTGlzdEdlbmVyYXRpb25JbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMaXN0OiB1c2VyVGFza0xpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdHJpY3RSZWxhdGlvbjogcmVzdHJpY3RSZWxhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJJbmZvOiBwYXJhbWV0ZXJJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleDogZ2xvYmFsTm9kZUluZGV4TWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVNYXA6IGdsb2JhbE5vZGVNYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0lkOiAoKSA9PiBjb250cm9sRmxvd0luZm8uc2VsZi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlTmFtZTogbm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE5vZGVOYW1lKGdsb2JhbE5vZGVNYXAuZ2V0KG5vZGVJZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UGFyYW1ldGVyVHlwZTogKG5vZGVJZCwgaXNJbnB1dCwgaXNUeXBlLCBoYXNQcmV2aW91cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlckluZm8uZ2V0KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbFBhcmFtcyA9IGlzSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtZXRlckluZm8uZ2V0KG5vZGVJZCkuZ2V0KFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmFtZXRlckluZm8uZ2V0KG5vZGVJZCkuZ2V0KFwib3V0cHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsUGFyYW1zICYmIGxvY2FsUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBpc1R5cGUgPyBsb2NhbFBhcmFtc1swXS50eXBlIDogbG9jYWxQYXJhbXNbMF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxvY2FsUGFyYW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gaXNUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiLCBcIiArIGxvY2FsUGFyYW1zW2ldLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCIsIFwiICsgbG9jYWxQYXJhbXNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmxlbmd0aCA+IDAgJiYgaGFzUHJldmlvdXMgPyBcIiwgXCIgKyByZXMgOiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRQYXJhbWV0ZXJzOiAobm9kZUlkLCBpc0lucHV0LCBoYXNUeXBlLCBoYXNQcmV2aW91cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlckluZm8uZ2V0KG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbFBhcmFtcyA9IGlzSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtZXRlckluZm8uZ2V0KG5vZGVJZCkuZ2V0KFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmFtZXRlckluZm8uZ2V0KG5vZGVJZCkuZ2V0KFwib3V0cHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsUGFyYW1zICYmIGxvY2FsUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBoYXNUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbG9jYWxQYXJhbXNbMF0udHlwZSArIFwiIFwiICsgbG9jYWxQYXJhbXNbMF0ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxvY2FsUGFyYW1zWzBdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsb2NhbFBhcmFtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IGhhc1R5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCIsIFwiICsgbG9jYWxQYXJhbXNbaV0udHlwZSArIFwiIFwiICsgbG9jYWxQYXJhbXNbaV0ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIiwgXCIgKyBsb2NhbFBhcmFtc1tpXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMubGVuZ3RoID4gMCAmJiBoYXNQcmV2aW91cyA/IFwiLCBcIiArIHJlcyA6IHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFdvcmtJdGVtc0dyb3VwQnlQYXJhbWV0ZXJzOiAoaXNJbnB1dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZTJJZHM6IE1hcDxzdHJpbmcsIHN0cmluZ1tdPiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dJbmZvLm5vZGVMaXN0LmZvckVhY2gobm9kZUlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZ2xvYmFsTm9kZU1hcC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyhub2RlLCAnYnBtbjpVc2VyVGFzaycpIHx8IGlzKG5vZGUsICdicG1uOlJlY2VpdmVUYXNrJykgfHwgY2F0Y2hpbmdNZXNzYWdlcy5pbmRleE9mKG5vZGVJZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJhbXMgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmRvY3VtZW50YXRpb24gJiYgbm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQgJiYgbm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQubGVuZ3RoID4gMCAmJiBleHRyYWN0UGFyYW1ldGVycyhub2RlLmRvY3VtZW50YXRpb25bMF0udGV4dCwgbm9kZUlkLCBudWxsKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbFBhcmFtcyA9IGlzSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGVJZCwgbnVsbCkuZ2V0KFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXh0cmFjdFBhcmFtZXRlcnMobm9kZS5kb2N1bWVudGF0aW9uWzBdLnRleHQsIG5vZGVJZCwgbnVsbCkuZ2V0KFwib3V0cHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gbG9jYWxQYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGxvY2FsUGFyYW1zLmxlbmd0aDsgaSArPSAyKSBwYXJhbXMgKz0gbG9jYWxQYXJhbXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBnZXROb2RlTmFtZShnbG9iYWxOb2RlTWFwLmdldChub2RlSWQpKSArIHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWUySWRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lMklkcy5zZXQobmFtZSwgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lMklkcy5nZXQobmFtZSkucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUySWRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXM6IGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxJbmZvLnNvbGlkaXR5ICs9IGxvY2FsU29saWRpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlclRhc2tMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbEluZm8uc29saWRpdHkgKz0gd29ya0xpc3Qyc29sVGVtcGxhdGUod29ya0xpc3RHZW5lcmF0aW9uSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbEluZm8uY29udHJvbEZsb3dJbmZvTWFwLnNldChjb250cm9sRmxvd0luZm8uc2VsZi5pZCwgY29udHJvbEZsb3dJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlTGlzdC5mb3JFYWNoKG5vZGVJZCA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5ub2RlSW5kZXhNYXAuc2V0KG5vZGVJZCwgZ2xvYmFsTm9kZUluZGV4TWFwLmdldChub2RlSWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5lZGdlTGlzdC5mb3JFYWNoKGVkZ2VJZCA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xGbG93SW5mby5lZGdlSW5kZXhNYXAuc2V0KGVkZ2VJZCwgZ2xvYmFsRWRnZUluZGV4TWFwLmdldChlZGdlSWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgICAgICAgIG1vZGVsSW5mby5lbnRyeUNvbnRyYWN0TmFtZSA9IG1vZGVsSW5mby5uYW1lICsgXCI6XCIgKyAocHJvYy5uYW1lID8gcHJvYy5uYW1lLnJlcGxhY2UoL1xccysvZywgXCJfXCIpIDogcHJvYy5pZCkgKyBcIl9Db250cmFjdFwiO1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXJzZU1vZGVsXG4iXX0=