"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/* babel-plugin-inline-import '../../../abstract/AbstractFactory.sol' */
const abstractFactory = "pragma solidity ^0.5.6;\n\ncontract AbstractFactory {\n    address internal worklist = address(0);\n\n    function setWorklist(address _worklist) public {\n        worklist = _worklist;\n    }\n\n    function newInstance(address parent, address globalFactory) public returns(address);\n    function startInstanceExecution(address processAddress) public;\n}\n";

/* babel-plugin-inline-import '../../../abstract/AbstractRegistry.sol' */
const abstractRegistry = "pragma solidity ^0.5.6;\n\ncontract AbstractRegistry {\n\n    function registerFactory(bytes32 bundleId, address factory) public;\n\n    function registerWorklist(bytes32 bundleId, address worklist) public;\n\n    function allInstances() public returns(address[] memory);\n\n    function newInstanceFor(uint nodeIndex, address parent) public returns(address);\n\n    function newBundleInstanceFor(bytes32 bundleId, address parent) public returns(address);\n\n    function bundleFor(address processInstance) public returns(bytes32);\n\n    function worklistBundleFor(address worklist) public returns(bytes32);\n\n    // Functions for Dynamic Bindings\n    function bindingPolicyFor(address processInstance) public view returns(bytes32);\n\n    function taskRoleMapFor(address processInstance) public view returns(bytes32);\n\n    function relateProcessToPolicy(bytes32 bundleId, bytes32 _taskRole, bytes32 _policy) external;\n\n    function canPerform(address actor, address processCase, uint taskIndex) external view returns(bool);\n}\n";

/* babel-plugin-inline-import '../../../abstract/AbstractWorklist.sol' */
const abstractWorklist = "pragma solidity ^0.5.6;\n\ncontract IRFunct {\n    function findRuntimePolicy(address pCase) public view returns(address);\n    function canPerform(address actor, address pCase, uint taskIndex) public view returns(bool);\n}\n\ncontract AbstractWorklist {\n\n    struct Workitem {\n        uint elementIndex;\n        address processInstanceAddr;\n    }\n\n    Workitem[] internal workitems;\n    address internal runtimeRegistry;\n\n    function updateRuntimeRegistry(address _runtimeRegistry) public {\n        runtimeRegistry = _runtimeRegistry;\n    }\n\n    function workItemsFor(uint elementIndex, address processInstance) external view returns(uint) {\n        uint reqIndex = 0;\n        for (uint i = 0; i < workitems.length; i++) {\n            if (workitems[i].elementIndex == elementIndex && workitems[i].processInstanceAddr == processInstance)\n                reqIndex |= uint(1) << i;\n        }\n        return reqIndex;\n    }\n\n    function processInstanceFor(uint workitemId) public view returns(address) {\n        require(workitemId < workitems.length);\n        return workitems[workitemId].processInstanceAddr;\n    }\n\n    function elementIndexFor(uint workitemId) public view returns(uint) {\n        require(workitemId < workitems.length);\n        return workitems[workitemId].elementIndex;\n    }\n\n    function canPerform(address actor, address pCase, uint elementIndex) internal view returns(bool) {\n        return IRFunct(IRFunct(runtimeRegistry).findRuntimePolicy(pCase)).canPerform(actor, pCase, elementIndex);\n    }\n}";

/* babel-plugin-inline-import '../../../abstract/ProcessRegistry.sol' */
const processRegistry = "pragma solidity ^0.5.6;\n\ncontract IFunct {\n    // WorkList functions\n    function updateRuntimeRegistry(address _runtimeRegistry) public;\n    // Factory Functions\n    function setWorklist(address _worklist) public;\n    function startInstanceExecution(address processAddress) public;\n    function newInstance(address parent, address globalFactory) public returns(address);\n    function findParent() public view returns(address);\n}\n\ncontract ProcessRegistry {\n\n    mapping (bytes32 => mapping (uint => bytes32)) private parent2ChildrenBundleId;\n    mapping (bytes32 => address) private factories;\n    mapping (bytes32 => bytes32) private policy;\n    mapping (bytes32 => bytes32) private taskRole;\n\n    mapping (address => bytes32) private instance2Bundle;\n    mapping (address => address) private instance2PolicyOp;\n    address[] private instances;\n\n    mapping (address => bytes32) private worklist2Bundle;\n\n    event NewInstanceCreatedFor(address parent, address processAddress);\n\n    function registerFactory(bytes32 bundleId, address factory) external {\n        factories[bundleId] = factory;\n    }\n\n    function registerWorklist(bytes32 bundleId, address worklist) external {\n        address factory = factories[bundleId];\n        require(factory != address(0));\n        worklist2Bundle[worklist] = bundleId;\n        IFunct(factory).setWorklist(worklist);\n        IFunct(worklist).updateRuntimeRegistry(address(this));\n    }\n\n    function findRuntimePolicy(address pCase) public view returns(address) {\n        return instance2PolicyOp[pCase];\n    }\n\n    function relateProcessToPolicy(bytes32 bundleId, bytes32 _policy, bytes32 _taskRole) external {\n        taskRole[bundleId] = _taskRole;\n        policy[bundleId] = _policy;\n    }\n\n\n    function addChildBundleId(bytes32 parentBundleId, bytes32 processBundleId, uint nodeIndex) external {\n        parent2ChildrenBundleId[parentBundleId][nodeIndex] = processBundleId;\n    }\n\n    function newInstanceFor(uint nodeIndex, address parent) public returns(address) {\n        return newBundleInstanceFor(parent2ChildrenBundleId[instance2Bundle[parent]][nodeIndex], parent, instance2PolicyOp[parent]);\n    }\n\n    function newBundleInstanceFor(bytes32 bundleId, address parent, address policyOpAddr) public returns(address) {\n        address factory = factories[bundleId];\n        require(factory != address(0));\n        address processAddress = IFunct(factory).newInstance(parent, address(this));\n        instance2Bundle[processAddress] = bundleId;\n        instance2PolicyOp[processAddress] = policyOpAddr;\n        instances.push(processAddress);\n        IFunct(factory).startInstanceExecution(processAddress);\n        emit NewInstanceCreatedFor(parent, processAddress);\n        return processAddress;\n    }\n\n    function allInstances() external view returns(address[] memory) {\n        return instances;\n    }\n    \n    function bindingPolicyFor(address procInstance) external view returns(bytes32) {\n        bytes32 pId = instance2Bundle[procInstance];\n        address pAddr = procInstance;\n        while(policy[pId].length != 0) {\n            pAddr = IFunct(pAddr).findParent();\n            if(pAddr == address(0))\n                break;\n            pId = instance2Bundle[pAddr];\n        }\n        return policy[pId];\n    }\n\n    function taskRoleMapFor(address procInstance) external view returns(bytes32) {\n        bytes32 pId = instance2Bundle[procInstance];\n        address pAddr = procInstance;\n        while(taskRole[pId].length != 0) {\n            pAddr = IFunct(pAddr).findParent();\n            if(pAddr == address(0))\n                break;\n            pId = instance2Bundle[pAddr];\n        }\n        return taskRole[pId];\n    }\n\n    function bindingPolicyFromId(bytes32 procId) external view returns(bytes32) {\n        return policy[procId];\n    }\n\n    function taskRoleMapFromId(bytes32 procId) external view returns(bytes32) {\n        return taskRole[procId];\n    }\n\n    function bundleFor(address processInstance) external view returns(bytes32) {\n        return instance2Bundle[processInstance];\n    }\n\n    function childrenFor(bytes32 parent, uint nodeInd) external view returns(bytes32) {\n        return parent2ChildrenBundleId[parent][nodeInd];\n    }\n\n    function worklistBundleFor(address worklist) external view returns(bytes32) {\n        return worklist2Bundle[worklist];\n    }\n}";

/* babel-plugin-inline-import '../../../abstract/AbstractProcess.sol' */
const abstractProcess = "pragma solidity ^0.5.6;\n\nimport \"AbstractRegistry\";\n\n\ncontract AbstractProcess {\n    address internal owner;\n    address internal parent;\n    address internal worklist;\n    uint internal instanceIndex;\n    address internal processRegistry;\n\n    constructor(address _parent, address _worklist, address _processRegistry) public {\n        owner = msg.sender;\n        parent = _parent;\n        worklist = _worklist;\n        processRegistry = _processRegistry;\n    }\n\n    function setInstanceIndex(uint _instanceIndex) public {\n        require(msg.sender == parent);\n        instanceIndex = _instanceIndex;\n    }\n\n    function findParent() public view returns(address) {\n        return parent;\n    }\n\n    function handleEvent(bytes32 code, bytes32 eventType, uint _instanceIndex, bool isInstanceCompleted) public;\n    function killProcess() public;\n    function startExecution() public;\n    function broadcastSignal() public;\n\n    function killProcess(uint processElementIndex, uint marking, uint startedActivities) internal returns(uint, uint);\n    function broadcastSignal(uint tmpMarking, uint tmpStartedActivities, uint sourceChild) internal returns(uint, uint);\n\n    function propagateEvent(bytes32 code, bytes32 eventType, uint tmpMarking, uint tmpStartedActivities, uint sourceChild) internal returns(uint, uint) {\n        if (eventType == \"Error\" || eventType == \"Terminate\")\n            (tmpMarking, tmpStartedActivities) = killProcess(0, tmpMarking, tmpStartedActivities);\n        else if (eventType == \"Signal\")\n            (tmpMarking, tmpStartedActivities) = broadcastSignal(tmpMarking, tmpStartedActivities, sourceChild);\n        if (parent != 0x0000000000000000000000000000000000000000)\n            AbstractProcess(parent).handleEvent(code, eventType, instanceIndex, tmpMarking | tmpStartedActivities == 0);\n        return (tmpMarking, tmpStartedActivities);\n    }\n}\n";
var _default = {
  AbstractFactory: {
    content: abstractFactory
  },
  AbstractRegistry: {
    content: abstractRegistry
  },
  AbstractWorklist: {
    content: abstractWorklist
  },
  ProcessRegistry: {
    content: processRegistry
  },
  AbstractProcess: {
    content: abstractProcess
  }
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2FwcC9yZXNvbHZlcnMvbXV0YXRpb24vbW9kZWwvc291cmNlcy50cyJdLCJuYW1lcyI6WyJBYnN0cmFjdEZhY3RvcnkiLCJjb250ZW50IiwiYWJzdHJhY3RGYWN0b3J5IiwiQWJzdHJhY3RSZWdpc3RyeSIsImFic3RyYWN0UmVnaXN0cnkiLCJBYnN0cmFjdFdvcmtsaXN0IiwiYWJzdHJhY3RXb3JrbGlzdCIsIlByb2Nlc3NSZWdpc3RyeSIsInByb2Nlc3NSZWdpc3RyeSIsIkFic3RyYWN0UHJvY2VzcyIsImFic3RyYWN0UHJvY2VzcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBT2U7QUFDYkEsRUFBQUEsZUFBZSxFQUFFO0FBQ2ZDLElBQUFBLE9BQU8sRUFBRUM7QUFETSxHQURKO0FBSWJDLEVBQUFBLGdCQUFnQixFQUFFO0FBQ2hCRixJQUFBQSxPQUFPLEVBQUVHO0FBRE8sR0FKTDtBQU9iQyxFQUFBQSxnQkFBZ0IsRUFBRTtBQUNoQkosSUFBQUEsT0FBTyxFQUFFSztBQURPLEdBUEw7QUFVYkMsRUFBQUEsZUFBZSxFQUFFO0FBQ2ZOLElBQUFBLE9BQU8sRUFBRU87QUFETSxHQVZKO0FBYWJDLEVBQUFBLGVBQWUsRUFBRTtBQUNmUixJQUFBQSxPQUFPLEVBQUVTO0FBRE07QUFiSixDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFic3RyYWN0RmFjdG9yeSBmcm9tICcuLi8uLi8uLi9hYnN0cmFjdC9BYnN0cmFjdEZhY3Rvcnkuc29sJ1xuaW1wb3J0IGFic3RyYWN0UmVnaXN0cnkgZnJvbSAnLi4vLi4vLi4vYWJzdHJhY3QvQWJzdHJhY3RSZWdpc3RyeS5zb2wnXG5pbXBvcnQgYWJzdHJhY3RXb3JrbGlzdCBmcm9tICcuLi8uLi8uLi9hYnN0cmFjdC9BYnN0cmFjdFdvcmtsaXN0LnNvbCdcbmltcG9ydCBwcm9jZXNzUmVnaXN0cnkgZnJvbSAnLi4vLi4vLi4vYWJzdHJhY3QvUHJvY2Vzc1JlZ2lzdHJ5LnNvbCdcbmltcG9ydCBhYnN0cmFjdFByb2Nlc3MgZnJvbSAnLi4vLi4vLi4vYWJzdHJhY3QvQWJzdHJhY3RQcm9jZXNzLnNvbCdcbmltcG9ydCBiaW5kaW5nQWNjZXNzQ29udHJvbCBmcm9tICcuLi8uLi8uLi9hYnN0cmFjdC9CaW5kaW5nQWNjZXNzQ29udHJvbC5zb2wnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQWJzdHJhY3RGYWN0b3J5OiB7XG4gICAgY29udGVudDogYWJzdHJhY3RGYWN0b3J5LFxuICB9LFxuICBBYnN0cmFjdFJlZ2lzdHJ5OiB7XG4gICAgY29udGVudDogYWJzdHJhY3RSZWdpc3RyeSxcbiAgfSxcbiAgQWJzdHJhY3RXb3JrbGlzdDoge1xuICAgIGNvbnRlbnQ6IGFic3RyYWN0V29ya2xpc3QsXG4gIH0sXG4gIFByb2Nlc3NSZWdpc3RyeToge1xuICAgIGNvbnRlbnQ6IHByb2Nlc3NSZWdpc3RyeSxcbiAgfSxcbiAgQWJzdHJhY3RQcm9jZXNzOiB7XG4gICAgY29udGVudDogYWJzdHJhY3RQcm9jZXNzLFxuICB9LFxufVxuIl19