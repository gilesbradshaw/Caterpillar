"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _debug2 = _interopRequireDefault(require("debug"));

var _compile = _interopRequireDefault(require("../../../../out/resolvers/util/compile"));

var _registryContract = _interopRequireDefault(require("../../../../out/resolvers/util/registry-contract"));

var _BindingPolicyGenerator = require("./dynamic_binding/validation_code_gen/BindingPolicyGenerator");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* babel-plugin-inline-import './dynamic_binding/runtime_solidity/BindingAccessControl.sol' */
const bindingPolicy = "pragma solidity ^0.4.25;\n\n// Function assertVote will return 0 -> UNBOUND, 1 -> NOMINATED, 2 -> RELEASING, 3 -> BOUND\ncontract BindingPolicy {\n\n    function isCaseCreator(uint roleIndex) public pure returns(bool);\n    function canNominate (uint rNominator, uint rNominee) public pure returns(bool);\n    function assertNConstraint (uint rNominator, uint rNominee, uint nomineeRoles) public pure returns(bool);\n    function requireNEndorsement (uint rNominator, uint rNominee) public pure returns(bool);\n    function assertNVote (uint rNominator, uint rNominee, uint rEndorser, uint endorsedBy, uint rejectedBy, bool isAccepted) public pure returns(uint);\n    \n    function canRelease (uint rNominator, uint rNominee) public pure returns(bool);\n    function assertRConstraint (uint rNominator, uint rNominee, uint nomineeRoles) public pure returns(bool);\n    function requireREndorsement (uint rNominator, uint rNominee) public pure returns(bool);\n    function assertRVote (uint rNominator, uint rNominee, uint rEndorser, uint endorsedBy, uint rejectedBy, bool isAccepted) public pure returns(uint);\n}\n\ncontract ControlFlow {\n    function findParent() public view returns(address);\n    function getRoleFromTask(uint taskIndex, bytes32 processId) public pure returns(uint);\n    function bundleFor(address pCase) external view returns(bytes32);\n} \n\n\ncontract BindingAccessControl {\n    \n    address private policyAdr;\n    address private taskRoleAdr;\n    address private registry;\n    \n    struct BindingInfo {\n        uint nominator;\n        uint nominee;\n        uint endorsedBy;\n        uint rejectedBy;\n        \n        // 0- UNBOUND, 1- RELEASING, 2- NOMINATED, 3- BOUND\n        uint bindingState;\n    }\n    \n    mapping (address => uint) private actorIndex;\n    uint private actorCount = 1;\n    \n    mapping (address => uint) private caseIndex;\n    uint private caseCount = 1;\n    \n    // caseIndex => roleIndex => actorIndex\n    mapping (uint => mapping (uint => BindingInfo)) private roleBindingState;\n    \n    // actorIndex => acceptedRoleIndexMask\n    mapping (uint => uint) private actorRoles;\n    \n    constructor(address _registry, address _policy, address _taskRoleAdr) public {\n        policyAdr = _policy;\n        taskRoleAdr = _taskRoleAdr;\n        registry = _registry;\n    }\n\n    function roleState (uint role, address pCase) public view returns(uint) {\n        return roleBindingState[caseIndex[pCase]][role].bindingState;\n    }\n\n    function nominateCaseCreator (uint rNominee, address nominee, address pCase) public {\n\n        require(actorCount == 1 && BindingPolicy(policyAdr).isCaseCreator(rNominee));\n        \n        uint creatorIndex = actorIndex[nominee] = actorCount++;\n        uint pCaseIndex = caseIndex[pCase] = caseCount++;\n        \n        roleBindingState[pCaseIndex][rNominee] = BindingInfo(creatorIndex, creatorIndex, 0, 0, 3);\n        actorRoles[creatorIndex] = uint(1) << rNominee;\n        \n    }\n    \n    function nominate (uint rNominator, uint rNominee, address nominator, address nominee, address pCase) public {\n\n        // Verify that @processCase is a child in the process hierarchy where root is the process-case provided when nominated the process-creator.\n        // This verification can be done via the RuntimeRegistry in order to keep the consistency between control-flow, worklist and binding-control.\n        \n        uint iNominee = actorIndex[nominee];\n        uint iCase = caseIndex[pCase];\n        uint nomineeMask = uint(1) << rNominee;\n        uint iNominator = actorIndex[nominator];\n\n        // no actor can be BOUND/NOMINATED in pCase, the noinee cannot hold the rNominee role\n        // nominator actor must be binded to a role unless self-nomination is allowed\n        // the role of the nominator is allowed to nominate in the binding policy.\n        // the requested nomination fulfill the conditions defined in the policy by the instructions IN / NOT IN\n        require(roleBindingState[iCase][rNominee].bindingState == 0 && actorRoles[iNominee] & nomineeMask == 0 &&\n                (actorRoles[iNominator] & (uint(1) << rNominator) != 0 || (iNominator == 0 && rNominator == rNominee)) &&\n                (BindingPolicy(policyAdr).canNominate(rNominator, rNominee)) &&\n                (BindingPolicy(policyAdr).assertNConstraint(rNominator, rNominee, actorRoles[iNominee])));\n        \n        // At this point, all the conditions were fulfilled because otherwise an exception was thrown reverting the transaction. Thus the binding is allowed.\n        \n        // Verifying that all the indexes (for actors and process-cases) were already assigned to an index.\n        if(iCase == 0)\n            iCase = caseIndex[pCase] = caseCount++;\n        if(iNominee == 0)\n            iNominee = actorIndex[nominee] = actorCount++;\n        if(iNominator == 0)\n            iNominator = iNominee;\n        \n        // Binding the role and updating the state as NOMINATED(2) or BOUND(3) depending on the nomination require endorsement or not.\n        uint state = BindingPolicy(policyAdr).requireNEndorsement(rNominator, rNominee) ? 2 : 3;\n        \n        roleBindingState[iCase][rNominee] = BindingInfo (iNominator, iNominee, 0, 0, state); \n        if(state == 3)\n            actorRoles[iNominee] |= nomineeMask;\n    }\n    \n    function voteN (uint rNominator, uint rNominee, uint rEndorser, address endorser, address pCase, bool isAccepted) public returns(uint) {\n        //require(runtimeRegistry == msg.sender);\n        \n        uint iCase = caseIndex[pCase];\n        BindingInfo memory roleVState = roleBindingState[iCase][rNominee];\n        \n        // A nomination to endorse must be in NOMINATED state\n        // The endorser must be nominated before (state BOUND) unless the endorser is the nominee accepting the nomination.\n        require(roleVState.bindingState == 2 && \n                (actorRoles[actorIndex[endorser]] & (uint(1) << rEndorser) != 0 || rEndorser == rNominee && roleVState.nominee == actorIndex[endorser]));\n        \n        // This function is responsible to evaluate the endorsment. \n        // An exception reverting the transaction is thwown in case of any invalid operation (e.g wrong endorser). \n        // Thus, this function only returns if the endorsement is performed. \n        uint state = BindingPolicy(policyAdr).assertNVote(rNominator, rNominee, rEndorser, roleVState.endorsedBy, roleVState.rejectedBy, isAccepted);\n            \n        // The storage is only updated if the endorsment is valid and thus performed.\n        roleBindingState[iCase][rNominee].bindingState = state;\n        updateVoteMask(iCase, rNominee, uint(1) << rEndorser, isAccepted);\n        if (state == 0 || state == 3) {\n            roleBindingState[iCase][rNominee].endorsedBy = roleBindingState[iCase][rNominee].rejectedBy = 0;\n            if (state == 3) \n                actorRoles[roleVState.nominee] |= ((uint(1) << rNominee));\n        }\n        return state;\n    }\n    \n    function release (uint rNominator, uint rNominee, address nominator, address pCase) public {\n        //require(runtimeRegistry == msg.sender);\n        \n        uint iCase = caseIndex[pCase];\n        \n        BindingInfo memory roleRState = roleBindingState[iCase][rNominee];\n        \n        // The endorser and the processCase address must be nominated before.\n        // Validating the rNomiator is allowed to release rNominee.\n        // Validating the release is not restricted by a binding constraint.\n        require(roleRState.bindingState == 3 && actorRoles[actorIndex[nominator]] & (uint(1) << rNominator) != 0 && \n                (BindingPolicy(policyAdr).canRelease(rNominator, rNominee)) && \n                (BindingPolicy(policyAdr).assertRConstraint(rNominator, rNominee, actorRoles[roleRState.nominee])));\n        \n        // Unbinding the role and updating the state as UNBINDING or UNBINDED depending on the dismisses require endorsement or not.\n        if(!BindingPolicy(policyAdr).requireREndorsement(rNominator, rNominee)) {\n            roleBindingState[iCase][rNominee].bindingState = 0;\n            actorRoles[roleRState.nominee] &= ~(uint(1) << rNominee);\n        }\n        else\n           roleBindingState[iCase][rNominee].bindingState = 1;\n    }\n    \n    function voteR (uint rNominator, uint rNominee, uint rEndorser, address endorser, address pCase, bool isAccepted) public returns(uint) {\n        // require(runtimeRegistry == msg.sender);\n        \n        uint iCase = caseIndex[pCase];\n        BindingInfo memory roleVRState = roleBindingState[iCase][rNominee];\n        \n        // A release to vote must be in RELEASING state\n        // The endorsed involved in the vote and the processCase address must be nominated before.\n        require(roleVRState.bindingState == 1 && actorRoles[actorIndex[endorser]] & (uint(1) << rEndorser) != 0);\n\n        // This function is responsible to evaluate the endorsment. \n        // An exception reverting the transaction is thwown in case of any invalid operation (e.g wrong endorser). \n        // Thus, that function only returns if the endorsement can be performed. \n        uint state = BindingPolicy(policyAdr).assertRVote(rNominator, rNominee, rEndorser, roleVRState.endorsedBy, roleVRState.rejectedBy, isAccepted);\n            \n        roleBindingState[iCase][rNominee].bindingState = state;\n        updateVoteMask(iCase, rNominee, uint(1) << rEndorser, isAccepted);\n        if (state == 0 || state == 3) {\n            roleBindingState[iCase][rNominee].endorsedBy = roleBindingState[iCase][rNominee].rejectedBy = 0;\n            if (state == 0)\n                actorRoles[roleVRState.nominee] &= ~(uint(1) << rNominee);\n        }\n        return state;\n    }\n        \n    \n    function canPerform(address actor, address pCase, uint taskIndex) public view returns(bool) {\n        bytes32 pId = ControlFlow(registry).bundleFor(pCase);\n        uint tRole = ControlFlow(taskRoleAdr).getRoleFromTask(taskIndex, pId);\n        uint iCase = caseIndex[pCase];\n        while(roleBindingState[iCase][tRole].bindingState != 3) {\n            pCase = ControlFlow(pCase).findParent();\n            if(pCase == 0)\n                break;\n            iCase = caseIndex[pCase];\n        }\n        return actorIndex[actor] > 0 && roleBindingState[iCase][tRole].nominee == actorIndex[actor];\n    }\n    \n    function updateVoteMask(uint iCase, uint rNominee, uint endorserMask, bool isAccepted) private {\n        if (isAccepted)\n            roleBindingState[iCase][rNominee].endorsedBy |= endorserMask;\n        else\n            roleBindingState[iCase][rNominee].rejectedBy |= endorserMask;\n    }\n}";
const debug = (0, _debug2.default)('caterpillarql:policy');

var _default = async ({
  model,
  registry,
  web3
}) => {
  const contract = await (0, _registryContract.default)({
    address: registry,
    web3
  });
  const policy = await (0, _BindingPolicyGenerator.generatePolicy)(model, 'BindingPolicy');
  debug('=============================================');
  debug("SOLIDITY CODE");
  debug('=============================================');
  debug(policy);
  debug('....................................................................');
  const output = (0, _compile.default)({
    BindingPolicy: {
      content: bindingPolicy
    }
  });

  if (!Object.keys(output.contracts).length) {
    debug('COMPILATION ERROR IN POLICY CONTRACTS');
    debug(output.errors);
    debug('----------------------------------------------------------------------------------------------');
    throw new Error('COMPILATION ERROR IN POLICY CONTRACTS');
  } // const procContract = new web3.eth.Contract(JSON.parse(output.contracts['BindingPolicy']['BindingPolicy_Contract'].abi));

};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2FwcC9yZXNvbHZlcnMvbXV0YXRpb24vcG9saWN5L2luZGV4LnRzIl0sIm5hbWVzIjpbImRlYnVnIiwibW9kZWwiLCJyZWdpc3RyeSIsIndlYjMiLCJjb250cmFjdCIsImFkZHJlc3MiLCJwb2xpY3kiLCJvdXRwdXQiLCJCaW5kaW5nUG9saWN5IiwiY29udGVudCIsImJpbmRpbmdQb2xpY3kiLCJPYmplY3QiLCJrZXlzIiwiY29udHJhY3RzIiwibGVuZ3RoIiwiZXJyb3JzIiwiRXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBSUEsTUFBTUEsS0FBSyxHQUFHLHFCQUFPLHNCQUFQLENBQWQ7O2VBRWUsT0FBTztBQUNwQkMsRUFBQUEsS0FEb0I7QUFFcEJDLEVBQUFBLFFBRm9CO0FBR3BCQyxFQUFBQTtBQUhvQixDQUFQLEtBSVE7QUFDckIsUUFBTUMsUUFBUSxHQUFHLE1BQU0sK0JBQWlCO0FBQ3RDQyxJQUFBQSxPQUFPLEVBQUVILFFBRDZCO0FBRXRDQyxJQUFBQTtBQUZzQyxHQUFqQixDQUF2QjtBQUlBLFFBQU1HLE1BQU0sR0FBRyxNQUFNLDRDQUFlTCxLQUFmLEVBQXNCLGVBQXRCLENBQXJCO0FBQ0FELEVBQUFBLEtBQUssQ0FBQywrQ0FBRCxDQUFMO0FBQ0FBLEVBQUFBLEtBQUssQ0FBQyxlQUFELENBQUw7QUFDQUEsRUFBQUEsS0FBSyxDQUFDLCtDQUFELENBQUw7QUFDQUEsRUFBQUEsS0FBSyxDQUFDTSxNQUFELENBQUw7QUFDQU4sRUFBQUEsS0FBSyxDQUFDLHNFQUFELENBQUw7QUFFQSxRQUFNTyxNQUFNLEdBQUcsc0JBQVE7QUFDckJDLElBQUFBLGFBQWEsRUFBRTtBQUNiQyxNQUFBQSxPQUFPLEVBQUVDO0FBREk7QUFETSxHQUFSLENBQWY7O0FBTUEsTUFBSSxDQUFDQyxNQUFNLENBQUNDLElBQVAsQ0FBWUwsTUFBTSxDQUFDTSxTQUFuQixFQUE4QkMsTUFBbkMsRUFBMkM7QUFDekNkLElBQUFBLEtBQUssQ0FBQyx1Q0FBRCxDQUFMO0FBQ0FBLElBQUFBLEtBQUssQ0FBQ08sTUFBTSxDQUFDUSxNQUFSLENBQUw7QUFDQWYsSUFBQUEsS0FBSyxDQUFDLGdHQUFELENBQUw7QUFDQSxVQUFNLElBQUlnQixLQUFKLENBQVUsdUNBQVYsQ0FBTjtBQUNELEdBdkJvQixDQXdCckI7O0FBRUQsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVidWcgZnJvbSAnZGVidWcnXG5pbXBvcnQgY29tcGlsZSBmcm9tICcuLi8uLi8uLi8uLi9vdXQvcmVzb2x2ZXJzL3V0aWwvY29tcGlsZSdcbmltcG9ydCByZWdpc3RyeUNvbnRyYWN0IGZyb20gJy4uLy4uLy4uLy4uL291dC9yZXNvbHZlcnMvdXRpbC9yZWdpc3RyeS1jb250cmFjdCdcbmltcG9ydCB7Z2VuZXJhdGVQb2xpY3l9IGZyb20gJy4vZHluYW1pY19iaW5kaW5nL3ZhbGlkYXRpb25fY29kZV9nZW4vQmluZGluZ1BvbGljeUdlbmVyYXRvcic7XG5pbXBvcnQge2dlbmVyYXRlUm9sZVRhc2tDb250cmFjdH0gZnJvbSAnLi9keW5hbWljX2JpbmRpbmcvdmFsaWRhdGlvbl9jb2RlX2dlbi9Qcm9jZXNzUm9sZUdlbmVyYXRvcic7XG5pbXBvcnQgYmluZGluZ1BvbGljeSBmcm9tICcuL2R5bmFtaWNfYmluZGluZy9ydW50aW1lX3NvbGlkaXR5L0JpbmRpbmdBY2Nlc3NDb250cm9sLnNvbCdcblxuY29uc3QgZGVidWcgPSBfZGVidWcoJ2NhdGVycGlsbGFycWw6cG9saWN5JylcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKHtcbiAgbW9kZWwsXG4gIHJlZ2lzdHJ5LFxuICB3ZWIzLFxufSk6IFByb21pc2U8b2JqZWN0PiA9PiB7XG4gIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgcmVnaXN0cnlDb250cmFjdCh7XG4gICAgYWRkcmVzczogcmVnaXN0cnksXG4gICAgd2ViMyxcbiAgfSlcbiAgY29uc3QgcG9saWN5ID0gYXdhaXQgZ2VuZXJhdGVQb2xpY3kobW9kZWwsICdCaW5kaW5nUG9saWN5Jyk7XG4gIGRlYnVnKCc9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0nKTtcbiAgZGVidWcoXCJTT0xJRElUWSBDT0RFXCIpO1xuICBkZWJ1ZygnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XG4gIGRlYnVnKHBvbGljeSlcbiAgZGVidWcoJy4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uJyk7XG5cbiAgY29uc3Qgb3V0cHV0ID0gY29tcGlsZSh7XG4gICAgQmluZGluZ1BvbGljeToge1xuICAgICAgY29udGVudDogYmluZGluZ1BvbGljeSxcbiAgICB9LFxuICB9KVxuXG4gIGlmICghT2JqZWN0LmtleXMob3V0cHV0LmNvbnRyYWN0cykubGVuZ3RoKSB7XG4gICAgZGVidWcoJ0NPTVBJTEFUSU9OIEVSUk9SIElOIFBPTElDWSBDT05UUkFDVFMnKTtcbiAgICBkZWJ1ZyhvdXRwdXQuZXJyb3JzKTtcbiAgICBkZWJ1ZygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgIHRocm93IG5ldyBFcnJvcignQ09NUElMQVRJT04gRVJST1IgSU4gUE9MSUNZIENPTlRSQUNUUycpXG4gIH1cbiAgLy8gY29uc3QgcHJvY0NvbnRyYWN0ID0gbmV3IHdlYjMuZXRoLkNvbnRyYWN0KEpTT04ucGFyc2Uob3V0cHV0LmNvbnRyYWN0c1snQmluZGluZ1BvbGljeSddWydCaW5kaW5nUG9saWN5X0NvbnRyYWN0J10uYWJpKSk7XG4gIFxufSJdfQ==