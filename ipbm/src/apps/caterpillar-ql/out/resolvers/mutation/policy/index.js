"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _debug2 = _interopRequireDefault(require("debug"));

var _compile = _interopRequireDefault(require("../../util/compile"));

var _registryContract = _interopRequireDefault(require("../../util/registry-contract"));

var _repo = require("../../repo");

var _BindingPolicyGenerator = require("./dynamic_binding/validation_code_gen/BindingPolicyGenerator");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* babel-plugin-inline-import './dynamic_binding/runtime_solidity/BindingAccessControl.sol' */
const bindingAccessControl = "pragma solidity ^0.5.0;\n\n// Function assertVote will return 0 -> UNBOUND, 1 -> NOMINATED, 2 -> RELEASING, 3 -> BOUND\ncontract BindingPolicy {\n\n    function isCaseCreator(uint roleIndex) public pure returns(bool);\n    function canNominate (uint rNominator, uint rNominee) public pure returns(bool);\n    function assertNConstraint (uint rNominator, uint rNominee, uint nomineeRoles) public pure returns(bool);\n    function requireNEndorsement (uint rNominator, uint rNominee) public pure returns(bool);\n    function assertNVote (uint rNominator, uint rNominee, uint rEndorser, uint endorsedBy, uint rejectedBy, bool isAccepted) public pure returns(uint);\n    \n    function canRelease (uint rNominator, uint rNominee) public pure returns(bool);\n    function assertRConstraint (uint rNominator, uint rNominee, uint nomineeRoles) public pure returns(bool);\n    function requireREndorsement (uint rNominator, uint rNominee) public pure returns(bool);\n    function assertRVote (uint rNominator, uint rNominee, uint rEndorser, uint endorsedBy, uint rejectedBy, bool isAccepted) public pure returns(uint);\n}\n\ncontract ControlFlow {\n    function findParent() public view returns(address);\n    function getRoleFromTask(uint taskIndex, bytes32 processId) public pure returns(uint);\n    function bundleFor(address pCase) external view returns(bytes32);\n} \n\n\ncontract BindingAccessControl {\n    \n    address private policyAdr;\n    address private taskRoleAdr;\n    address private registry;\n    \n    struct BindingInfo {\n        uint nominator;\n        uint nominee;\n        uint endorsedBy;\n        uint rejectedBy;\n        \n        // 0- UNBOUND, 1- RELEASING, 2- NOMINATED, 3- BOUND\n        uint bindingState;\n    }\n    \n    mapping (address => uint) private actorIndex;\n    uint private actorCount = 1;\n    \n    mapping (address => uint) private caseIndex;\n    uint private caseCount = 1;\n    \n    // caseIndex => roleIndex => actorIndex\n    mapping (uint => mapping (uint => BindingInfo)) private roleBindingState;\n    \n    // actorIndex => acceptedRoleIndexMask\n    mapping (uint => uint) private actorRoles;\n    \n    constructor(address _registry, address _policy, address _taskRoleAdr) public {\n        policyAdr = _policy;\n        taskRoleAdr = _taskRoleAdr;\n        registry = _registry;\n    }\n\n    function roleState (uint role, address pCase) public view returns(uint) {\n        return roleBindingState[caseIndex[pCase]][role].bindingState;\n    }\n\n    function nominateCaseCreator (uint rNominee, address nominee, address pCase) public {\n\n        require(actorCount == 1 && BindingPolicy(policyAdr).isCaseCreator(rNominee));\n        \n        uint creatorIndex = actorIndex[nominee] = actorCount++;\n        uint pCaseIndex = caseIndex[pCase] = caseCount++;\n        \n        roleBindingState[pCaseIndex][rNominee] = BindingInfo(creatorIndex, creatorIndex, 0, 0, 3);\n        actorRoles[creatorIndex] = uint(1) << rNominee;\n        \n    }\n    \n    function nominate (uint rNominator, uint rNominee, address nominator, address nominee, address pCase) public {\n\n        // Verify that @processCase is a child in the process hierarchy where root is the process-case provided when nominated the process-creator.\n        // This verification can be done via the RuntimeRegistry in order to keep the consistency between control-flow, worklist and binding-control.\n        \n        uint iNominee = actorIndex[nominee];\n        uint iCase = caseIndex[pCase];\n        uint nomineeMask = uint(1) << rNominee;\n        uint iNominator = actorIndex[nominator];\n\n        // no actor can be BOUND/NOMINATED in pCase, the noinee cannot hold the rNominee role\n        // nominator actor must be binded to a role unless self-nomination is allowed\n        // the role of the nominator is allowed to nominate in the binding policy.\n        // the requested nomination fulfill the conditions defined in the policy by the instructions IN / NOT IN\n        require(roleBindingState[iCase][rNominee].bindingState == 0 && actorRoles[iNominee] & nomineeMask == 0 &&\n                (actorRoles[iNominator] & (uint(1) << rNominator) != 0 || (iNominator == 0 && rNominator == rNominee)) &&\n                (BindingPolicy(policyAdr).canNominate(rNominator, rNominee)) &&\n                (BindingPolicy(policyAdr).assertNConstraint(rNominator, rNominee, actorRoles[iNominee])));\n        \n        // At this point, all the conditions were fulfilled because otherwise an exception was thrown reverting the transaction. Thus the binding is allowed.\n        \n        // Verifying that all the indexes (for actors and process-cases) were already assigned to an index.\n        if(iCase == 0)\n            iCase = caseIndex[pCase] = caseCount++;\n        if(iNominee == 0)\n            iNominee = actorIndex[nominee] = actorCount++;\n        if(iNominator == 0)\n            iNominator = iNominee;\n        \n        // Binding the role and updating the state as NOMINATED(2) or BOUND(3) depending on the nomination require endorsement or not.\n        uint state = BindingPolicy(policyAdr).requireNEndorsement(rNominator, rNominee) ? 2 : 3;\n        \n        roleBindingState[iCase][rNominee] = BindingInfo (iNominator, iNominee, 0, 0, state); \n        if(state == 3)\n            actorRoles[iNominee] |= nomineeMask;\n    }\n    \n    function voteN (uint rNominator, uint rNominee, uint rEndorser, address endorser, address pCase, bool isAccepted) public returns(uint) {\n        //require(runtimeRegistry == msg.sender);\n        \n        uint iCase = caseIndex[pCase];\n        BindingInfo memory roleVState = roleBindingState[iCase][rNominee];\n        \n        // A nomination to endorse must be in NOMINATED state\n        // The endorser must be nominated before (state BOUND) unless the endorser is the nominee accepting the nomination.\n        require(roleVState.bindingState == 2 && \n                (actorRoles[actorIndex[endorser]] & (uint(1) << rEndorser) != 0 || rEndorser == rNominee && roleVState.nominee == actorIndex[endorser]));\n        \n        // This function is responsible to evaluate the endorsment. \n        // An exception reverting the transaction is thwown in case of any invalid operation (e.g wrong endorser). \n        // Thus, this function only returns if the endorsement is performed. \n        uint state = BindingPolicy(policyAdr).assertNVote(rNominator, rNominee, rEndorser, roleVState.endorsedBy, roleVState.rejectedBy, isAccepted);\n            \n        // The storage is only updated if the endorsment is valid and thus performed.\n        roleBindingState[iCase][rNominee].bindingState = state;\n        updateVoteMask(iCase, rNominee, uint(1) << rEndorser, isAccepted);\n        if (state == 0 || state == 3) {\n            roleBindingState[iCase][rNominee].endorsedBy = roleBindingState[iCase][rNominee].rejectedBy = 0;\n            if (state == 3) \n                actorRoles[roleVState.nominee] |= ((uint(1) << rNominee));\n        }\n        return state;\n    }\n    \n    function release (uint rNominator, uint rNominee, address nominator, address pCase) public {\n        //require(runtimeRegistry == msg.sender);\n        \n        uint iCase = caseIndex[pCase];\n        \n        BindingInfo memory roleRState = roleBindingState[iCase][rNominee];\n        \n        // The endorser and the processCase address must be nominated before.\n        // Validating the rNomiator is allowed to release rNominee.\n        // Validating the release is not restricted by a binding constraint.\n        require(roleRState.bindingState == 3 && actorRoles[actorIndex[nominator]] & (uint(1) << rNominator) != 0 && \n                (BindingPolicy(policyAdr).canRelease(rNominator, rNominee)) && \n                (BindingPolicy(policyAdr).assertRConstraint(rNominator, rNominee, actorRoles[roleRState.nominee])));\n        \n        // Unbinding the role and updating the state as UNBINDING or UNBINDED depending on the dismisses require endorsement or not.\n        if(!BindingPolicy(policyAdr).requireREndorsement(rNominator, rNominee)) {\n            roleBindingState[iCase][rNominee].bindingState = 0;\n            actorRoles[roleRState.nominee] &= ~(uint(1) << rNominee);\n        }\n        else\n           roleBindingState[iCase][rNominee].bindingState = 1;\n    }\n    \n    function voteR (uint rNominator, uint rNominee, uint rEndorser, address endorser, address pCase, bool isAccepted) public returns(uint) {\n        // require(runtimeRegistry == msg.sender);\n        \n        uint iCase = caseIndex[pCase];\n        BindingInfo memory roleVRState = roleBindingState[iCase][rNominee];\n        \n        // A release to vote must be in RELEASING state\n        // The endorsed involved in the vote and the processCase address must be nominated before.\n        require(roleVRState.bindingState == 1 && actorRoles[actorIndex[endorser]] & (uint(1) << rEndorser) != 0);\n\n        // This function is responsible to evaluate the endorsment. \n        // An exception reverting the transaction is thwown in case of any invalid operation (e.g wrong endorser). \n        // Thus, that function only returns if the endorsement can be performed. \n        uint state = BindingPolicy(policyAdr).assertRVote(rNominator, rNominee, rEndorser, roleVRState.endorsedBy, roleVRState.rejectedBy, isAccepted);\n            \n        roleBindingState[iCase][rNominee].bindingState = state;\n        updateVoteMask(iCase, rNominee, uint(1) << rEndorser, isAccepted);\n        if (state == 0 || state == 3) {\n            roleBindingState[iCase][rNominee].endorsedBy = roleBindingState[iCase][rNominee].rejectedBy = 0;\n            if (state == 0)\n                actorRoles[roleVRState.nominee] &= ~(uint(1) << rNominee);\n        }\n        return state;\n    }\n        \n    \n    function canPerform(address actor, address pCase, uint taskIndex) public view returns(bool) {\n        bytes32 pId = ControlFlow(registry).bundleFor(pCase);\n        uint tRole = ControlFlow(taskRoleAdr).getRoleFromTask(taskIndex, pId);\n        uint iCase = caseIndex[pCase];\n        while(roleBindingState[iCase][tRole].bindingState != 3) {\n            pCase = ControlFlow(pCase).findParent();\n            if(pCase == address(0))\n                break;\n            iCase = caseIndex[pCase];\n        }\n        return actorIndex[actor] > 0 && roleBindingState[iCase][tRole].nominee == actorIndex[actor];\n    }\n    \n    function updateVoteMask(uint iCase, uint rNominee, uint endorserMask, bool isAccepted) private {\n        if (isAccepted)\n            roleBindingState[iCase][rNominee].endorsedBy |= endorserMask;\n        else\n            roleBindingState[iCase][rNominee].rejectedBy |= endorserMask;\n    }\n}";
const debug = (0, _debug2.default)('caterpillarql:policy');

var _default = async ({
  model,
  registry,
  web3
}) => {
  const contract = await (0, _registryContract.default)({
    address: registry,
    web3
  });
  const policy = await (0, _BindingPolicyGenerator.generatePolicy)(model, 'BindingPolicy');
  debug('=============================================');
  debug("SOLIDITY CODE");
  debug('=============================================');
  debug(policy);
  debug('....................................................................');
  const output = (0, _compile.default)({
    BindingPolicy: {
      content: policy.solidity
    },
    BindingAccessControl: {
      content: bindingAccessControl
    }
  });

  if (!output.contracts || !Object.keys(output.contracts).length) {
    debug('COMPILATION ERROR IN POLICY CONTRACTS');
    debug(output.errors);
    debug('----------------------------------------------------------------------------------------------');
    throw new Error('COMPILATION ERROR IN POLICY CONTRACTS');
  }

  const procContract = new web3.eth.Contract(output.contracts['BindingPolicy']['BindingPolicy_Contract'].abi);
  procContract.transactionConfirmationBlocks = 1;
  const accounts = await web3.eth.personal.getAccounts();
  const result = await procContract.deploy({
    data: '0x' + output.contracts['BindingPolicy']['BindingPolicy_Contract'].evm.bytecode.object
  }).send({
    from: accounts[0],
    gas: 4700000
  });
  let indexToRole = [];

  for (let [role, index] of policy.roleIndexMap) {
    indexToRole[index] = role;
  }

  return _repo.policy.create({
    address: result.address,
    registry: contract.address,
    model: model,
    solidityCode: policy.solidity,
    abi: JSON.stringify(output.contracts.BindingPolicy.BindingPolicy_Contract.abi),
    bytecode: output.contracts.BindingPolicy.BindingPolicy_Contract.evm.bytecode.object,
    indexToRole,
    accessControlAbi: JSON.stringify(output.contracts.BindingAccessControl.BindingAccessControl.abi),
    accessControlBytecode: output.contracts.BindingAccessControl.BindingAccessControl.evm.bytecode.object
  });
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2FwcC9yZXNvbHZlcnMvbXV0YXRpb24vcG9saWN5L2luZGV4LnRzIl0sIm5hbWVzIjpbImRlYnVnIiwibW9kZWwiLCJyZWdpc3RyeSIsIndlYjMiLCJjb250cmFjdCIsImFkZHJlc3MiLCJwb2xpY3kiLCJvdXRwdXQiLCJCaW5kaW5nUG9saWN5IiwiY29udGVudCIsInNvbGlkaXR5IiwiQmluZGluZ0FjY2Vzc0NvbnRyb2wiLCJiaW5kaW5nQWNjZXNzQ29udHJvbCIsImNvbnRyYWN0cyIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJlcnJvcnMiLCJFcnJvciIsInByb2NDb250cmFjdCIsImV0aCIsIkNvbnRyYWN0IiwiYWJpIiwidHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3MiLCJhY2NvdW50cyIsInBlcnNvbmFsIiwiZ2V0QWNjb3VudHMiLCJyZXN1bHQiLCJkZXBsb3kiLCJkYXRhIiwiZXZtIiwiYnl0ZWNvZGUiLCJvYmplY3QiLCJzZW5kIiwiZnJvbSIsImdhcyIsImluZGV4VG9Sb2xlIiwicm9sZSIsImluZGV4Iiwicm9sZUluZGV4TWFwIiwicG9saWN5U2NoZW1hIiwiY3JlYXRlIiwic29saWRpdHlDb2RlIiwiSlNPTiIsInN0cmluZ2lmeSIsIkJpbmRpbmdQb2xpY3lfQ29udHJhY3QiLCJhY2Nlc3NDb250cm9sQWJpIiwiYWNjZXNzQ29udHJvbEJ5dGVjb2RlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUdBLE1BQU1BLEtBQUssR0FBRyxxQkFBTyxzQkFBUCxDQUFkOztlQUVlLE9BQU87QUFDcEJDLEVBQUFBLEtBRG9CO0FBRXBCQyxFQUFBQSxRQUZvQjtBQUdwQkMsRUFBQUE7QUFIb0IsQ0FBUCxLQUlRO0FBQ3JCLFFBQU1DLFFBQVEsR0FBRyxNQUFNLCtCQUFpQjtBQUN0Q0MsSUFBQUEsT0FBTyxFQUFFSCxRQUQ2QjtBQUV0Q0MsSUFBQUE7QUFGc0MsR0FB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QixDQUFzQ0Esb0JBQXRDLENBQTJEVyxHQUExRSxDQVJ0QjtBQVNJeUIsSUFBQUEscUJBQXFCLEVBQUN4QyxNQUFNLENBQUNNLFNBQVAsQ0FBaUJGLG9CQUFqQixDQUFzQ0Esb0JBQXRDLENBQTJEbUIsR0FBM0QsQ0FBK0RDLFFBQS9ELENBQXdFQztBQVRsRyxHQURLLENBQVA7QUFhRCxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWJ1ZyBmcm9tICdkZWJ1ZydcbmltcG9ydCBjb21waWxlIGZyb20gJy4uLy4uL3V0aWwvY29tcGlsZSdcbmltcG9ydCByZWdpc3RyeUNvbnRyYWN0IGZyb20gJy4uLy4uL3V0aWwvcmVnaXN0cnktY29udHJhY3QnXG5pbXBvcnQgeyBwb2xpY3kgYXMgcG9saWN5U2NoZW1hIH0gZnJvbSAnLi4vLi4vcmVwbydcbmltcG9ydCB7Z2VuZXJhdGVQb2xpY3l9IGZyb20gJy4vZHluYW1pY19iaW5kaW5nL3ZhbGlkYXRpb25fY29kZV9nZW4vQmluZGluZ1BvbGljeUdlbmVyYXRvcic7XG5pbXBvcnQgYmluZGluZ0FjY2Vzc0NvbnRyb2wgZnJvbSAnLi9keW5hbWljX2JpbmRpbmcvcnVudGltZV9zb2xpZGl0eS9CaW5kaW5nQWNjZXNzQ29udHJvbC5zb2wnXG5cbmNvbnN0IGRlYnVnID0gX2RlYnVnKCdjYXRlcnBpbGxhcnFsOnBvbGljeScpXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jICh7XG4gIG1vZGVsLFxuICByZWdpc3RyeSxcbiAgd2ViMyxcbn0pOiBQcm9taXNlPG9iamVjdD4gPT4ge1xuICBjb25zdCBjb250cmFjdCA9IGF3YWl0IHJlZ2lzdHJ5Q29udHJhY3Qoe1xuICAgIGFkZHJlc3M6IHJlZ2lzdHJ5LFxuICAgIHdlYjMsXG4gIH0pXG4gIGNvbnN0IHBvbGljeSA9IGF3YWl0IGdlbmVyYXRlUG9saWN5KG1vZGVsLCAnQmluZGluZ1BvbGljeScpO1xuICBkZWJ1ZygnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XG4gIGRlYnVnKFwiU09MSURJVFkgQ09ERVwiKTtcbiAgZGVidWcoJz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PScpO1xuICBkZWJ1Zyhwb2xpY3kpXG4gIGRlYnVnKCcuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLicpO1xuXG4gIGNvbnN0IG91dHB1dCA9IGNvbXBpbGUoe1xuICAgIEJpbmRpbmdQb2xpY3k6IHtcbiAgICAgIGNvbnRlbnQ6IHBvbGljeS5zb2xpZGl0eSxcbiAgICB9LFxuICAgIEJpbmRpbmdBY2Nlc3NDb250cm9sOiB7XG4gICAgICBjb250ZW50OiBiaW5kaW5nQWNjZXNzQ29udHJvbCxcbiAgICB9XG4gIH0pXG4gIGlmICghb3V0cHV0LmNvbnRyYWN0cyB8fCAhT2JqZWN0LmtleXMob3V0cHV0LmNvbnRyYWN0cykubGVuZ3RoKSB7XG4gICAgZGVidWcoJ0NPTVBJTEFUSU9OIEVSUk9SIElOIFBPTElDWSBDT05UUkFDVFMnKTtcbiAgICBkZWJ1ZyhvdXRwdXQuZXJyb3JzKTtcbiAgICBkZWJ1ZygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgIHRocm93IG5ldyBFcnJvcignQ09NUElMQVRJT04gRVJST1IgSU4gUE9MSUNZIENPTlRSQUNUUycpXG4gIH1cbiAgY29uc3QgcHJvY0NvbnRyYWN0ID0gbmV3IHdlYjMuZXRoLkNvbnRyYWN0KG91dHB1dC5jb250cmFjdHNbJ0JpbmRpbmdQb2xpY3knXVsnQmluZGluZ1BvbGljeV9Db250cmFjdCddLmFiaSk7XG4gIHByb2NDb250cmFjdC50cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyA9IDFcblxuICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHdlYjMuZXRoLnBlcnNvbmFsLmdldEFjY291bnRzKClcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY0NvbnRyYWN0XG4gICAgLmRlcGxveSh7XG4gICAgICBkYXRhOiAnMHgnICsgb3V0cHV0LmNvbnRyYWN0c1snQmluZGluZ1BvbGljeSddWydCaW5kaW5nUG9saWN5X0NvbnRyYWN0J10uZXZtLmJ5dGVjb2RlLm9iamVjdFxuICAgIH0pXG4gICAgLnNlbmQoe1xuICAgICAgZnJvbTogYWNjb3VudHNbMF0sXG4gICAgICBnYXM6IDQ3MDAwMDAsXG4gICAgfSlcbiAgXG4gIGxldCBpbmRleFRvUm9sZSA9IFtdO1xuICBmb3IgKGxldCBbcm9sZSwgaW5kZXhdIG9mIHBvbGljeS5yb2xlSW5kZXhNYXApIHtcbiAgICAgIGluZGV4VG9Sb2xlW2luZGV4XSA9IHJvbGU7XG4gIH1cbiAgcmV0dXJuIHBvbGljeVNjaGVtYS5jcmVhdGUoXG4gICAge1xuICAgICAgICBhZGRyZXNzOiByZXN1bHQuYWRkcmVzcyxcbiAgICAgICAgcmVnaXN0cnk6IGNvbnRyYWN0LmFkZHJlc3MsXG4gICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgc29saWRpdHlDb2RlOiBwb2xpY3kuc29saWRpdHksXG4gICAgICAgIGFiaTogSlNPTi5zdHJpbmdpZnkob3V0cHV0LmNvbnRyYWN0cy5CaW5kaW5nUG9saWN5LkJpbmRpbmdQb2xpY3lfQ29udHJhY3QuYWJpKSxcbiAgICAgICAgYnl0ZWNvZGU6IG91dHB1dC5jb250cmFjdHMuQmluZGluZ1BvbGljeS5CaW5kaW5nUG9saWN5X0NvbnRyYWN0LmV2bS5ieXRlY29kZS5vYmplY3QsXG4gICAgICAgIGluZGV4VG9Sb2xlLFxuICAgICAgICBhY2Nlc3NDb250cm9sQWJpOiBKU09OLnN0cmluZ2lmeShvdXRwdXQuY29udHJhY3RzLkJpbmRpbmdBY2Nlc3NDb250cm9sLkJpbmRpbmdBY2Nlc3NDb250cm9sLmFiaSksXG4gICAgICAgIGFjY2Vzc0NvbnRyb2xCeXRlY29kZTpvdXRwdXQuY29udHJhY3RzLkJpbmRpbmdBY2Nlc3NDb250cm9sLkJpbmRpbmdBY2Nlc3NDb250cm9sLmV2bS5ieXRlY29kZS5vYmplY3QsXG4gICAgfSxcbiAgKVxufSJdfQ==