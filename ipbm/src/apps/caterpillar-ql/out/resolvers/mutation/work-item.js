"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _debug2 = _interopRequireDefault(require("debug"));

var _repo = require("../repo");

var _registryContract = _interopRequireDefault(require("../util/registry-contract"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)('caterpillarql:mutation:work-item');

var _default = async ({
  id,
  worklist,
  from,
  parameters,
  registry,
  web3
}) => {
  debug({
    worklist
  });

  if (!web3.utils.isAddress(from)) {
    throw new Error('User is not a valid address');
  }

  const contract = await (0, _registryContract.default)({
    address: registry,
    web3
  });
  const worklistId = await contract.worklistBundleFor({
    address: worklist
  });
  debug({
    worklistId
  });
  const [model] = await _repo.process.find({
    _id: worklistId
  });
  const worklistInstance = new web3.eth.Contract(JSON.parse(model.worklistAbi), worklist);
  const processAddress = await worklistInstance.methods.processInstanceFor(parseInt(id)).call();
  let nodeIndex = await worklistInstance.methods.elementIndexFor(id).call();
  debug({
    nodeIndex
  });
  const node = model.indexToElement[nodeIndex.toNumber()];
  debug('about to fire method', worklist, from, node.name, ...[id, ...parameters]);
  const ddd = await worklistInstance.methods[node.name](...[id, ...parameters.map(p => true)]).send({
    from,
    gas: 4700000
  }).on('receipt', receipt => {
    debug({
      receipt
    });
  });
  debug({
    ddd
  }); // to do get the worklist address...

  return {
    address: processAddress,
    id: model.id,
    registryContract: contract
  };
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2FwcC9yZXNvbHZlcnMvbXV0YXRpb24vd29yay1pdGVtLnRzIl0sIm5hbWVzIjpbImRlYnVnIiwiaWQiLCJ3b3JrbGlzdCIsImZyb20iLCJwYXJhbWV0ZXJzIiwicmVnaXN0cnkiLCJ3ZWIzIiwidXRpbHMiLCJpc0FkZHJlc3MiLCJFcnJvciIsImNvbnRyYWN0IiwiYWRkcmVzcyIsIndvcmtsaXN0SWQiLCJ3b3JrbGlzdEJ1bmRsZUZvciIsIm1vZGVsIiwicHJvY2Vzc1NjaGVtYSIsImZpbmQiLCJfaWQiLCJ3b3JrbGlzdEluc3RhbmNlIiwiZXRoIiwiQ29udHJhY3QiLCJKU09OIiwicGFyc2UiLCJ3b3JrbGlzdEFiaSIsInByb2Nlc3NBZGRyZXNzIiwibWV0aG9kcyIsInByb2Nlc3NJbnN0YW5jZUZvciIsInBhcnNlSW50IiwiY2FsbCIsIm5vZGVJbmRleCIsImVsZW1lbnRJbmRleEZvciIsIm5vZGUiLCJpbmRleFRvRWxlbWVudCIsInRvTnVtYmVyIiwibmFtZSIsImRkZCIsIm1hcCIsInAiLCJzZW5kIiwiZ2FzIiwib24iLCJyZWNlaXB0IiwicmVnaXN0cnlDb250cmFjdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBOztBQUtBOzs7O0FBS0EsTUFBTUEsS0FBSyxHQUFHLHFCQUFPLGtDQUFQLENBQWQ7O2VBRWUsT0FBTztBQUNwQkMsRUFBQUEsRUFEb0I7QUFFcEJDLEVBQUFBLFFBRm9CO0FBR3BCQyxFQUFBQSxJQUhvQjtBQUlwQkMsRUFBQUEsVUFKb0I7QUFLcEJDLEVBQUFBLFFBTG9CO0FBTXBCQyxFQUFBQTtBQU5vQixDQUFQLEtBT1E7QUFDckJOLEVBQUFBLEtBQUssQ0FBQztBQUFFRSxJQUFBQTtBQUFGLEdBQUQsQ0FBTDs7QUFDQSxNQUFJLENBQUNJLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUFYLENBQXFCTCxJQUFyQixDQUFMLEVBQWlDO0FBQy9CLFVBQU0sSUFBSU0sS0FBSixDQUFVLDZCQUFWLENBQU47QUFDRDs7QUFDRCxRQUFNQyxRQUFRLEdBQUcsTUFBTSwrQkFBaUI7QUFDdENDLElBQUFBLE9BQU8sRUFBRU4sUUFENkI7QUFFdENDLElBQUFBO0FBRnNDLEdBQWpCLENBQXZCO0FBSUEsUUFBTU0sVUFBVSxHQUFHLE1BQU1GLFFBQVEsQ0FDOUJHLGlCQURzQixDQUNKO0FBQ2pCRixJQUFBQSxPQUFPLEVBQUVUO0FBRFEsR0FESSxDQUF6QjtBQUlBRixFQUFBQSxLQUFLLENBQUM7QUFBRVksSUFBQUE7QUFBRixHQUFELENBQUw7QUFDQSxRQUFNLENBQUNFLEtBQUQsSUFBVSxNQUFNQyxjQUNuQkMsSUFEbUIsQ0FDZDtBQUNKQyxJQUFBQSxHQUFHLEVBQUVMO0FBREQsR0FEYyxDQUF0QjtBQUtBLFFBQU1NLGdCQUFnQixHQUFHLElBQUlaLElBQUksQ0FBQ2EsR0FBTCxDQUFTQyxRQUFiLENBQXNCQyxJQUFJLENBQUNDLEtBQUwsQ0FBV1IsS0FBSyxDQUFDUyxXQUFqQixDQUF0QixFQUFxRHJCLFFBQXJELENBQXpCO0FBRUEsUUFBTXNCLGNBQWMsR0FBRyxNQUFNTixnQkFBZ0IsQ0FDMUNPLE9BRDBCLENBRTFCQyxrQkFGMEIsQ0FFUEMsUUFBUSxDQUFDMUIsRUFBRCxDQUZELEVBRzFCMkIsSUFIMEIsRUFBN0I7QUFLQSxNQUFJQyxTQUFTLEdBQUcsTUFBTVgsZ0JBQWdCLENBQ25DTyxPQURtQixDQUVuQkssZUFGbUIsQ0FFSDdCLEVBRkcsRUFHbkIyQixJQUhtQixFQUF0QjtBQUlFNUIsRUFBQUEsS0FBSyxDQUFDO0FBQUU2QixJQUFBQTtBQUFGLEdBQUQsQ0FBTDtBQUVGLFFBQU1FLElBQUksR0FBR2pCLEtBQUssQ0FDZmtCLGNBRFUsQ0FDS0gsU0FBUyxDQUFDSSxRQUFWLEVBREwsQ0FBYjtBQUVBakMsRUFBQUEsS0FBSyxDQUFDLHNCQUFELEVBQXlCRSxRQUF6QixFQUFtQ0MsSUFBbkMsRUFBeUM0QixJQUFJLENBQUNHLElBQTlDLEVBQW9ELEdBQUcsQ0FBQ2pDLEVBQUQsRUFBSyxHQUFHRyxVQUFSLENBQXZELENBQUw7QUFDQSxRQUFNK0IsR0FBRyxHQUFHLE1BQU1qQixnQkFBZ0IsQ0FDL0JPLE9BRGUsQ0FDUE0sSUFBSSxDQUFDRyxJQURFLEVBRWQsR0FBRyxDQUFDakMsRUFBRCxFQUFLLEdBQUdHLFVBQVUsQ0FBQ2dDLEdBQVgsQ0FBZUMsQ0FBQyxJQUFJLElBQXBCLENBQVIsQ0FGVyxFQUlmQyxJQUplLENBSVY7QUFDSm5DLElBQUFBLElBREk7QUFFSm9DLElBQUFBLEdBQUcsRUFBRTtBQUZELEdBSlUsRUFRZkMsRUFSZSxDQVNkLFNBVGMsRUFXWkMsT0FERixJQUVXO0FBQ1R6QyxJQUFBQSxLQUFLLENBQUM7QUFBRXlDLE1BQUFBO0FBQUYsS0FBRCxDQUFMO0FBQ0QsR0FkYSxDQUFsQjtBQWdCQXpDLEVBQUFBLEtBQUssQ0FBQztBQUFFbUMsSUFBQUE7QUFBRixHQUFELENBQUwsQ0FuRHFCLENBb0RyQjs7QUFDQSxTQUFPO0FBQ0x4QixJQUFBQSxPQUFPLEVBQUVhLGNBREo7QUFFTHZCLElBQUFBLEVBQUUsRUFBRWEsS0FBSyxDQUFDYixFQUZMO0FBR0x5QyxJQUFBQSxnQkFBZ0IsRUFBRWhDO0FBSGIsR0FBUDtBQUtELEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2RlYnVnIGZyb20gJ2RlYnVnJ1xuXG5pbXBvcnQge1xuICByb2xlVGFzayBhcyByb2xlVGFza1NjaGVtYSxcbiAgcG9saWN5IGFzIHBvbGljeVNjaGVtYSxcbiAgcHJvY2VzcyBhcyBwcm9jZXNzU2NoZW1hXG59IGZyb20gJy4uL3JlcG8nXG5pbXBvcnQgcmVnaXN0cnlDb250cmFjdCBmcm9tICcuLi91dGlsL3JlZ2lzdHJ5LWNvbnRyYWN0J1xuaW1wb3J0IGhleFRvSWQgZnJvbSAnLi4vdXRpbC9oZXgtdG8taWQnXG5pbXBvcnQgZmluZFJvbGVNYXAgZnJvbSAnLi4vdXRpbC9maW5kLXJvbGUtbWFwJ1xuaW1wb3J0IGNyZWF0ZUNvbnRyYWN0IGZyb20gJy4uL3V0aWwvY3JlYXRlLWNvbnRyYWN0J1xuXG5jb25zdCBkZWJ1ZyA9IF9kZWJ1ZygnY2F0ZXJwaWxsYXJxbDptdXRhdGlvbjp3b3JrLWl0ZW0nKVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyAoe1xuICBpZCxcbiAgd29ya2xpc3QsXG4gIGZyb20sXG4gIHBhcmFtZXRlcnMsXG4gIHJlZ2lzdHJ5LFxuICB3ZWIzLFxufSk6IFByb21pc2U8b2JqZWN0PiA9PiB7XG4gIGRlYnVnKHsgd29ya2xpc3QgfSlcbiAgaWYgKCF3ZWIzLnV0aWxzLmlzQWRkcmVzcyhmcm9tKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVXNlciBpcyBub3QgYSB2YWxpZCBhZGRyZXNzJylcbiAgfVxuICBjb25zdCBjb250cmFjdCA9IGF3YWl0IHJlZ2lzdHJ5Q29udHJhY3Qoe1xuICAgIGFkZHJlc3M6IHJlZ2lzdHJ5LFxuICAgIHdlYjMsXG4gIH0pXG4gIGNvbnN0IHdvcmtsaXN0SWQgPSBhd2FpdCBjb250cmFjdFxuICAgIC53b3JrbGlzdEJ1bmRsZUZvcih7XG4gICAgICBhZGRyZXNzOiB3b3JrbGlzdCxcbiAgICB9KVxuICBkZWJ1Zyh7IHdvcmtsaXN0SWQgfSlcbiAgY29uc3QgW21vZGVsXSA9IGF3YWl0IHByb2Nlc3NTY2hlbWFcbiAgICAuZmluZCh7XG4gICAgICBfaWQ6IHdvcmtsaXN0SWQsXG4gICAgfSlcbiAgXG4gIGNvbnN0IHdvcmtsaXN0SW5zdGFuY2UgPSBuZXcgd2ViMy5ldGguQ29udHJhY3QoSlNPTi5wYXJzZShtb2RlbC53b3JrbGlzdEFiaSksIHdvcmtsaXN0KVxuXG4gIGNvbnN0IHByb2Nlc3NBZGRyZXNzID0gYXdhaXQgd29ya2xpc3RJbnN0YW5jZVxuICAgIC5tZXRob2RzXG4gICAgLnByb2Nlc3NJbnN0YW5jZUZvcihwYXJzZUludChpZCkpXG4gICAgLmNhbGwoKVxuXG4gIGxldCBub2RlSW5kZXggPSBhd2FpdCB3b3JrbGlzdEluc3RhbmNlXG4gICAgLm1ldGhvZHNcbiAgICAuZWxlbWVudEluZGV4Rm9yKGlkKVxuICAgIC5jYWxsKClcbiAgICBkZWJ1Zyh7IG5vZGVJbmRleCB9KVxuICAgIFxuICBjb25zdCBub2RlID0gbW9kZWxcbiAgICAuaW5kZXhUb0VsZW1lbnRbbm9kZUluZGV4LnRvTnVtYmVyKCldXG4gIGRlYnVnKCdhYm91dCB0byBmaXJlIG1ldGhvZCcsIHdvcmtsaXN0LCBmcm9tLCBub2RlLm5hbWUsIC4uLltpZCwgLi4ucGFyYW1ldGVyc10pXG4gIGNvbnN0IGRkZCA9IGF3YWl0IHdvcmtsaXN0SW5zdGFuY2VcbiAgICAubWV0aG9kc1tub2RlLm5hbWVdKFxuICAgICAgLi4uW2lkLCAuLi5wYXJhbWV0ZXJzLm1hcChwID0+IHRydWUpXSxcbiAgICApXG4gICAgLnNlbmQoe1xuICAgICAgZnJvbSxcbiAgICAgIGdhczogNDcwMDAwMCxcbiAgICB9KVxuICAgIC5vbihcbiAgICAgICdyZWNlaXB0JyxcbiAgICAgIChcbiAgICAgICAgcmVjZWlwdDogYW55LFxuICAgICAgKTogdm9pZCA9PiB7XG4gICAgICAgIGRlYnVnKHsgcmVjZWlwdCB9KVxuICAgICAgfSxcbiAgICApXG4gIGRlYnVnKHsgZGRkIH0pXG4gIC8vIHRvIGRvIGdldCB0aGUgd29ya2xpc3QgYWRkcmVzcy4uLlxuICByZXR1cm4ge1xuICAgIGFkZHJlc3M6IHByb2Nlc3NBZGRyZXNzLFxuICAgIGlkOiBtb2RlbC5pZCxcbiAgICByZWdpc3RyeUNvbnRyYWN0OiBjb250cmFjdFxuICB9ICAgICAgICAgICBcbn0iXX0=